# 图

主要了解概念，算法具体实现不是重点。

## 基本概念

### 图的定义

图是顶点集和边集构成的二元组，即图$G$由顶点集$V$和边集$E$组成，记为$G=(V,E)$，其中$V(G)$表示图$G$中顶点的有限非空集，$E(G)$表示图$G$中顶点之间的关系（边）集合。

若$V=\{v_1,v_2\cdots,v_n\}$，则用$\vert V\vert$表示图$G$中顶点的个数，也称图$G$的阶，$E=\{(u,v)\vert u\in V,v\in V\}$，用$\vert E\vert$表示图$G$中边的条数。

图一定是非空的，即$V$一定是非空集。

### 图的类别

+ 无向图：若$E$是无向边（简称边）的有限集合时，则图$G$为无向图。边是顶点的无序对，记为$(v,w)$或$(w,v)$，因为$(v,w)=(w,v)$，其中$v$、$w$是顶点。可以说顶点$w$和顶点$v$互为邻接点。边$(v,w)$依附于顶点$w$和$v$，或者说边$(v,w)$和顶点$v$、$w$相关联。
+ 有向图：若$E$是有向边（也称弧）的有限集合时，则图$G$为有向图。弧是顶点的有序对，记为$<v,w>$，其中$v$、$w$是顶点，$v$称为弧尾，$w$称为弧头，$<v,w>$称为从顶点$v$到顶点$w$的弧，也称$v$邻接到$w$，或$w$邻接自$v$。$<v,w>\neq<w,v>$。
+ 简单图：不存在重复边，且不存在顶点到自身的边。一般的图默认是简单图。
+ 多重图：图$G$中某两个结点之间的边数多于一条，又允许顶点通过同一条边与自己关联。
+ 无向完全图：对于无向图$\vert E\vert\in[0,n(n-1)/2]$，无向图中任意两个顶点之间都存在边。
+ 有向完全图：对于有向图$\vert E\vert\in[0,n(n-1)]$，有向图中任意两个顶点之间都存在方向相反的两条弧。
+ 稀疏图：一般$\vert E\vert<\vert V\vert\log\vert V\vert$的图。
+ 稠密图：一般$\vert E\vert>\vert V\vert\log\vert V\vert$的图。
+ 树：不存在回路，且连通的无向图。
+ 有向树：一个顶点的入度为$0$，其余顶点入度均为$1$的有向图。

### 顶点的度

对于无向图，顶点$v$的度是指依附于该顶点的边的条数，记为$TD(v)$。$\sum\limits_{i=1}^nTD(v_i)=2\vert E\vert$。

对于具有$n$个顶点，$e$条边的无向图，$\sum\limits_{i=1}^nTD(v_i)=2e$，即无向图的全部顶点的度的和等于边数的两倍。

对于有向图，入度是指以顶点$v$为终点的有向边的条数，记为$ID(v)$；出度指以顶点$v$为起点的有向边的条数，记为$OD(v)$；顶点$v$的度就是其入度和出度之和，即$TD(v)=ID(v)+OD(v)$。$\sum\limits_{i=1}^nID(v_i)=\sum\limits_{i=1}^nOD(v_i)=\vert E\vert$。因为每条有向边都有一个起点和重点。

### 顶点的关系

+ 路径：从一个点到另一个点所经过的顶点序列。由顶点和相邻顶点序偶构成的边所形成的序列。
+ 回路（环）：第一个顶点与最后一个顶点相同的路径。
+ 长度（无权图）：沿路径所经过的边数成为该路径的长度。
+ 简单路径：路径中的顶点不重复出现。
+ 简单回路：由简单路径组成的回路。（除第一个和最后一个顶点外其余顶点不重复出现的回路）
+ 点到点的距离：从顶点$u$到顶点$v$的最短路径若存在，则此路径的长度就是从$u$到$v$的路径，若不存在路径，则记该路径为无穷。

若一个图有$n$个顶点，有大于$n-1$条边，则此图一定有环。

### 图的连通

+ 连通：在无向图中，若从顶点$v$到顶点$u$有路径存在，则称$uv$是连通的。
+ 强连通：在有向图中，若从顶点$v$到顶点$u$和从顶点$u$到顶点$v$之间都有路径，则称强连通。
+ 连通图：无向图中任意两个顶点之间都是连通的。对于$n$个顶点的无向图，若其是连通图，则最少需要$n-1$条边，若其是非连通图，则最多有$C_{n-1}^2$条边。
+ 强连通图：有向图中任意两个顶点之间都是强连通的。对于$n$个顶点的有相同，若其是强连通图，则最少需要$n$条边来形成环路。
+ 子图：设有两个图$G=(V,E)$和$G'=(V',E')$，若$V'$是$V$的子集，$E'$是$E$的子集，则$G'$是$G$的子图。
+ 生成子图：若有满足$V(G')=V(G)$的子图$G'$，则$G'$是$G$的生成子图。
+ 连通分量：无向图$G$中的极大连通子图称为$G$的连通分量；对任何连通图而言，连通分量就是其自身。
+ 强连通分量：有向图$G$中的极大连通子图称为$G$的强连通分量；对任何强连通图而言，强连通分量就是其自身。
+ 生成树：包含连通图中全部顶点的一个极小连通子图。若图的顶点为$n$，则其生成树包含$n-1$条边，若去掉生成树的一条边则会变成非连通图，若加上一条边则会形成一个回路。
+ 生成森林：在非连通图中，连通分量的生成树构成了非连通图的生成森林。

无向图研究连通性，有向图研究强连通性。

区分极大连通子图和极小连通子图。极大连通子图是无向图的连通分量，极大即要求该连通子图包含其所有的边；极小连通子图是既要保持图连通又要使得边数最少的子图。

### 图的权

+ 边的权：在一个图中，每条边都可以表上具有某种含义的数值，这就是该边的权值。
+ 网络（网）：若图中的每条边都有权，这个带权图被称为网。
+ 带权路径长度：取沿路径各边的权之和作为此路径的长度。

#### 无权图

若$v[i][j]=0$，表示$v_{i+1}$到$v_{j+1}$是不连通的，若$v[i][j]=1$，表示$v_{i+1}$到$v_{j+1}$是连通的。

#### 网

若$v[i][j]=\infty$，表示$v_{i+1}$到$v_{j+1}$是不连通的，若$v[i][j]=$某权值，表示$v_{i+1}$到$v_{j+1}$是连通的。

## 图的存储结构

### 邻接矩阵

用一个一维数组保存顶点，用一个二维数组保存边，这个二维数组就是邻接矩阵。

使用一个长宽皆为$\vert v\vert$的二维矩阵$v$，从左上角到右上角，从左上角到左下角，分别标识表示$v_1,v_2\cdots,v_n$。

<!-- 假设矩阵的索引从$0$开始，而结点编号从$1$开始。 -->

若$(v_i,v_j)$是$E(G)$中的边矩阵$A[i][j]$就设为$1$，否则是$0$。

对于带权图而言，保存的是对应的权值。

+ 对于无向图，第$i$个结点的度=第$i$行或第$i$列的非零元素个数。
+ 对于有向图，第$i$个结点的入度=第$i$行的非零元素个数；第$i$个结点的出度=第$i$列的非零元素个数；第$i$个结点的度=第$i$行的非零元素个数+第$i$列的非零元素个数。

空间复杂度是$O(\vert V\vert^2)$。

适用于存储稠密图。

对于无向图，因为没有方向，所以只有两点连接就是连通的，从而无向图的邻接矩阵都是主对角线对称的。因为对称，所以可以压缩存储。

设图$G$的邻接矩阵为$A$，矩阵元素为$0$或$1$，则$A^n$的元素$A^n[i][j]$表示由顶点$v_{i+1}$到结点$v_{j+1}$的长度为$n$的路径的数目。

### 邻接表

对于稀疏图临界矩阵浪费空间，使用邻接表回更方便。

邻接表存储方式是顺序存储与链式存储的结合，存储方式和树的孩子表示法类似。

使用一个数组顺序保存图的每一个结点，称为顶点表，使用链式存储让每一个结点元素包含一个指向后一条边的指针，称为边表。

对于无向图，因为同一条边两端的点会重复存储，所以空间复杂度为$O(\vert V\vert+2\vert E\vert)$，而对于有向图空间复杂度为$O(\vert V\vert+\vert E\vert)$。

+ 对于无向图，每个结点的边链表的结点数就是该结点的度。
+ 对于有向图，每个结点的边链表的结点数就是该结点的出度，而对于入度就只能遍历所有结点的结点链表。

邻接表的表示方式是不唯一的。

### 十字链表

十字链表置用于存储有向图。可以解决邻接矩阵空间复杂度高和邻接表计算入度入边不方便的问题。

十字链表定义了两种结点：

+ 顶点结点：用于表示顶点，被一个数组包裹。
  + 数据域。
  + 该顶点作为弧头的第一条弧。
  + 该顶点作为弧尾的第一条弧。
+ 弧结点：被顶点结点指向的结点。
  + 弧尾顶点编号。
  + 弧头顶点编号。
  + 权值。
  + 弧头相同的下一条弧。
  + 弧尾相同的下一条弧。

空间复杂度为$O(\vert V\vert+\vert E\vert)$。

### 邻接多重表

邻接多重表用于存储无向图，可以解决邻接矩阵空间复杂度高和邻接表删除插入结点不方便的问题。

邻接多重表定义了两种结点：

+ 顶点结点：用于表示顶点，被一个数组包裹。
  + 数据域。
  + 该顶点相连的第一条边。
+ 边结点：被顶点结点指向的结点。
  + 边一端编号$i$。
  + 边另一端编号$j$。
  + 权值。
  + 依附于$i$的下一条边。
  + 依附于$j$的下一条边。

空间复杂度为$O(\vert V\vert+\vert E\vert)$。

## 图的基本操作

### 图查找

#### 查找边

使用邻接矩阵只用根据对应行列的元素是否为1或某值就可以了，如果是0或无穷，就代表没有该邻边。时间复杂度为$O(1)$。

而使用邻接矩阵需要从一端点出发遍历对应的结点链表，如果能在链表中找到另一端点的索引，就代表有边。时间复杂度为$O(1)$到$O(\vert V\vert)$。

#### 查找点邻边

对于无向图，邻接矩阵需要遍历对应结点的那一行，所有数值为1或某数值的列就是对应的有边的另一个端点。时间复杂度为$O(\vert V\vert)$。

对于有向图，邻接矩阵需要遍历对应结点的那一行得到出边以及那一列代表入边，所有数值为1或某数值的列就是对应的有边的另一个端点。时间复杂度为$O(\vert V\vert)$。

对于无向图，邻接表只用遍历对应结点的结点链表就可以。时间复杂度为$O(1)$到$O(\vert V\vert)$。

对于有向图，邻接表用遍历对应结点的结点链表得到出边，而对于入边需要遍历所有邻接表的边结点。出边时间复杂度为$O(1)$到$O(\vert V\vert)$，入边时间复杂度为$O(\vert E\vert)$。

#### 查找头邻接点

邻接矩阵只用扫描对应的行，找到结点就可以了。时间复杂度为$O(1)$到$O(\vert V\vert)$。

对于无向图，邻接表只用找到结点的边结点的第一个结点。时间复杂度为$O(1)$。

对于有向图，出边邻接表只用找到结点的边结点的第一个结点。时间复杂度为$O(1)$。而对于入边需要遍历所有的结点的第一个链表结点。时间复杂度为$O(1)$到$O(\vert E\vert)$。

#### 查找下一个邻接点

邻接矩阵只用扫描对应的行，找到结点就可以了。时间复杂度为$O(1)$到$O(\vert V\vert)$。

邻接表只用找到当前结点的下一个结点。时间复杂度为$O(1)$。

### 图插入

邻接矩阵只用在最后增加一行一列。时间复杂度是$O(1)$。

邻接表只用在存储结点的数组的末尾添加一个结点，指针设置为NULL。时间复杂度是$O(1)$。

### 图删除

邻接矩阵的删除元素分为两种方式，如果是直接删除对应元素行与列上的所有元素并移动其他元素，那么时间复杂度就是$O(\vert V\vert^2)$，如果删除对应元素行与列上的所有元素但是不移动其他元素，而是将保存结点数据的数组中对应结点的数据变为NULL，则时间复杂度就是$O(\vert V\vert)$。

对于无向图，邻接表的删除需要删除该结点并删除结点后连接的所有结点链表元素，时间复杂度为$O(1)$到$O(\vert V\vert)$。

对于有向图，邻接表的删除需要删除该结点并删除结点后连接的所有结点链表元素且还要遍历所有的边并删除，删除出边时间复杂度为$O(1)$到$O(\vert V\vert)$，删除入边时间复杂度为$O(\vert E\vert)$。

### 图遍历

分为广度优先BFS与深度优先DFS。

#### 广度优先遍历

+ 找到一个与顶点相邻的所有结点。
+ 标记哪些结点被访问过。
+ 需要一个辅助队列保存结点是否被访问的数据。

广度优先遍历过程：

1. 访问顶点v。
2. 访问v的所有未被访问的邻接点。
3. 依次从这些邻接点（在步骤二中访问的顶点）出发，访问它们的所有未被访问的邻接点; 依此类推，直到图中所有访问过的顶点的邻接点都被访问。

邻接矩阵实现时的时间复杂度为$O(\vert V\vert^2)$，邻接表实现时的时间复杂度为$O(\vert V\vert+\vert E\vert)$；空间复杂度为$O(\vert V\vert)$。

广度优先生成树：根据广度优先遍历可以将所有第一次访问结点时的路径组合生成一个广度优先生成树，若图结点为n个，则生成树边一共有n-1条。因为保存图的数据结构若是不唯一，则其广度优先生成树也是不唯一的。
广度优先生成森林：若图是不连通的，那会生成连通分量个广度优先生成树，就构成了广度优先生成森林。

#### 深度优先遍历

类似于树的先根遍历。

深度优先遍历过程：

1. 访问顶点v。
2. 依次从v的未被访问的邻接点出发，对图进行深度优先遍历。
3. 直至图中和v有路径相通的顶点都被访问。
4. 若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到图中所有顶点均被访问过为止。

邻接矩阵实现时的时间复杂度为$O(\vert V\vert^2)$，邻接表实现时的时间复杂度为$O(\vert V\vert+\vert E\vert)$；空间复杂度为$O(\vert V\vert)$。

邻接表的深度优先序列会优先选择每个结点的第一个相邻结点，即结点链中的第一个元素。

邻接矩阵方式唯一所以深度优先序列唯一，而邻接表方式不唯一，所以深度优先序列不唯一。

深度优先生成树：根据深度优先遍历可以将所有第一次访问结点时的路径组合生成一个深度优先生成树，若图结点为n个，则生成树边一共有n-1条。因为保存图的数据结构若是不唯一，则其深度优先生成树也是不唯一的。
深度优先生成森林：若图是不连通的，那会生成连通分量个深度优先生成树，就构成了深度优先生成森林。

#### 图遍历与图连通性

若起始顶点到其他各顶点都有路径，那么只需调用一次深度优先或广度优先遍历函数。

对强连通图，从任意一结点出发都只用调用一次深度优先或广度优先遍历函数。

## 图的应用

### 最小生成树

#### 最小生成树定义

最小生成树MST也是最小代价树。已知生成树就是最小边的能到任意结点的树，这种树只关心边数，所以有多个不同的生成树。

而最小生成树就是带权生成树的最小权值和的情况。

设R为图G的所有生成树的集合，若T为R中边的权值之和最小的生成树，则T称G的最小生成树。

+ 最小生成树可能有多个，但是边的权值总是唯一且最小的。
+ 最小生成树的边数=顶点数-1。减去一条则不连通，增加一条则会出现回路。
+ 若一个连通图本身就是一棵树，则其最小生成树就是其本身。
+ 只用连通图才有生成树，非连通图只有生成森林。

#### Prim算法

普里姆算法：从某个顶点开始构建生成树，每次将代价最小的新顶点纳入生成树，直到所有顶点都纳入为止。

时间复杂度为$O(\vert V\vert^2)$，适用于边稠密图。

#### Kruskal算法

克鲁斯卡尔算法：每次选择一条权值最小的边，使这条边的两头连通，若本就连通的就不选，直到所有的结点都连通。

时间复杂度为$O(\vert E\vert\log_2\vert E\vert)$，适用于边稀疏图。

### 最短路径

+ 单源最短路径：单个结点到图的其他结点的最短路径。
  + BFS算法（无权图）。
  + Dijkstra算法（带权图、无权图）。
+ 每对顶点间最短路径：每个结点之间的最短路径。
  + Floyd算法（带权图、无权图）。

#### BFS算法

广度优先算法可以计算无权图的单源最短路径。

实际上无权图可以视为一种特殊的带权图，只是每条边的权值全部为1。

广度优先算法基本上就是对广度优先遍历的改进。定义两个数组，索引号就代表元素的序号，一个数组表示从起点开始到该点的最短路径长度，另一个数组表示从起点开始到该点的最短路径的上一个结点的索引值。

#### Dijkstra算法

1. 从$v_0$开始，初始化三个数组：标记各顶点是否已找到最短路径；最短路径长度；最短路径上的前驱。
2. 遍历所有结点，找到还没确定最短路径，且最短路径长度值最小的的一个顶点，这就确定了下一个最短路径的结点，令其各顶点是否已找到最短路径的值为true。
3. 检查所有邻接这个结点的其他结点，若其点还没有找到最短路径，则更新最短路径长度值与最短路径上前驱的值。
4. 重复步骤二再次循环遍历所有结点并找到没确定最短路径则最短路径长度最小的顶点。

Dijkstra算法与Prim算法类似，都是优先与最短的路径结合。

时间复杂度为$O(\vert V\vert^2)$。

当权值中含有负权值的时候可能Dijkstra算法会失效。

#### Floyd算法

是一种动态规划算法，将问题的求解分为多个阶段。

对于n个结点的图G，求任意一对顶点$v_i$到$v_j$之间的最短路径可分为如下阶段：

1. 初始化：不允许在其他顶点中转，求最短路径。
2. 若允许在$v_0$中转，求最短路径。
3. 若允许在$v_0$、$v_1$中转，求最短路径。
4. ...
5. 若允许在$v_0$、$v_1\cdots v_{n-1}$中转，求最短路径。

算法需要遍历n次，每次遍历都需要查看n×n的矩阵中是否有更优的中转点。

时间复杂度为$O(\vert V\vert^3)$，空间复杂度为$O(\vert V\vert^2)$。

Floyd算法复杂度高，所以基本上都是四个结点以下的图，能解决带负权值的问题，但是不能解决带有负权回路的图，即有负权值的边组成回路，这种图可能没有最短路径。

### 有向无环图

若一个有向图中不存在环，则是有向无环图，简称DAG图。

有向无环图可以运用到表达式的表达上，将操作数共同的结点部分删除并将边合并到一起，这就形成了图。

顶点中不可能出现重复的操作数。

1. 把各个单个的操作数不重复的排成一排。
2. 标出各个运算符的生效顺序。
3. 按顺序加入运算符，并注意对运算符的优先级进行分层。
4. 当构建完成后从底向上逐层检查同层的运算符是否可以合并。

### 拓扑排序

AOV网：用DAG图表示一个工程，顶点表示活动，有向边$<v_i,v_j>$表示活动$v_i$必须先于活动$v_j$进行。

拓扑排序:在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条;件时，称为该图的一个拓扑排序：

1. 每个顶点出现且只出现一次。
2. 若顶点A在序列中排在顶点B的前面，则在图中不存在从顶点B到顶点A的路径。

或定义为：拓扑排序是对有向无环图的顶点的一种排序，它使得若存在一条从顶点A到顶点B的路径，则在排序中顶点B出现在顶点A的后面。每个AOV网都有一个或多个拓扑排序序列。

拓扑排序的实现：

1. 从AOV网中选择一个没有前驱的入度为0的顶点并输出。
2. 从网中删除该顶点和所有以它为起点的有向边。
3. 重复步骤一和二直到当前的AOV网为空或当前网中不存在无前驱的顶点为止。

逆拓扑排序的实现：

1. 从AOV网中选择一个没有后继的出度为0的顶点并输出。
2. 从网中删除该顶点和所有以它为起点的有向边。
3. 重复步骤一和二直到当前的AOV网为空或当前网中不存在无前驱的顶点为止。

### 关键路径

在带权有向图中，以顶点表示时间，以有向边表示活动，以边上的权值表示完成该活动的开销，称之为用边表示活动的网络，简称AOE网。

+ 只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始。
+ 只有在进入某顶点的各有向边所代表的活动都已经结束时，该顶点所代表的事件才能发生，活动也可以并行进行。
+ 只有一个入度为0的顶点，即开始顶点（源点），表示整个工程的开始。
+ 只有一个出度为0的顶点，称为结束顶点（汇点），表示整个工程的结束。
+ 从源点到汇点的有向路径可能有多条，所有路径中，具有最大路径长度的路径称为关键路径（即决定完成整个工程所需的最小时间），而关键路径上的活动称为关键活动。
+ 事件的最早发生时间：决定了所有从该事件开始的活动能够开工的最早时间。
+ 活动的最早开始时间：指该活动弧的起点所表示的事件最早发生时间。
+ 事件的最迟发生时间：在不推迟整个工程完成的前提下，该事件最迟必须发生的时间。
+ 活动的最迟开始时间：指该活动弧的终点所表示的事件的最迟发生时间与该活动所需时间之差。
+ 活动的时间余量：在不增加完成整个工程所需总时间的情况下，活动可以拖延的时间。

求关键路径的步骤：

1. 求所有事件的最早发生时间ve。根据拓扑排序序列，依次按照所有路径的最大值求出各个顶点的最早发生时间。
2. 求所有事件的最迟发生时间vl。根据逆拓扑排序序列，回退依次将每个结点按第一步计算的整个工程的时间减去本结点需要处理的时间，得到每个活动都最晚应该发生的时间，交叉的结点取最小值。
3. 求所有活动的最早发生时间e。根据第二步可以得到每个活动发生的最早时间。
4. 求所有活动的最迟发生时间l。根据vl求每个结点不影响整个工程的情况下最晚可以什么时候开始。
5. 求所有活动的时间余量d。将l-e得到d，余量为0的活动就是关键活动，表示如果该活动拖延就会影响整个工程的进度。

+ 关键活动时间增加，整个工程工期延长。
+ 关键活动时间减少，整个工程工期缩短。
+ 关键活动时间减少，可能变为非关键活动。
+ 若有多条关键路径，则必须提高所有关键路径关键活动才能缩短工期。