# 串

## 基本概念

+ 串：零个或多个字符组成的有限序列。
+ 子串：串中任意个连续的字符组成的子序列。
+ 空串：长度为零的串。
+ 空白串（空格串）：仅由一个或多个空格组成的串。
+ 空串是任意串的子串，任意串是其自身的子串。

串的基本操作是对子串的操作。

## 顺序串

顺序串的结构定义方案

+ 使用单独的变量length保存串长。
+ 使用data[0]记录串长；使得字符位序与数组下标一致；但是由于char类型一个为一字节大小，所以能表示的数字是0到255，太大的串无法表示。
+ 没有表示串长的变量，使用\0表示串结尾，对应ASCII码的0号字符。
+ data[0]空余，使用单独的变量length保存串长，这个比较常用。

## 链串

如一般的链式存储结构定义一样，定义一个数据与指向下一位的指针。

但是如果你只在每个结点定义了一个字节的数据，但是又包含了四个字节的指针，那么存储利用率会很低。

如果是顺序表数据类型是整数类型，那么这种利用率低的情况确实无可奈何，但是对于串而言，因为一个字节存储一个字符，所以能一个字节存一个字符类型数据，所以为了提升数据存储利用率，可以每个结点存等多个字符。

## 模式匹配

模式匹配指在主串中找到与模式串相同的子串并返回其所在位置。

### 朴素模式匹配算法

从主串T、模式串P（子串）的第一个位置开始比较（i=0,j=0），若相等，则 i，j各自+1，然后比较下一个字符。若不等，主串指针回溯到上一轮比较位置的下一个位置，子串回溯到0，再进行下一次比较。令子串长度为m，主串长度为n：

+ 匹配成功的最好时间复杂度：$O(m)$：刚好第一个就匹配上了，总对比次数为子串长度。
+ 匹配失败的最好时间复杂度：$O(n-m+1)=O(n-m)=O(n)$：匹配成功之前，每一个与第一个字符都匹配失败。
+ 匹配失败的最坏时间复杂度：$O(nm-m^2+m)= O(nm)$：子串除了最后一个对不上，其余的都能对上，则每次遍历完一边后，又要走回头路；直到匹配成功/失败一共需要比较$m\times(n-m+1)$次。m：每次需要移动m次，i需要移动$n-m+1$次。

### KMP算法

KMP算法是对朴素模式匹配算法的优化。

朴素模式匹配算法的缺点就是当某些子串与模式串能部分匹配时，主串的扫描指针i经常回溯，从而导致时间开销。

主要思想是失配时，只有模式串指针回溯，主串指针不变，找到失配前模式串的最长公共前后缀并跳转到最大公共后缀开始匹配，且最大公共前后缀要小于左端子串长度。

+ 前缀：对于字符串A，B，A=B+S，且S非空，则B是A的前缀。
+ 后缀：对于字符串A，B，A=S+B，且S非空，则B是A的后缀。
+ PMT值：前缀集合和后缀集合的交集中，最长元素的长度。
+ 部分匹配表：PMT值集合，字符串所有前后缀的PMT值。

当一个位置失配时，那么子串前面的所有字符串都是配对的，所以对于子串前面的部分都是已知的了，需要从模式串的最开始开始对比，而一般的模式匹配要从主串的下一个重新开始匹配，但是如果我们找到了主串当前失配位置的前缀和后缀最大重合的地方，即公共前后缀，PMT值，就代表从这里开始就可以匹配了，前面的地方没必要匹配，可以直接多跳几步移动到公共后缀去开始重新匹配。

当第j个字符匹配失败，由P前1到j-1个字符组成的串记为S，则next[j]=S的最长相等前后缀长度+1（即最大PMT值+1）。特别的next[1]=0，且next[2]肯定为1。

使用KMP算法时需要先计算不同模式串P的next数组，时间复杂度为$O(m)$，然后使用KMP算法计算，时间复杂度为$O(n)$，从而平均时间复杂度为$O(m+n)$。

KMP算法对于重复部分比较多的模式串匹配效果更好。

KMP算法的next数组存在一定问题，当当前索引的值匹配失败，那么模式串的其他同样值的地方也一定会匹配失败。所以可以直接将模式串所有相同值的部分的next值全部取为其next值对应索引的next值。
