# 串

## 基本概念

+ 串：零个或多个字符组成的有限序列。
+ 子串：串中任意个连续的字符组成的子序列。
+ 空串：长度为零的串。
+ 空白串（空格串）：仅由一个或多个空格组成的串。
+ 空串是任意串的子串，任意串是其自身的子串。

串的基本操作是对子串的操作。

## 顺序串

顺序串的结构定义方案

+ 使用单独的变量length保存串长。
+ 使用data[0]记录串长；使得字符位序与数组下标一致；但是由于char类型一个为一字节大小，所以能表示的数字是0到255，太大的串无法表示。
+ 没有表示串长的变量，使用\0表示串结尾，对应ASCII码的0号字符。

## 链串

如一般的链式存储结构定义一样，定义一个数据与指向下一位的指针。

但是如果你只在每个结点定义了一个字节的数据，但是又包含了四个字节的指针，那么存储利用率会很低。

如果是顺序表数据类型是整数类型，那么这种利用率低的情况确实无可奈何，但是对于串而言，因为一个字节存储一个字符，所以能一个字节存一个字符类型数据，所以为了提升数据存储利用率，可以每个结点存等多个字符。

## 模式匹配

模式匹配指在主串中找到与模式串相同的子串并返回其所在位置。

### 朴素模式匹配算法

从主串、模式串（子串）的第一个位置开始比较（i=0,j=0），若相等，则 i，j 各自+1，然后比较下一个字符。若不等，主串指针回溯到上一轮比较位置的下一个位置，子串回溯到0，再进行下一次比较。令子串长度为m，主串长度为n：

+ 匹配成功的最好时间复杂度：$O(m)$：刚好第一个就匹配上了，总对比次数为子串长度。
+ 匹配失败的最好时间复杂度：$O(n-m+1)=O(n-m)=O(n)$：匹配成功之前，每一个与第一个字符都匹配失败。
+ 匹配失败的最坏时间复杂度：$O(nm-m^2+m)= O(nm)$：子串除了最后一个对不上，其余的都能对上，则每次遍历完一边后，又要走回头路；直到匹配成功/失败一共需要比较$m*(n-m+1)$次。m：每次需要移动m次，i需要移动$n-m+1$次。

### KMP算法

KMP算法是对朴素模式匹配算法的优化。

主要思想是失配时，只有模式串指针回溯，主串指针不变。

