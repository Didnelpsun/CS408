# 设备管理

## I/O概述

### I/O设备的基本概念

+ “$I/O$”就是“输入/输出”（$Input/Output$）。$I/O$设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件。
+ $UNIX$系统将外部设备抽象为一种特殊的文件，用户可以使用与文件操作相同的方式对外部设备进行操作。
+ 按使用特性分类：
  + 人机交互类外部设备：数据传输速度慢，如鼠标、键盘。
  + 存储设备：数据传输速度块，如移动硬盘。
  + 网络通信设备：数据传输速度介于二者之间，如调制解调器。
+ 按传输速率分类：
  + 低速设备：鼠标、键盘。
  + 中速设备：打印机。
  + 高速设备：硬盘。
+ 按信息交换的单位分类：
  + 块设备：传输速率较高，可寻址，即对它可随机地读/写任一块，如硬盘、磁盘。
  + 字符设备：传输速率较慢，不可寻址，在输入/输出时常采用中断驱动方式，键盘、鼠标。

### I/O控制器

+ $I/O$设备由机械部件和电子部件（$I/O$控制器或设备控制器）组成。
+ $I/O$设备的机械部件主要用来执行具体$I/O$操作。如鼠标/键盘的按钮，显示器的$LED$屏，移动硬盘的磁臂、磁盘盘面。
+ $I/O$设备的电子部件通常是一块插入主板扩充槽的印刷电路板。
+ $CPU$无法直接控制$I/O$设备的机械部件，因此$I/O$设备还要有一个电子部件作为$CPU$和$I/O$设备机械部件之间的“中介”，用于实现$CPU$对设备的控制。
+ $I/O$控制器的功能：
  + 接受和识别$CPU$发出的命令：如$CPU$发来的$Read/Write$命令，$I/O$控制器中会有相应的**控制寄存器**来存放命令和参数。
  + 向$CPU$报告设备的状态：$I/O$控制器中会有相应的**状态寄存器**，用于记录$I/O$设备的当前状态。如$1$表示空闲，$0$表示忙碌。
  + 数据交换：$I/O$控制器中会设置相应的**数据寄存器**。输出时，数据寄存器用于暂存$CPU$发来的数据，之后再由控制器传送设备。输入时，数据寄存器用于暂存设备发来的数据，之后$CPU$从数据寄存器中取走数据。
  + 地址识别：类似于内存的地址，为了区分设备控制器中的各个寄存器，也需要给各个寄存器设置一个特定的“地址”。$I/O$控制器通过$CPU$提供的“地址”来判断$CPU$要读/写的是哪个寄存器。
+ $I/O$控制器的组成：
  + $CPU$与控制器的接口：用于实现$CPU$与控制器之间的通信。$CPU$通过控制线发出命令，通过地址线指明要操作的设备，通过数据线来取出（输入）数据,或放入（输出）数据。
  + $I/O$逻辑：负责接收和识别$CPU$的各种命令（如地址译码），并负责对设备发出命令。
  + 控制器与设备的接口：用于实现控制器与设备之间的通信，包括数据、状态和控制。
+ 一个$I/O$控制器可能会对应多个设备。
+ 数据寄存器、控制寄存器、状态寄存器可能有多个（如每个控制/状态寄存器对应一个具体的设备），且这些寄存器都要有相应的地址，才能方便$CPU$操作。
  + 有的计算机会让这些寄存器占用内存地址的一部分，称为**内存映像$I/O$**，优点是简化了指令。可以采用对内存进行操作的指令来对控制器进行操作。
  + 另一些计算机则采用$I/O$专用地址，即**寄存器独立编址**，缺点是需要设置专门的指令来实现对控制器的操作，不仅要指明寄存器的地址，还要指明控制器的编号。

### I/O控制方式

#### 程序直接控制方式

+ 完成读写的流程：
  1. $CPU$向控制器发出读指令。于是设备启动，并且状态寄存器设为$1$（未就绪）。
  2. 轮询检查控制器的状态，其实就是在不断地执行程序的循环，若状态位一直是$1$，说明设备还没准备好要输入的数据，于是$CPU$会不断地轮询。
  3. 输入设备准备好数据后将数据传给控制器，并报告自身状态。
  4. 控制器将输入的数据放到数据寄存器中，并将状态改为$0$（已就绪）。
  5. $CPU$发现程序已就绪，即可将数据寄存器中的内容读入$CPU$的寄存器中，再把$CPU$寄存器中的内容放入内存。
  6. 若还要继续读入数据，则$CPU$继续发出读指令。
+ $CPU$干预的频率：很频繁，$I/O$操作开始之前、完成之后需要$CPU$介入，并且在等待$I/O$完成的过程中$CPU$需要不断地轮询检查。
+ 数据传送的单位：每次读/写一个字。
+ 数据的流向：
  + 读操作（数据输入）: $I/O$设备→$CPU$→内存（指的是$CPU$的寄存器）。
  + 写操作（数据输出）：内存→$CPU$→$I/O$设备。
  + 每个字的读/写都需要$CPU$的帮助。
+ 主要缺点和主要优点：
  + 优点：实现简单，在读/写指令之后，加上实现循环检查的一系列指令即可，因此才称为“程序直接控制方式”。
  + 缺点：
    + $CPU$和$I/O$设备只能串行工作。
    + $CPU$需要一直轮询检查，长期处于“忙等”状态，$CPU$利用率低。

#### 中断驱动方式

+ 引入中断机制。由于$I/O$设备速度很慢，因此在$CPU$发出读/写命令后，可将等待$I/O$的进程阻塞，先切换到别的进程执行。当$I/O$完成后，控制器会向$CPU$发出一个中断信号，$CPU$检测到中断信号后，会保存当前进程的运行环境信息，转去执行中断处理程序处理该中断。处理中断的过程中，$CPU$从$I/O$控制器读一个字的数据传送到$CPU$寄存器，再写入主存。接着，$CPU$恢复等待$I/O$的进程（或其他进程）的运行环境，然后继续执行。
  + $CPU$会在每个指令周期的末尾检查中断。
  + 中断处理过程中需要保存、恢复进程的运行环境，这个过程是需要一定时间开销的。可见，如果中断发生的频率太高，也会降低系统性能。
+ $CPU$干预的频率：每次$I/O$操作开始之前、完成之后需要$CPU$介入。等待$I/O$完成的过程中$CPU$可以切换到别的进程执行。
+ 数据传送的单位：每次读/写一个字。
+ 数据的流向：
  + 读操作（数据输入）: $I/O$设备→$CPU$→内存（指的是$CPU$的寄存器）。
  + 写操作（数据输出）:内存→$CPU$→$I/O$设备。
+ 主要缺点和主要优点：
  + 优点：
    + 与“程序直接控制方式”相比，在“中断驱动方式”中，$I/O$控制器会通过中断信号主动报告$I/O$已完成，$CPU$不再需要不停地轮询。
    + $CPU$和$I/O$设备可并行工作，$CPU$利用率得到明显提升。
  + 缺点：
    + 每个字在$I/O$设备与内存之间的传输，都需要经过$CPU$。
    + 频繁的中断处理会消耗较多的$CPU$时间。

#### DMA方式

+ 即直接存储器存取方式，主要用于块设备的$I/O$控制。
+ 改进方面：
  + 数据的传送单位是“块”。不再是一个字、一个字的传送。
  + 数据的流向是从设备直接放入内存，或者从内存直接到设备。不再需要$CPU$中转。
  + 仅在传送一个或多个数据块的开始和结束时，才需要$CPU$干预。
+ 完成读写的流程：
  1. $CPU$向$I/O$模块发出读或写块的命令。$CPU$指明此次要进行的操作，如读操作说明要读入多少数据、数据要存放在内存的什么位置、数据在外部设备上的地址。
  2. $CPU$转向其他工作，$DMA$控制器根据$CPU$所给参数完成工作。
  3. 完成工作后$DMA$控制器向$CPU$发送一个中断信号。$CPU$处理中断。
+ $DMA$控制器结构：与$I/O$控制器结构类似：
  + 主机控制器接口：
    + $DR$（$Data\,Register$，数据寄存器）：暂存从设备到内存，或从内存到设备的数据。
    + $MAR$（$Memory\,Address\,Register$，内存地址寄存器）：在输入时，$MAR$表示数据应放到内存中的什么位置，输出时$MAR$表示要输出的数据放在内存中的什么位置。
    + $DC$（$Data\,Counter$，数据计数器）：表示剩余要读/写的字节数。
    + $CR$（$Command\,Register$，命令/状态寄存器）：用于存放$CPU$发来的$I/O$命令，或设备的状态信息。
  + $I/O$控制逻辑。
  + 块设备控制器接口。
+ $CPU$干预的频率：仅在传送一个或多个数据块的开始和结束时，才需要$CPU$干预。
+ 数据传送的单位：每次读/写一个或多个块（注意每次读写的只能是连续的多个块，且这些块读入内存后在内存中也必须是连续的）。
+ 数据的流向（不再需要经过$CPU$）：
  + 读操作（数据输入）:$I/O$设备→内存。
  + 写操作（数据输出）:内存→$I/O$设备。
+ 主要缺点和主要优点：
  + 优点：
    + 数据传输以“块”为单位，$CPU$介入频率进一步降低。
    + 数据的传输不再需要先经过$CPU$再写入内存，数据传输效率进一步增加。
    + $CPU$和$I/O$设备的并行性得到提升。
  + 缺点：
    + $CPU$每发出一条$I/O$指令，只能读/写一个或多个连续的数据块。
    + 如果要读/写多个离散存储的数据块，或者要将数据分别写到不同的内存区域时，$CPU$要分别发出多条$I/O$指令，进行多次中断处理才能完成。

#### 通道控制方式

+ 通道：一种硬件，可以理解为是简版的$CPU$，因为与$CPU$相比，通道可以执行的指令很单一，并且通道程序是放在主机内存中的，也就是说通道与$CPU$共享内存。
。通道可以识别并执行一系列通道指令。
+ 完成读写的流程：
  1. $CPU$向通道发出$I/O$指令。指明通道程序在内存中的位置，并指明要操作的是哪个$I/O$设备。之后$CPU$就切换到其他进程执行。
  2. 通道执行内存中的通道程序（其中指明了要读入/写出多少数据，读/写的数据应放在内存的什么位置等信息），类似任务清单。
  3. 通道执行完规定的任务后，向$CPU$发出中断信号，之后$CPU$对中断进行处理。
+ $CPU$干预的频率：极低，通道会根据$CPU$的指示执行相应的通道程序，只有完成一组数据块的读/写后才需要发出中断信号，请求$CPU$干预。
+ 数据传送的单位：每次读/写一组数据块。
+ 数据的流向（(在通道的控制下进行）：
  + 读操作（数据输入）: $I/O$设备→内存。
  + 写操作（数据输出）:内存→$I/O$设备。
+ 主要缺点和主要优点：
  + 优点：$CPU$、通道、$I/O$设备可并行工作，资源利用率很高。
  + 缺点：实现复杂，需要专门的通道硬件支持。

### I/O软件层次结构

$I/O$软件结构层次：

1. 中断处理程序。
2. 设备驱动程序。
3. 设备独立性软件。
4. 用户层软件。

每一层会利用其下层提供的服务，实现某些功能，并屏蔽实现的具体细节，向高层提供服务（“封装思想”）。

其中中断处理程序、设备驱动程序、设备独立性软件属于操作系统的内核部分，即$I/O$系统或$I/O$核心子系统，需要使用核心态进行运行，而用户层软件用户态就可以运行。

#### 用户层软件

+ 用户层软件实现了与用户交互的接口，用户可直接使用该层提供的、与$I/O$操作相关的库函数对设备进行操作。
+ 用户层软件将用户请求翻译成格式化的$I/O$请求，并通过“系统调用”请求操作系统内核的服务。

#### 设备独立性软件

+ 设备独立性软件，又称设备无关性软件。与设备的硬件特性无关的功能几乎都在这一层实现。
+ 主要实现的功能：
  1. 向上层提供统一的调用接口（如$Read/Write$系统调用）。
  2. 设备保护。原理类似与文件保护。设备被看做是一种特殊的文件，不同用户对各个文件的访问权限是不一样的，同理，对设备的访问权限也不一样。
  3. 差错处理。
  4. 设备的分配与回收。
  5. 数据缓冲区管理。可以通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异。
  6. 建立逻辑设备名到物理设备名的映射关系，根据设备类型选择调用相应的驱动程序。（逻辑设备名）
      + 用户或用户层软件发出$I/O$操作相关系统调用的系统调用时，需要指明此次要操作的$I/O$设备的逻辑设备名（如去学校打印店打印时，需要选择扣印机$1$/打印机$2$/打印机$3$，其实这些都是逻辑设备名）。
      + 设备独立性软件需要通过“逻辑设备表”（$LUT$，$Logical\,UnitTable$）来确定逻辑设备对应的物理设备，并找到该设备对应的设备驱动程序。
      + 操作系统系统可以采用两种方式管理逻辑设备表（$LUT$）：
        1. 整个系统只设置一张$LUT$，这就意味着所有用户不能使用相同的逻辑设备名，因此这种方式只适用于单用户操作系统。
        2. 为每个用户设置一张$LUT$，各个用户使用的逻辑设备名可以重复，适用于多用户操作系统。系统会在用户登录时为其建立一个用户管理进程，而$LUT$就存放在用户管理进程的$PCB$中。

#### 设备驱动程序

+ 主要负责对硬件设备的具体控制，将上层发出的一系列命令（如$Read/Write$）转化成特定设备“能听得懂”的一系列操作。包括设置设备寄存器、检查设备状态等。
+ 不同的$I/O$设备有不同的硬件特性，具体细节只有设备的厂家才知道，因此厂家需要根据设备的硬件特性设计并提供相应的驱动程序。
+ 驱动程序一般会以一个独立进程的方式存在。

#### 中断处理程序

+ 当$I/O$任务完成时，$I/O$控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序并执行。中断处理程序的处理流程如下：
  1. 从控制器读出设备状态。
  2. 如果正常结束则从设备中读入一个字的数据并由$CPU$放入内存缓冲区中。交给上一层处理。
  3. 如果异常结束则根据异常原语进行处理。

## I/O核心子系统

### I/O核心子系统概述

实现功能：

+ 用户层软件：假脱机技术。
+ 设备独立性软件：
  + $I/O$调度：用某种算法确定一个好的顺序来处理各个$I/O$请求。
  + 设备保护：将设备看作文件，具有FCB。
  + 设备分配与回收。
  + 缓冲区管理（即缓冲与高度缓存）。

### 假脱机技术

也称为SPOOLing技术。

#### 脱机技术

+ 脱机处理是一种计算机技术，是指在不受主机控制的外部设备上进行数据处理，或与实时控制系统、主机不直接相连的数据处理。常用于主机速度不高的数据处理中提高设备的利用率。
+ 如输入输出设备速度慢，远小于$CPU$处理速率，而$CPU$要处理就必须等待输入输出设备，导致$CPU$资源浪费，而脱机技术能让数据更快进出$CPU$，从而速度加快。

#### 假脱机技术实现

+ “假脱机技术”，又称“SPOOLing技术”是用软件的方式模拟脱机技术。
+ SPOOLing系统组成：
  + 输入井：在磁盘上，模拟脱机输入时的磁带，用于收容$I/O$设备输入的数据。
  + 输出井：在磁盘上，模拟脱机输出时的磁带，用于收容用户进程输出的数据。
  + 输入进程：在内存中，模拟脱机输入时的外围控制机。
  + 输出进程，在内存中，模拟脱机输出时的外围控制机。
  + 输入缓冲区与输出缓冲区：在内存中，用于暂存输入的数据转存到输入井中，或暂存输出的数据转存到输出井中。

#### 共享打印机

打印机是一种独占式设备，而通过假脱机技术变成共享设备。

当多个用户进程提出输出打印的请求时，系统会答应它们的请求，但是并不是真正把打印机分配给他们，而是由假脱机管理进程处理：

1. 在磁盘输出井中为进程申请一个空闲缓冲区（也就是说，这个缓冲区是在磁盘上的），并将要打印的数据送入其中。
2. 为用户进程申请一张空白的打印请求表，并将用户的打印请求填入表中（其实就是用来说明用户的打印数据存放位置等信息的），再将该表挂到假脱机文件队列（打印任务队列）上。
3. 当打印机空闲时，输出进程会从文件队列的队头取出一张打印请求表，并根据表中的要求将要打印的数据从输出井传送到输出缓冲区，再输出到打印机进行打印。用这种方式可依次处理完全部的打印任务。

#### 设备分配回收

#### 设备分配考虑因素

+ 固有属性：
  + 独占设备。
  + 共享设备。
  + 虚拟设备：将独占设备改造成共享的虚拟设备。
+ 分配算法。
+ 安全性：
  + 安全分配方式：
    + 为进程分配一个设备后就将进程阻塞，本次$I/O$完成后才将进程唤醒。一个时段内每个进程只能使用一个设备。
    + 优点：破坏了“请求和保持”条件，不会死锁。
    + 缺点：对于一个进程来说，$CPU$和$I/O$设备只能串行工作。
  + 不安全分配方式：
    + 进程发出$I/O$请求后，系统为其分配$I/O$设备，进程可继续执行，之后还可以发出新的$I/O$请求。只有某个$I/O$请求得不到满足时才将进程阻塞。一个进程可以同时使用多个设备。
    + 优点：进程的计算任务和$I/O$任务可以并行处理，使进程迅速推进。
    + 缺点：有可能发生死锁（死锁避免、死锁的检测和解除）。

#### 设备分配数据结构

+ 一个通道可控制多个设备控制器，每个设备控制器可控制多个设备。
+ 设备控制表（DCT），系统为每个设备配置一张DCT，用于记录设备情况：
  + 设备类型：如打印机/扫描仪/键盘。
  + 设备标识符：即物理设备名，系统中的每个设备的物理设备名唯一。
  + 设备状态：忙碌/空闲/故障……。
  + 指向控制器表的指针：每个设备由一个控制器控制，该指针可找到相应控制器的信息。
  + 重复执行次数或时间：当重复执行多次$I/O$操作后仍不成功，才认为此次$I/O$失败。
  + 设备队列的队首指针：指向正在等待该设备的进程队列（由进程PCB组成队列）。
+ 控制器控制表（COCT），每个设备控制器都会对应一张COCT。操作系统根据COCT的信息对控制器进行操作和管理：
  + 控制器标识符：各个控制器的唯一ID。
  + 控制器状态：忙碌/空闲/故障……
  + 指向通道表的指针：每个控制器由一个通道控制，该指针可找到相应通道的信息。
  + 控制器队列的队首指针：指向正在等待该控制器的进程队列（由进程PCB组成队列）。
  + 控制器队列的队尾指针：指向控制器的队尾。
+ 通道控制表（CHCT），每个通道都会对应一张CHCT。操作系统根据CHCT的信息对通道进行操作和管理：
  + 通道标识符：各个通道的唯一ID。
  + 通道状态：忙碌/空闲/故障……
  + 与通道连接的控制器表首址：可通过该指针找到该通道管理的所有控制器相关信息（COCT）。
  + 通道队列的队首指针：指向正在等待该通道的进程队列（由进程PCB组成队列）。
  + 通道队列的队尾指针：指向通道队列的队尾。
+ 系统设备表（SDT），记录了系统中全部设备的情况，每个设备对应一个表目：
  + 设备类型：打印机/扫描仪/键盘。
  + 设备标识符：物理设备名。
  + DCT（设备控制表）。
  + 驱动程序入口：对应设备驱动的程序地址。

#### 设备分配过程

1. 根据进程请求的物理设备名查找SDT（物理设备名是进程请求分配设备时提供的参数）。
2. 根据SDT找到DCT，若设备忙碌则将进程PCB挂到设备等待队列中，不忙碌则将设备分配给进程。
3. 根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。
4. 根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程。
5. 只有设备、控制器、通道三者都分配成功时，这次设备分配才算成功，之后便可后动$I/O$设备进行数据传送。

缺点:

1. 用户编程时必须使用“物理设备名”，底层细节对用户不透明，不方便编程。
2. 若换了一个物理设备，则程序无法运行。
3. 若进程请求的物理设备正在忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待这个名字设备。

改进方法：建立逻辑设备名与物理设备名的映射机制，用户编程时只需提供逻辑设备名。

1. 根据进程请求的逻辑设备名查找SDT（用户编程时提供的逻辑设备名其实就是“设备类型”）。
2. 查找SDT，找到用户进程指定类型的、并且空闲的设备，将其分配给该进程。操作系统在逻辑设备表（LUT）中新增一个表项。
3. 根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。
4. 根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程。

优点：

+ 逻辑设备表（LUT）建立了逻辑设备名与物理设备名之间的映射关系。
+ 某用户进程第一次使用设备时使用逻辑设备名向操作系统发出请求，操作系统根据用户进程指定的设备类型（逻辑设备名）查找系统设备表，找到一个空闲设备分配给进程，并在LUT中增加相应表项。
+ 如果之后用户进程再次通过相同的逻辑设备名请求使用设备，则操作系统通过LUT表即可知道用户进程实际要使用的是哪个物理设备了，并且也能知道该设备的驱动程序入口地址。

逻辑设备表的设置问题：

+ 整个系统只有一张LUT：各用户所用的逻辑设备名不允许重复，适用于单用户操作系统。
+ 每个用户一张LUT：不同用户的逻辑设备名可重复，适用于多用户操作系统。

### 缓冲区管理

#### 缓冲区概念

+ 缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可利用内存作为缓冲区。
+ 使用硬件作为缓冲区的成本较高，容量也较小，一般仅用在对速度要求非常高的场合（如存储器管理中所用的联想寄存器，由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本）。
+ 一般情况下，更多的是利用内存作为缓冲区，“设备独立性软件”的缓冲区管理就是要组织管理好这些缓冲区。
+ 缓冲区作用：
  + 缓和$CPU$与$I/O$设备之间速度不匹配的矛盾。
  + 减少对$CPU$的中断频率，放宽对$CPU$中断相应时间的限制。
  + 解决数据粒度不匹配的问题。
  + 提高$CPU$与$I/O$设备之间的并行性。

#### 单缓冲

+ 假设某用户进程请求某种块设备读入若干块的数据。若采用单缓冲的策略，操作系统会在主存中为其分配一个缓冲区（若题目中没有特别说明，一个缓冲区的大小就是一个块）。
+ 当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出；当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出。
+ 常考题型：计算每处理一块数据平均需要多久？技巧：假定一个初始状态（如工作区满、缓冲区空），分析下次到达相同状态需要多少时间，这就是处理一块数据平均所需时间。
+ 处理一块数据平均耗时max(C,T)+M。其中C代表处理时间、M代表传输时间、T代表输入时间。

#### 双缓冲

+ 假设某用户进程请求某种块设备读入若干块的数据。若采用双缓冲的策略，操作系统会在主存中为其分配两个缓冲区（若题目中没有特别说明，一个缓冲区的大小就是一个块）。
+ 处理一块数据平均耗时max(T,(C+M))。其中C代表处理时间、M代表传输时间、T代表输入时间。
+ 若两个相互通信的机器设置双缓冲区，则同一时刻可以实现双向的数据传输。否则单缓冲区只能单向数据传输。

#### 循环缓冲

+ 将多个大小相等的缓冲区链接成一个循环队列。
+ in指针，指向下一个可以冲入数据的空缓冲区。
+ out指针，指向下一个可以取出数据的满缓冲区。

#### 缓冲池

+ 缓冲池由系统中共用的缓冲区组成。这些缓冲区按使用状况可以分为：
  + 空缓冲队列、
  + 装满输入数据的缓冲队列（输入队列）。
  + 装满输出数据的缓冲队列（输出队列）。
+ 根据一个缓冲区在实际运算中扮演的功能不同，又设置了四种工作缓冲区：
  + 用于收容输入数据的工作缓冲区（hin）。
  + 用于提取输入数据的工作缓冲区（sin）。
  + 用于收容输出数据的工作缓冲区（hout）。
  + 用于提取输出数据的工作缓冲区（sout）。
+ 输入进程请求输入数据：从空缓冲队列中取出一块作为收容输入数据的工作缓冲区（hin）。冲满数据后将缓冲区挂到输入队列队尾。
+ 计算进程想要一块输入数据：从输入队列中取得一块冲满输入数据的缓冲区作为提取输入数据的工作缓冲区（cin）。缓冲区读空后挂到空缓冲区队列。
+ 计算进程将准备好的数据冲入缓冲区：从空缓冲队列中取出一块作为收容输出数据的工作缓冲区（hout）。数据冲满后将缓冲区挂到输出队列队尾。
+ 输出进程请求输出数据：从输出队列中取得一块冲满输出数据的缓冲区作为提取输出数据的工作缓冲区（sout）。缓冲区读空后挂到空缓冲区队列。
