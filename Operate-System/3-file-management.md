# 文件管理

## 文件系统

### 文件基本概念

+ 文件：一组有意义的信息/数据的集合。
+ 文件基本属性：
  + 文件名：由创建文件的用户决定文件名，主要是为了方便用户找到文件，同一目录下不允许有重名文件。
  + 标识符：一个系统内的各文件标识符唯一，对用户来说毫无可读性,因此标识符只是操作系统用于区分各个文件的一种内部名称。
  + 类型：指明文件的类型。
  + 位置：文件存放的路径（让用户使用）、在外存中的地址（操作系统使用，对用户不可见）。
  + 大小：指明文件大小。
  + 创建时间。
  + 上次修改时间。
  + 文件所有者信息。
  + 保护信息：对文件进行保护的访问控制信息。
+ 文件逻辑结构：
  + 无结构文件（如文本文件）：由一些二进制或字符流组成，又称“流式文件”。
  + 有结构文件（如数据库表）：由一组相似的记录（每条记录又若干个数据项组成，数据项又包含多个属性，是文件系统中最基本的数据单位）组成，又称“记录式文件”。每条记录有一个数据项可作为关键字（如ID）。
+ 操作系统向上提供基本功能：
  + 创建create。
  + 删除delete。
  + 读文件read。
  + 写文件write。
  + 打开文件open。
  + 关闭文件close。
+ 操作系统以“块”为单位为文件分配存储空间，外村中的数据读入内存同样以块为单位。

### 文件逻辑结构

分为无结构文件与有结构文件。

有结构文件可以根据各条记录的长度（占用的存储空间）是否相等，可分为定长记录和可变长记录两种。

有结构文件的逻辑结构：

+ 顺序文件。
+ 索引文件。
+ 索引顺序文件。

#### 顺序文件

文件中的记录一个接一个地顺序排列（逻辑上)，记录可以是定长的或可变长的。各个记录在物理上可以顺序存储或链式存储。

根据关键字与顺序之间的关系：

+ 串结构：记录之间的顺序与关键字无关。一般按记录存入时间决定记录的顺序。
+ 顺序结构：记录之间的顺序按关键字顺序排列。

如何访存顺序文件：

+ 链式存储：无论是定长/可变长记录，都无法实现随机存取，每次只能从第一记录开始依次往后查找。
+ 顺序存储：
  + 可变长记录：无法实现随机存取。每次只能从第一个记录开始依次往后查找。因为需要显式地给出记录长度。
  + 定长记录：
    + 可实现随机存取。记录长度为L，则第i个记录存放的相对位置是i*L。
    + 若采用串结构，只能从头开始查找，无法快速找到某关键字对应的记录。
    + 若采用顺序结构，可以快速找到某关键字对应的记录（如折半查找）。

顺序文件插入删除文件比较麻烦。一般实际实现时会隔一个时间段集中将修改写入到文件中。

#### 索引文件

+ 为了解决顺序文件查找问题，建立一张索引表以加快文件检索速度。每条记录对应一个索引项。
+ 记录可以离散存放，而索引表必须连续存放。
+ 索引表包含索引号，长度，指针三个部分。其本身是定长长度的顺序文件，所以可以快速找到索引，通过指针随机访问。
+ 可将关键字作为索引号内容，若按关键字顺序排列，则还可以支持按照关键字折半查找。
+ 每当要增加/删除一个记录时，需要对索引表进行修改。由于索引文件有很快的检索速度，因此主要用于对信息处理的及时性要求比较高的场合。
+ 可以使用不同的数据项对一组数据建立多个索引表。
+ 索引表其实是索引顺序结构的。

#### 索引顺序文件

+ 因为每个记录对应一个索引表项，因此索引表可能会很大。同时若数据长度本身远小于索引表项长度，则空间利用率会很低。
+ 索引顺序文件是索引文件和顺序文件思想的结合。索引顺序文件中，同样会为文件建立一张索引表，但不同的是并不是每个记录对应一个索引表项，而是一组记录对应一个索引表项。
+ 每个分组就是一个顺序文件，分组内的记录不需要按关键字排序。
+ 索引项页不需要按关键字顺序排列，从而能便利插入删除。
+ 索引表其实是索引串结构的。
+ 为了进一步提高索引效率，可以建立多级索引表。

### 文件目录

#### 文件控制块

+ 目录本身就是一种有结构文件，由一条条记录组成。每条记录对应一个在该放在该目录下的文件。
+ 目录文件中的一条记录就是一个**文件控制块**（PCB）。FCB的有序集合就是文件目录，一个FCB就是一个文件目录项。
+ FCB中包含了文件的基本信息（文件名、物理地址、逻辑结构、物理结构等），存取控制信息（是否可读/可写、禁止访问的用户名单等），使用信息（如文件的建立时间、修改时间等）。最重要最基本的就是文件名和文件存放物理地址。
+ FCB实现了文件名与文件之间的映射，使得用户（用户程序）可以实现按名存取。

#### 索引结点

+ 其实在查找各级目录的过程中只需要用到“文件名”这个信息，只有文件名匹配时，才需要读出文件的其他信息。因此可以考虑让目录表“瘦身”来提升效率。
+ 所以目录只包含文件名与索引结点指针，除了文件名之外的文件描述信息都存放在索引结点之中。索引结点是对FCB的改进。
+ 当找到文件名对应的目录项时，才需要将索引结点调入内存，索引结点中记录了文件的各种信息，包括文件在外存中的存放位置，根据“存放位置”即可找到文件。
+ 存放在外存中的索引结点称为“磁盘索引结点”，当索引结点放入内存后称为“内存索引结点”。相比之下内存索引结点中需要增加一些信息，比如:文件是否被修改、此时有几个进程正在访问该文件等。
+ 假设一个FCB是64B，磁盘块的大小为1KB，则每个盘块中只能存放16个FCB。若一个文件目录中共有640个目录项，则共需要占用640/16=40个盘块。因此按照某文件名检索该目录，使用折半查找平均需要查询320个目录项，平均需要启动磁盘20次（每次磁盘I/O读入一块)。
+ 若使用索引结点机制，文件名占14B，索引结点指针站2B，则每个盘块可存放64个目录项，那么按文件名检索目录平均只需要读入320/64=5个磁盘块。显然，这将大大提升文件检索速度。

#### 目录结构

+ 单级目录结构：整个系统中只建立一张目录表，每个文件占一个目录项。
  + 实现了“按名存取”，但是不允许文件重名。
  + 在创建一个文件时，需要先检查目录表中有没有重名文件，确定不重名后才能允许建立文件，并将新文件对应的目录项插入目录表中。
  + 不适用于多用户操作系统。
+ 两级目录结构：分为主文件目录（MFD，Master File Directory）和用户文件目录（UFD，User Flie Directory) 。
  + 主文件目录记录用户名及相应用户文件目录的存放位置。
  + 用户文件目录由该用户的文件FCB组成。
  + 允许不同用户的文件重名。文件名虽然相司，但是对应的其实是不同的文件。
  + 两级目录结构允许不同用户的文件重名，也可以在目录上实现实现访问限制（检查此时登录的用户名是否匹配）。
  + 两级目录结构依然缺乏灵活性,用户不能对自己的文件进行分类。
+ 多级目录结构（树形目录结构）：
  + 不同目录下的文件可以重名。
  + 用户（或用户进程）要访问某个文件时要用文件路径名标识文件，文件路径名是个字符串。各级目录之间用“/”隔开。从根目录出发的路径称为绝对路径。
  + 从根目录出发的路径称为绝对路径。
  + 很多时候，用户会连续访问同一目录内的多个文件，显然，每次都从根目录开始查找，是很低效的。因此可以设置一个“当前目录”出发的相对路径。
  + 树形目录结构可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。但是，树形结构不便于实现文件的按享。为此，提出了“无环图目录结构”。
+ 无环图目录结构：
  + 在树形目录结构的基础上，增加一些指向同一节点的有向边，使整个目录成为一个有向无环图。可以更方便地实现多个用户间的文件共享。
  + 可以用不同的文件名指向同一个文件，甚至可以指向同一个目录（共享同一目录下的所有内容）。
  + 需要为每个共享结点设置一个共享计数器，用于记录此时有多少个地方在共享该结点。用户提出删除结点的请求时，只是删除该用户的FCB、并使共享计数器减1，并不会直接删除共享结点。
  + 共享文件不同于复制文件。在共享文件中，由于各用户指向的是同一个文件，因此只要其中一个用户修改了文件数据，那么所有用户都可以看到文件数据的变化。

### 文件物理结构

文件物理结构即文件分配方式，是对非空间磁盘块的管理。

#### 文件块与磁盘块

+ 类似于内存分页，磁盘中的存储单元也会被分为一个个“块/磁盘块/物理块”。很多操作系统中，磁盘块的大小与内存块、页面的大小相同。
+ 内存与磁盘之间的数据交换（即读/写操作、磁盘I/O)）都是以“块”为单位进行的。即每次读入一块，或每次写出一块。
+ 在内存管理中，进程的逻辑地址空间被分为一个一个页面。同样的，在外存管理中，为了方便对文件数据的管理，文件的逻辑地址空间也被分为了一个一个的文件“块”。于是文件的逻辑地址也可以表示为（逻辑块号，块内地址）的形式。
+ 用户通过逻辑地址来操作自己的文件，
操作系统要负责实现从逻辑地址到物理地址的映射，即文件的物理结构或文件分配方式。

#### 连续分配

+ 每个文件在磁盘上占有一组连续的块。
+ （逻辑块号，块内地址）→（物理块号，块内地址）。只需转换块号就行，块内地址保持不变。
+ 文件目录中记录存放的起始块号和长度（总共占用几个块）。
+ 用户给出要访问的逻辑块号，操作系统找到该文件对应的目录项（FCB），物理块号=起始块号＋逻辑块号。
+ 优点：
  + 可以直接算出逻辑块号对应的物理块号，因此连续分配支持顺序访问和直接访问（即随机访问）。
  + 连续分配的文件在顺序读写时速度最快。
+ 缺点：
  + 不便于拓展。
  + 存储利用率低，产生大量外部碎片。

#### 链接分配

+ 采取离散分配的方式，可以为文件分配离散的磁盘块。分为隐式链接和显式链接两种。
+ 隐式链接：
  + 类似链表。
  + FCB目录中记录了文件存放的起始块号和结束块号，当然也可以增加一个字段来表示文件的长度。
  + 除了文件的最后个磁盘块之外，每个磁盘块中都会保存指向下一个盘块的指针，这些指针对用户是透明的。
  + 优点：
    + 方便文件拓展。
    + 不会有硬盘碎片。
  + 缺点：
    + 只支持顺序访问，不支持随机访问，查找效率低。
    + 指向下一个盘块的指针也需要耗费少量的存储空间。
+ 显式链接：
  + 类似静态链表。
  + 把用于链接文件各物理块的指针显式地存放在一张表中。即文件分配表（FAT，File Allocation Table）。FAT包含物理块号和下一块指针两项。
  + FCB目录中只需记录文件的起始块号。
  + 一个磁盘仅设置一张FAT。开机时，将FAT读入内存，并常驻内存。所以地址转换不需要读取内存，从而效率更高。
  + FAT的各个表项在物理上连续存储，且每一个表项长度相同，因此“物理块号”字段可以是隐含的。
  + 地址转换：目录项中找到起始块号，若i>0，则查询内存中的文件分配表FAT，往后找到i号逻辑块对应的物理块号。逻辑块号转换成物理块号的过程不需要读磁盘操作。
  + 优点：
    + 很方便文件拓展，不会有碎片问题，外存利用率高。
    + 支持随机访问。
    + 相比于隐式链接来说，地址转换时不需要访问磁盘，因此文件的访问效率更高。
  + 缺点：文件分配表的需要占用一定的存储空间。

#### 索引分配

+ 允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表中记录了文件的各个逻辑块对应的物理块（索引表的功能类似于内存管理中的页表——建立逻辑页面到物理页之间的映射关系）。索引表存放的磁盘块称为索引块。文件数据存放的磁盘块称为数据块。
+ 索引表包含逻辑块号和物理块号两项。逻辑块号可以是隐含的。
+ 每一个文件都有一个索引表。
+ 地址转换：从目录项中可知索引表存放位置，将索引表从外存读入内存，并查找索引表即可只i号逻辑块在外存中的存放位置。
+ 优点：
  + 很方便文件拓展，不会有碎片问题，外存利用率高。
  + 支持随机访问。
+ 缺点：文件索引表的需要占用一定的存储空间。
+ 文件大小过大的解决方案：
  + 链接方案：
    + 分配多个索引块并链接起来。
    + 文件FCB中只需要记录第一个索引块的块号。
    + 缺点：查找效率低。
  + 多层索引：
    + 建立类似多级页表的多层索引，使上层索引块指向下一层的索引块。
    + FCB中只需要记录顶层索引块就可以了。
    + 若采用多层索引，则各层索引表大小不能超过一个磁盘块。理由同多级页表。
    + 采用K层索引结构，且顶级索引表未调入内存，则访问一个数据块只需要K+1次读磁盘操作。
    + 缺点：即使是小文件页需要K+1次读磁盘操作。
  + 混合索引：
    + 多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含直接地址索引（直接指向数据块），又包含一级间接索引（指向单层索引表)、还包含两级间接索引（指向两层索引表）。
    + 优点：对于小文件，只需较少的读磁盘次数就可以访问目标数据块。（一般计算机中小文件更多）。

**例题** 假设磁盘块大小为1KB，一个索引表项占4B，求文件最大长度。

若磁盘块大小为1KB，一个索引表项占4B，则一个磁盘块只能存放1*1024/4=256个索引项。

若某文件采用两层索引，则该文件的最大长度，就是所有索引都用来指向一个文件的数据，所以可以到256\*256*1KB= 65536KB= 64MB。

### 文件存储空间管理

即对空闲空间的管理。

#### 存储空间划分与初始化

+ 将物理磁盘划分为一个个文件卷（逻辑卷、逻辑盘）。
+ 将各个文件卷初始化为：
  + 目录区：主要存放文件目录信息FCB、用于磁盘存储空间管理的信息。
  + 文件区：用于存放普通文件数据。
+ 有的系统支持超大型文件，支持由多格物理磁盘组成一个文件卷。

#### 空闲表法

+ 拥有一个空闲盘块表，包括空闲区间的起始位置（第一个空闲盘块号）和空闲空间长度（空闲盘块数）。
+ 适用于连续分配方式。
+ 如何分配磁盘块：与内存管理中的动态分区分配很类似，为一个文件分配连续的存储空间。同样可采用首次适应、最佳适应、最坏适应等算法来决定要为文件分配哪个区间。
+ 如何回收磁盘块：与内存管理中的动态分区分配很类似，当回收某个存储区时需要有四种情况：
  1. 回收区的前后都没有相邻空闲区。
  2. 回收区的前后都是空闲区。
  3. 回收区前面是空闲区.
  4. 回收区后面是空闲区。
  5. 总之，回收时需要注意表项的合并问题。

#### 空闲链表法

+ 空闲盘块法：
  + 以盘块为单位组成一条空闲链。空闲盘块中存储着下一个空闲盘块的指针。
  + 操作系统保存着链头、链尾指针。
  + 如何分配：若某文件申请K个盘块，则从链头开始依次摘下K个盘块分配，并修改空闲链的链头指针。
  + 如何回收：回收的盘块依次挂到链尾，并修改空闲链的链尾指针。
  + 适用于离散分配的物理结构。为文件分配多个盘块时可能要重复多次操作。
+ 空闲盘区法：
  + 以盘区为单位组成一条空闲链。由连续的几个盘块组成一个盘区。每一个盘区内的第一个盘块内记录了盘区的长度和下一个盘区的指针。
  + 操作系统保存着链头、链尾指针。
  + 如何分配:若某文件申请K个盘块，则可以采用首次适应、最佳适应等算法，从链头开始检索，按照算法规则找到一个大小符合要求的空闲盘区,分配给文件。若没有合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件，注意分配后可能要修改相应的链指针、盘区大小等数据。
  + 如何回收:若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中。若回收区没有和任何空闲区相邻，将回收区作为单独的一个空闲盘区挂到链尾。
  + 离散分配、连续分配都适用。为一个文件分配多个盘块时效率更高。

#### 位示图法

+ 每个二进制位对应一个盘块。如“0”代表盘块空闲，“1”代表盘块已分配。
+ 位示图一般用连续的“字”来表示，如一个字的字长是16位，则一共有16列，字中的每一位对应一个盘块。因此可以用（字号，位号）对应一个盘块号。当然有的题目中也描述为（行号，列号）。
+ 若盘块号、字号、位号从0开始，若n表示字长，则(字号,位号)=(i,j)的二进制位对应的盘块号b=ni+j。
+ b号盘块对应的字号i= b/n，位号j= b%n。
+ 如何分配：若文件需要K个块，
  1. 顺序扫描位示图，找到K个相邻或不相邻的“0”。
  2. 根据字号、位号算出对应的盘块号，将相应盘块分配给文件。
  3. 将相应位设置为“1”。
+ 如何回收：
  1. 根据回收的盘块号计算出对应的字号、位号。
  2. 将相应二进制位设为“0”。
+ 离散分配、连续分配都适用。

#### 成组链接法

+ 空闲表法、空闲链表法不适用于大型文件系统，因为空闲表或空闲链表可能过大。UNX系统中采用了成组链接法对磁盘空闲块进行管理。
+ 文件卷的目录区中专门用一个磁盘块作为“超级块”，当系统启动时需要将超级块读入内存。并且要保证内存与外存中的“超级块”数据一致。
+ 将空闲块分成若干组，每100个空闲块为一组，每组的第一空闲块登记了下一组空闲块的物理盘块号和空闲块总数。组内索引，组间链接。
+ 一个分组的块号不需要连续。
+ 如何分配：
  1. 检测第一个分组的块数是否足够。
  2. 若足够则分配空闲块并修改对应数据。
  3. 若刚好相等或不足，则分配时要先将其数据复制到超级块中，超级块充当链头的作用。
+ 如何回收：
  1. 如果块内回收后余留，则修改数据。
  2. 若回收数量大于等于余下，需要将超级块中的数据复制到新回收的块中，并修改超级块的内容，让新回收的块成为第一个分组。



### 文件基本操作

### 文件共享

### 文件保护

### 文件系统层次结构

## 磁盘管理
