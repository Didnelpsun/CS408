# 文件管理

## 文件系统

### 文件基本概念

+ 文件：一组有意义的信息/数据的集合。
+ 文件基本属性：
  + 文件名：由创建文件的用户决定文件名，主要是为了方便用户找到文件，同一目录下不允许有重名文件。
  + 标识符：一个系统内的各文件标识符唯一，对用户来说毫无可读性,因此标识符只是操作系统用于区分各个文件的一种内部名称。
  + 类型：指明文件的类型。
  + 位置：文件存放的路径（让用户使用）、在外存中的地址（操作系统使用，对用户不可见）。
  + 大小：指明文件大小。
  + 创建时间。
  + 上次修改时间。
  + 文件所有者信息。
  + 保护信息：对文件进行保护的访问控制信息。
+ 文件逻辑结构：
  + 无结构文件（如文本文件）：由一些二进制或字符流组成，又称“流式文件”。
  + 有结构文件（如数据库表）：由一组相似的记录（每条记录又若干个数据项组成，数据项又包含多个属性，是文件系统中最基本的数据单位）组成，又称“记录式文件”。每条记录有一个数据项可作为关键字（如ID）。
+ 操作系统向上提供基本功能：
  + 创建create。
  + 删除delete。
  + 读文件read。
  + 写文件write。
  + 打开文件open。
  + 关闭文件close。
+ 操作系统以“块”为单位为文件分配存储空间，外村中的数据读入内存同样以块为单位。

### 文件逻辑结构

分为无结构文件与有结构文件。

有结构文件可以根据各条记录的长度（占用的存储空间）是否相等，可分为定长记录和可变长记录两种。

有结构文件的逻辑结构：

+ 顺序文件。
+ 索引文件。
+ 索引顺序文件。

#### 顺序文件

文件中的记录一个接一个地顺序排列（逻辑上），记录可以是定长的或可变长的。各个记录在物理上可以顺序存储或链式存储。

根据关键字与顺序之间的关系：

+ 串结构：记录之间的顺序与关键字无关。一般按记录存入时间决定记录的顺序。
+ 顺序结构：记录之间的顺序按关键字顺序排列。

如何访存顺序文件：

+ 链式存储：无论是定长/可变长记录，都无法实现随机存取，每次只能从第一记录开始依次往后查找。
+ 顺序存储：
  + 可变长记录：无法实现随机存取。每次只能从第一个记录开始依次往后查找。因为需要显式地给出记录长度。
  + 定长记录：
    + 可实现随机存取。记录长度为L，则第i个记录存放的相对位置是i*L。
    + 若采用串结构，只能从头开始查找，无法快速找到某关键字对应的记录。
    + 若采用顺序结构，可以快速找到某关键字对应的记录（如折半查找）。

顺序文件插入删除文件比较麻烦。一般实际实现时会隔一个时间段集中将修改写入到文件中。

#### 索引文件

+ 为了解决顺序文件查找问题，建立一张索引表以加快文件检索速度。每条记录对应一个索引项。
+ 记录可以离散存放，而索引表必须连续存放。
+ 索引表包含索引号，长度，指针三个部分。其本身是定长长度的顺序文件，所以可以快速找到索引，通过指针随机访问。
+ 可将关键字作为索引号内容，若按关键字顺序排列，则还可以支持按照关键字折半查找。
+ 每当要增加/删除一个记录时，需要对索引表进行修改。由于索引文件有很快的检索速度，因此主要用于对信息处理的及时性要求比较高的场合。
+ 可以使用不同的数据项对一组数据建立多个索引表。
+ 索引表其实是索引顺序结构的。

#### 索引顺序文件

+ 因为每个记录对应一个索引表项，因此索引表可能会很大。同时若数据长度本身远小于索引表项长度，则空间利用率会很低。
+ 索引顺序文件是索引文件和顺序文件思想的结合。索引顺序文件中，同样会为文件建立一张索引表，但不同的是并不是每个记录对应一个索引表项，而是一组记录对应一个索引表项。
+ 每个分组就是一个顺序文件，分组内的记录不需要按关键字排序。
+ 索引项页不需要按关键字顺序排列，从而能便利插入删除。
+ 索引表其实是索引串结构的。
+ 为了进一步提高索引效率，可以建立多级索引表。

### 文件目录

#### 文件控制块

+ 目录本身就是一种有结构文件，由一条条记录组成。每条记录对应一个在该放在该目录下的文件。
+ 目录文件中的一条记录就是一个**文件控制块**（PCB）。FCB的有序集合就是文件目录，一个FCB就是一个文件目录项。
+ FCB中包含了文件的基本信息（文件名、物理地址、逻辑结构、物理结构等），存取控制信息（是否可读/可写、禁止访问的用户名单等），使用信息（如文件的建立时间、修改时间等）。最重要最基本的就是文件名和文件存放物理地址。
+ FCB实现了文件名与文件之间的映射，使得用户（用户程序）可以实现按名存取。

#### 索引结点

+ 其实在查找各级目录的过程中只需要用到“文件名”这个信息，只有文件名匹配时，才需要读出文件的其他信息。因此可以考虑让目录表“瘦身”来提升效率。
+ 所以目录只包含文件名与索引结点指针，除了文件名之外的文件描述信息都存放在索引结点之中。索引结点是对FCB的改进。
+ 当找到文件名对应的目录项时，才需要将索引结点调入内存，索引结点中记录了文件的各种信息，包括文件在外存中的存放位置，根据“存放位置”即可找到文件。
+ 存放在外存中的索引结点称为“磁盘索引结点”，当索引结点放入内存后称为“内存索引结点”。相比之下内存索引结点中需要增加一些信息，比如:文件是否被修改、此时有几个进程正在访问该文件等。
+ 假设一个FCB是64B，磁盘块的大小为1KB，则每个盘块中只能存放16个FCB。若一个文件目录中共有640个目录项，则共需要占用640/16=40个盘块。因此按照某文件名检索该目录，使用折半查找平均需要查询320个目录项，平均需要启动磁盘20次（每次磁盘I/O读入一块)。
+ 若使用索引结点机制，文件名占14B，索引结点指针站2B，则每个盘块可存放64个目录项，那么按文件名检索目录平均只需要读入320/64=5个磁盘块。显然，这将大大提升文件检索速度。

#### 目录结构

+ 单级目录结构：整个系统中只建立一张目录表，每个文件占一个目录项。
  + 实现了“按名存取”，但是不允许文件重名。
  + 在创建一个文件时，需要先检查目录表中有没有重名文件，确定不重名后才能允许建立文件，并将新文件对应的目录项插入目录表中。
  + 不适用于多用户操作系统。
+ 两级目录结构：分为主文件目录（MFD，Master File Directory）和用户文件目录（UFD，User Flie Directory) 。
  + 主文件目录记录用户名及相应用户文件目录的存放位置。
  + 用户文件目录由该用户的文件FCB组成。
  + 允许不同用户的文件重名。文件名虽然相司，但是对应的其实是不同的文件。
  + 两级目录结构允许不同用户的文件重名，也可以在目录上实现实现访问限制（检查此时登录的用户名是否匹配）。
  + 两级目录结构依然缺乏灵活性,用户不能对自己的文件进行分类。
+ 多级目录结构（树形目录结构）：
  + 不同目录下的文件可以重名。
  + 用户（或用户进程）要访问某个文件时要用文件路径名标识文件，文件路径名是个字符串。各级目录之间用“/”隔开。从根目录出发的路径称为绝对路径。
  + 从根目录出发的路径称为绝对路径。
  + 很多时候，用户会连续访问同一目录内的多个文件，显然，每次都从根目录开始查找，是很低效的。因此可以设置一个“当前目录”出发的相对路径。
  + 树形目录结构可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。但是，树形结构不便于实现文件的按享。为此，提出了“无环图目录结构”。
+ 无环图目录结构：
  + 在树形目录结构的基础上，增加一些指向同一节点的有向边，使整个目录成为一个有向无环图。可以更方便地实现多个用户间的文件共享。
  + 可以用不同的文件名指向同一个文件，甚至可以指向同一个目录（共享同一目录下的所有内容）。
  + 需要为每个共享结点设置一个共享计数器，用于记录此时有多少个地方在共享该结点。用户提出删除结点的请求时，只是删除该用户的FCB、并使共享计数器减1，并不会直接删除共享结点。
  + 共享文件不同于复制文件。在共享文件中，由于各用户指向的是同一个文件，因此只要其中一个用户修改了文件数据，那么所有用户都可以看到文件数据的变化。

### 文件物理结构

文件物理结构即文件分配方式，是对非空间磁盘块的管理。

#### 文件块与磁盘块

+ 类似于内存分页，磁盘中的存储单元也会被分为一个个“块/磁盘块/物理块”。很多操作系统中，磁盘块的大小与内存块、页面的大小相同。
+ 内存与磁盘之间的数据交换（即读/写操作、磁盘I/O)）都是以“块”为单位进行的。即每次读入一块，或每次写出一块。
+ 在内存管理中，进程的逻辑地址空间被分为一个一个页面。同样的，在外存管理中，为了方便对文件数据的管理，文件的逻辑地址空间也被分为了一个一个的文件“块”。于是文件的逻辑地址也可以表示为（逻辑块号，块内地址）的形式。
+ 用户通过逻辑地址来操作自己的文件，
操作系统要负责实现从逻辑地址到物理地址的映射，即文件的物理结构或文件分配方式。

#### 连续分配

+ 每个文件在磁盘上占有一组连续的块。
+ （逻辑块号，块内地址）→（物理块号，块内地址）。只需转换块号就行，块内地址保持不变。
+ 文件目录中记录存放的起始块号和长度（总共占用几个块）。
+ 用户给出要访问的逻辑块号，操作系统找到该文件对应的目录项（FCB），物理块号=起始块号＋逻辑块号。
+ 优点：
  + 可以直接算出逻辑块号对应的物理块号，因此连续分配支持顺序访问和直接访问（即随机访问）。
  + 连续分配的文件在顺序读写时速度最快。
+ 缺点：
  + 不便于拓展。
  + 存储利用率低，产生大量外部碎片。

#### 链接分配

+ 采取离散分配的方式，可以为文件分配离散的磁盘块。分为隐式链接和显式链接两种。
+ 隐式链接：
  + 类似链表。
  + FCB目录中记录了文件存放的起始块号和结束块号，当然也可以增加一个字段来表示文件的长度。
  + 除了文件的最后个磁盘块之外，每个磁盘块中都会保存指向下一个盘块的指针，这些指针对用户是透明的。
  + 优点：
    + 方便文件拓展。
    + 不会有硬盘碎片。
  + 缺点：
    + 只支持顺序访问，不支持随机访问，查找效率低。
    + 指向下一个盘块的指针也需要耗费少量的存储空间。
+ 显式链接：
  + 类似静态链表。
  + 把用于链接文件各物理块的指针显式地存放在一张表中。即文件分配表（FAT，File Allocation Table）。FAT包含物理块号和下一块指针两项。
  + FCB目录中只需记录文件的起始块号。
  + 一个磁盘仅设置一张FAT。开机时，将FAT读入内存，并常驻内存。所以地址转换不需要读取内存，从而效率更高。
  + FAT的各个表项在物理上连续存储，且每一个表项长度相同，因此“物理块号”字段可以是隐含的。
  + 地址转换：目录项中找到起始块号，若i>0，则查询内存中的文件分配表FAT，往后找到i号逻辑块对应的物理块号。逻辑块号转换成物理块号的过程不需要读磁盘操作。
  + 优点：
    + 很方便文件拓展，不会有碎片问题，外存利用率高。
    + 支持随机访问。
    + 相比于隐式链接来说，地址转换时不需要访问磁盘，因此文件的访问效率更高。
  + 缺点：文件分配表的需要占用一定的存储空间。

#### 索引分配

+ 允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表中记录了文件的各个逻辑块对应的物理块（索引表的功能类似于内存管理中的页表——建立逻辑页面到物理页之间的映射关系）。索引表存放的磁盘块称为索引块。文件数据存放的磁盘块称为数据块。
+ 索引表包含逻辑块号和物理块号两项。逻辑块号可以是隐含的。
+ 每一个文件都有一个索引表。
+ 地址转换：从目录项中可知索引表存放位置，将索引表从外存读入内存，并查找索引表即可只i号逻辑块在外存中的存放位置。
+ 优点：
  + 很方便文件拓展，不会有碎片问题，外存利用率高。
  + 支持随机访问。
+ 缺点：文件索引表的需要占用一定的存储空间。
+ 文件大小过大的解决方案：
  + 链接方案：
    + 分配多个索引块并链接起来。
    + 文件FCB中只需要记录第一个索引块的块号。
    + 缺点：查找效率低。
  + 多层索引：
    + 建立类似多级页表的多层索引，使上层索引块指向下一层的索引块。
    + FCB中只需要记录顶层索引块就可以了。
    + 若采用多层索引，则各层索引表大小不能超过一个磁盘块。理由同多级页表。
    + 采用K层索引结构，且顶级索引表未调入内存，则访问一个数据块只需要K+1次读磁盘操作。
    + 缺点：即使是小文件页需要K+1次读磁盘操作。
  + 混合索引：
    + 多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含直接地址索引（直接指向数据块），又包含一级间接索引（指向单层索引表)、还包含两级间接索引（指向两层索引表）。
    + 优点：对于小文件，只需较少的读磁盘次数就可以访问目标数据块。（一般计算机中小文件更多）。

**例题** 假设磁盘块大小为1KB，一个索引表项占4B，求文件最大长度。

若磁盘块大小为1KB，一个索引表项占4B，则一个磁盘块只能存放1*1024/4=256个索引项。

若某文件采用两层索引，则该文件的最大长度，就是所有索引都用来指向一个文件的数据，所以可以到256\*256*1KB= 65536KB= 64MB。

### 文件存储空间管理

即对空闲空间的管理。

#### 存储空间划分与初始化

+ 将物理磁盘划分为一个个文件卷（逻辑卷、逻辑盘）。
+ 将各个文件卷初始化为：
  + 目录区：主要存放文件目录信息FCB、用于磁盘存储空间管理的信息。
  + 文件区：用于存放普通文件数据。
+ 有的系统支持超大型文件，支持由多格物理磁盘组成一个文件卷。

#### 空闲表法

+ 拥有一个空闲盘块表，包括空闲区间的起始位置（第一个空闲盘块号）和空闲空间长度（空闲盘块数）。
+ 适用于连续分配方式。
+ 如何分配磁盘块：与内存管理中的动态分区分配很类似，为一个文件分配连续的存储空间。同样可采用首次适应、最佳适应、最坏适应等算法来决定要为文件分配哪个区间。
+ 如何回收磁盘块：与内存管理中的动态分区分配很类似，当回收某个存储区时需要有四种情况：
  1. 回收区的前后都没有相邻空闲区。
  2. 回收区的前后都是空闲区。
  3. 回收区前面是空闲区.
  4. 回收区后面是空闲区。
  5. 总之，回收时需要注意表项的合并问题。

#### 空闲链表法

+ 空闲盘块法：
  + 以盘块为单位组成一条空闲链。空闲盘块中存储着下一个空闲盘块的指针。
  + 操作系统保存着链头、链尾指针。
  + 如何分配：若某文件申请K个盘块，则从链头开始依次摘下K个盘块分配，并修改空闲链的链头指针。
  + 如何回收：回收的盘块依次挂到链尾，并修改空闲链的链尾指针。
  + 适用于离散分配的物理结构。为文件分配多个盘块时可能要重复多次操作。
+ 空闲盘区法：
  + 以盘区为单位组成一条空闲链。由连续的几个盘块组成一个盘区。每一个盘区内的第一个盘块内记录了盘区的长度和下一个盘区的指针。
  + 操作系统保存着链头、链尾指针。
  + 如何分配:若某文件申请K个盘块，则可以采用首次适应、最佳适应等算法，从链头开始检索，按照算法规则找到一个大小符合要求的空闲盘区,分配给文件。若没有合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件，注意分配后可能要修改相应的链指针、盘区大小等数据。
  + 如何回收:若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中。若回收区没有和任何空闲区相邻，将回收区作为单独的一个空闲盘区挂到链尾。
  + 离散分配、连续分配都适用。为一个文件分配多个盘块时效率更高。

#### 位示图法

+ 每个二进制位对应一个盘块。如“0”代表盘块空闲，“1”代表盘块已分配。
+ 位示图一般用连续的“字”来表示，如一个字的字长是16位，则一共有16列，字中的每一位对应一个盘块。因此可以用（字号，位号）对应一个盘块号。当然有的题目中也描述为（行号，列号）。
+ 若盘块号、字号、位号从0开始，若n表示字长，则(字号,位号)=(i,j)的二进制位对应的盘块号b=ni+j。
+ b号盘块对应的字号i= b/n，位号j= b%n。
+ 如何分配：若文件需要K个块，
  1. 顺序扫描位示图，找到K个相邻或不相邻的“0”。
  2. 根据字号、位号算出对应的盘块号，将相应盘块分配给文件。
  3. 将相应位设置为“1”。
+ 如何回收：
  1. 根据回收的盘块号计算出对应的字号、位号。
  2. 将相应二进制位设为“0”。
+ 离散分配、连续分配都适用。

#### 成组链接法

+ 空闲表法、空闲链表法不适用于大型文件系统，因为空闲表或空闲链表可能过大。UNX系统中采用了成组链接法对磁盘空闲块进行管理。
+ 文件卷的目录区中专门用一个磁盘块作为“超级块”，当系统启动时需要将超级块读入内存。并且要保证内存与外存中的“超级块”数据一致。
+ 将空闲块分成若干组，每100个空闲块为一组，每组的第一空闲块登记了下一组空闲块的物理盘块号和空闲块总数。组内索引，组间链接。
+ 一个分组的块号不需要连续。
+ 如何分配：
  1. 检测第一个分组的块数是否足够。
  2. 若足够则分配空闲块并修改对应数据。
  3. 若刚好相等或不足，则分配时要先将其数据复制到超级块中，超级块充当链头的作用。
+ 如何回收：
  1. 如果块内回收后余留，则修改数据。
  2. 若回收数量大于等于余下，需要将超级块中的数据复制到新回收的块中，并修改超级块的内容，让新回收的块成为第一个分组。

### 文件基本操作

#### 创建文件

+ 进行Create系统调用时，需要提供的几个主要参数：
  1. 所需的外存空间大小。
  2. 文件存放路径。
  3. 文件名。
+ 操作系统在处理Create系统调用时，主要做了两件事：
  1. 在外存中找到文件所需的空间（空闲链表法、位示图、成组链接法等管理策略，找到空闲空间）。
  2. 根据文件存放路径的信息找到该目录对应的目录文件，在目录中创建该文件对应的目录项。目录项中包含了文件名、文件在外存中的存放位置等信息。

#### 删除文件

+ 进行Delete系统调用时，需要提供的几个主要参数：
  1. 文件存放路径。
  2. 文件名。
+ 操作系统在处理Delete系统调用时，主要做了几件事:
  1. 根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的目录项。
  2. 根据该目录项记录的文件在外存的存放位置、文件大小等信息，回收文件占用的磁盘块。（回收磁盘块时，根据空闲表法、空闲链表法、位图法等管理策略的不同，需要做不同的处理）。
  3. 从目录表中删除文件对应的目录项。

#### 打开文件

+ 在很多操作系统中，在对文件进行操作之前，要求用户先使用Open系统调用“打开文件”，需要提供的几个主要参数：
  1. 文件存放路径。
  2. 文件名。
  3. 要对文件的操作类型（如：r只读;
rw读写等）。
+ 操作系统在处理open系统调用时，主要做了几件事：
  1. 根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的的目录项，并检查该用户是否有指定的操作权限。
  2. 将目录项复制到内存中的“打开文件表”中。并将对应表目的编号返回给用户。之后用户使用打开文件表的编号来指明要操作的文件。
+ 打开文件表分为两种：
  1. 系统打开文件表，只有一张，包括编号、文件名、外存地址、打开计数器（多少个进程打开了次文件）等。
  2. 每一个进程的打开文件表，包括编号、文件名、读写指针、访问权限、系统表索引号等。
+ 打开文件时并不会把文件数据直接读入内存，而是提供索引号。“索引号”也称“文件描述符”。

#### 关闭文件

+ 用户使用Close系统调用“打开文件”，需要提供的几个主要参数：
  1. 文件存放路径。
  2. 文件名。
+ 操作系统在处理Close系统调用时，主要做了几件事：
  1. 将进程的打开文件表相应表项删除。
  2. 回收分配给该文件的内存空间等资源。
  3. 系统打开文件表的打开计数器count减1，若count=0，则删除对应表项。

#### 读文件

+ 打开文件后可以“读文件”，将文件数据读入内存，才能让CPU处理。
+ 进程使用Read系统调用完成写操作，需要提供几个主要参数：
  1. 在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的索引号（文件描述符）即可。
  2. 文件存放路径。
  3. 读入数据的数量（如:读入1KB）。
+ 操作系统在处理read系统调用时，会从读指针指向的外存中，将用户指定大小的数据读入用户指定的内存区域中。

#### 写文件

+ 进程使用Read系统调用完成写操作，需要提供几个主要参数：
  1. 在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的索引号（文件描述符）即可。
  2. 文件存放路径。
  3. 写回数据的数量。

### 文件共享

多个用户共享同一个文件，意味着系统中只有“一份”文件数据。并且只要某个用户修改了该文件的数据，其他用户也可以看到文件数据的变化。

文件共享方式分为：

+ 基于索引结点的共享方式：硬链接。
+ 基于符号链的共享方式：软链接。

#### 硬链接

+ 在文件目录中提到，索引结点，是一种文件目录瘦身策略。由于检索文件时只需用到文件名，因此可以将除了文件名之外的其他信息放到索引结点中。这样目录项就只需要包含文件名、索引结点指针。
+ 索引结点中设置一个链接计数变量count，用于表示链接到本索引结点上的用户目录项数。
+ 不同目录下对于同一个文件的索引结点的命名可以是不同的。
+ 若某个用户决定“删除”该文件，则只是要把用户目录中与该文件对应的目录项删除，且索引结点的count值减1。
+ 若count>0，说明还有别的用户要使用该文件，暂时不能把文件数据删除，否则会导致指针悬空。
+ 若count=0，则系统需要删除文件。

#### 软链接

+ 软链接就是共享时建立一个Link类型的文件，记录了要共享的文件的存放路径或任意一条硬链接路径，类似Windows系统的快捷方式。
+ 当访问共享文件时，回首先判断这个文件属于Link类型文件，然后根据其中记录的路径层层查找路径找到索引结点。
+ 若共享文件被删除了，则软链接失效。
+ 因为软链接访问共享文件时需要查询多层目录，所以有多层I/O操作，从而软链接访问速度慢于硬链接。

### 文件保护

#### 口令保护

+ 为文件设置一个“口令”，用户请求访问该文件时必须提供“口令”。
+ 口令一般存放在文件对应的FCB或索引结点中。用户访问文件前需要先输入“口令”，操作系统会将用户提供的口令与FCB中存储的口令进行对比，如果正确，则允许该用户访问文件。
+ 优点：保存口令的空间开销不多，验证口令的时间开销也很小。
+ 缺点：正确的“口令”存放在系统内部，不够安全。

#### 加密保护

+ 使用某个“密码”对文件进行加密，在访问文件时需要提供正确的“密码”才能对文件进行正确的解密。
+ 系统并不保存原始数据，而是加密过的数据。
+ 加密方式有异或加密等。
+ 优点：保密性强，不需要在系统中存储“密码”。
+ 缺点：编码/译码，或者说加密/解密要花费一定时间。

#### 访问控制

+ 在每个文件的FCB（或索引结点）中增加一个访问控制列表（AccessControl List，ACL），该表中记录了各个用户可以对该文件执行哪些操作。
+ 访问类型包括：
  + 读：从文件中读数据。
  + 写：向文件中写数据。
  + 执行：将文件装入内存并执行。
  + 添加：将新信息添加到文件结尾部。
  + 删除：删除文件，释放空间。
  + 列表清单：列出文件名和文件属性。
+ 有的计算机可能会有很多个用户，因此访问控制列表可能会很大，可以用精简的访问列表解决这个问题。
+ 精简的访问列表：以“组”为单位，标记各“组”用户可以对文件执行哪些操作。当某用户想要访问文件时，系统会检查该用户所属的分组是否有相应的访问权限。所以系统也需要管理分组的信息。
+ 若想要让某个用户能够获取某种权限，需要把该用户放入有该权限的分组即可。
+ 如果对某个目录进行了访问权限的控制，那也要对目录下的所有文件进行相同的访问权限控制。

### 文件系统层次结构

1. 设备。
2. 相关模块
   + 辅助分配模块：负责文件存储空间的管理，即负责分配和回收存储空间。
   + 设备管理模块：直接与硬件交互，负责和硬件直接相关的一些管理工作。如分配设备、分配设备缓冲区、磁盘调度、启动设备、释放设备等。
3. 物理文件系统：这一层需要把上一层提供的文件逻辑地址转换为实际的物理地址。
4. 逻辑文件系统与文件信息缓冲区：用户指明想要访问文件记录号，这一层需要将记录号转换为对应的逻辑地址。文件信息缓冲区用来在调入索引表到内存时暂存索引表的内容。
5. 存取控制模块：为了保证文件数据的安全，还需要验证用户是否有访问权限。这一层主要完成了文件保护相关功能。
6. 文件目录系统：用户是通过文件路径来访问文件的，因此这一层需要根据用户给出的文件路径找到相应的FCB或索引结点。所有和目录、目录项相关的管理工作都在本层完成，如管理活跃的文件目录
表、管理打开文件表等。
7. 用户接口：文件系统需要向上层的用户提供一些简单易用的功能接口。这层就是用于处理用户发出的系统调用请求（Read、Write、Open、Close等系统调用）。
8. 用户/应用程序。

假设某用户请求删除文件“D:/工作目录/学生信息.xlsx”的最后100条记录：

1. 用户需要通过操作系统提供的接口发出上述请求——用户接口。
2. 由于用户提供的是文件的存放路径，因此需要操作系统一层一层地查找目录，找到对应的目录项――文件目录系统
3. 不同的用户对文件有不同的操作权限，因此为了保证安全，需要检查用户是否有访问权限―-存取控制模块（存取控制验证层）。
4. 验证了用户的访问权限之后，需要把用户提供的“记录号”转变为对应的逻辑地址――逻辑文件系统与文件信息缓冲区。
5. 知道了目标记录对应的逻辑地址后，还需要转换成实际的物理地址――物理文件系统。
6. 要删除这条记录，必定要对磁盘设备发出请求――设备管理程序模块。
7. 删除这些记录后，会有一些盘块空闲，因此要将这些空闲盘块回收――辅助分配模块。

## 磁盘管理

### 磁盘结构

+ 磁盘由空气过滤片、主轴、音圈马达、永磁铁、磁盘、磁头、磁头臂组成。
+ 磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据。
+ 磁盘由多个盘片构成，盘片保存数据的一面就是盘面。一个盘片有一个或两个盘面。
+ 磁盘的盘面被划分成一个个磁道。这样的一个“圈”就是一个磁道。
+ 一个磁道又被划分成一个个扇区,每个扇区就是一个“磁盘块”。各个扇区存放的数据量相同。
+ 最内侧磁道上的扇区面积最小，因此数据密度最大。
+ 磁头用于读写盘面数据，需要把磁头移动到想要读/写的扇区所在的磁道。磁盘会转起来，让目标扇区从磁头下面划过，才能完成对扇区的读/写操作。
+ 每个盘面对应一个磁头。
+ 所以磁头都是链接在一个磁臂上，所有磁头的移动方向都是一致的。
+ 所有盘面中相对位置相同的磁道组成柱面。
+ 可用（柱面号，盘面号，扇区号）来定位任意一个磁盘块。
+ 地址读取方式：
  1. 根据“柱面号”移动磁臂，让磁头指向指定柱面。
  2. 激活指定盘面对应的磁头。
  3. 磁盘旋转的过程中，指定的扇区会从磁头下面划过，这样就完成了对指定扇区的读/写。
+ 磁盘的分类：
  + 磁头可以移动的称为活动头磁盘。磁臂可以来回伸缩来带动磁头定位磁道。
  + 磁头不可移动的称为固定头磁盘。这种磁盘中每个磁道有一个磁头。
  + 盘片可以更换的称为可换盘磁品。
  + 盘片不可更换的称为固定盘磁品。

### 磁盘操作时间

+ 寻找时间（寻道时间）Ts=s+m*n：在读/写数据前，将磁头移动到指定磁道所花的时间：
  + 启动磁头臂是需要时间的。假设耗时为s。
  + 移动磁头也是需要时间的。假设磁头匀速移动，每跨越一个磁道耗时为m，总共需要跨越n条磁道。
+ 延迟时间Tr=(1/2)*(1/r)=1/2r：通过旋转磁盘，使磁头定位到目标扇区所需要的时间。
  + 磁盘转速为r（单位:转/秒，或转/分）。
  + 1/r就是转一圈需要的时间。
  + 找到目标扇区平均需要转半圈，因此再乘以1/2。
+ 传输时间Tt=b/(r*N)：从磁盘读出或向磁盘写入数据所经历的时间。
  + 假设磁盘转速为r，此次读/写的字节数为b，每个磁道上的字节数为N。
  + 每个磁道要可存N字节的数据，因此b字节的数据需要b/N个磁道才能存储。而读/写一个磁道所需的时间刚好又是转一圈所需要的时间1/r，T=(1/r)*(b/N)。
+ 操作时间=寻道时间Ts+延迟时间Tr+传输时间Tt。
+ 延迟时间和传输时间都与磁盘转速相关，且为线性相关。而转速是硬件的固有属性，因此操作系统也无法优化延迟时间和传输时间，操作系统只能通过磁盘调度算法优化寻道时间。

### 磁盘调度算法

磁盘调度算法用来优化寻道时间。

**例题** 假设某磁盘的磁道为0~200号，磁头的初始位置是100号磁道，此时磁头正在往磁道号增大的方向，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道。

#### 先来先服务算法

+ 即FCFS算法，根据进程请求访问磁盘的先后顺序进行调度。
+ 优点：
  + 公平。
  + 如果请求访问的磁道比较集中的话，算法性能还算过的去。
+ 缺点：如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则FCFS在性能上很差，寻道时间长。

对于例题，按照FCFS的规则，移动顺序为55、58、39、18、90、160、150、38、184号磁道。一共移动了498个磁道。平均寻找长度为55.3。

#### 最短寻找时间优先算法

+ 即SSTF算法，会优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短。（其实就是贪心算法的思想，只是选择眼前最优，但是总体未必最优）。
+ 优点：性能较好，平均寻道时间短。
+ 缺点：
  + 可能产生“饥饿”现象。产生饥饿的原因在磁头可能在一个小区域内来回来去地移动。
  + 对于全局而言未必最优。

对于例题，按照SSTF的规则，首先需要将号码排序，移动顺序为90、58、55、39、38、18、150、160、184。一共移动了248个磁道。平均寻找长度为27.5。

#### 扫描算法

+ 也叫电梯算法，即SCAN算法，规定只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往移动。
+ 优点：
  + 性能较好，平均寻道时间较短。
  + 不会产生饥饿现象。
+ 缺点：
  + 只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了最大和最小的磁道的访问请求之后就不需要再往两边移动磁头了。
  + 对于各个位置磁道的响应频率不平均。（如假设此时磁头正在往右移动，且刚处理过90号磁道，那么下次处理90号磁道的请求就需要等磁头移动很长一段距离，而响应了184号磁道的请求之后，很快又可以再次响应184号磁道的请求了）。

对于例题，按照SCAN规则，因为磁头向增大的方向移动，所以应该最开始访问150号，而SCAN规定只有到了最边上的磁道才能改变磁头移动方向，所以移动到184号后还要移动到200号才能往小方向移动磁头，移动顺序为150、160、184、200、90、58、55、39、38、18。一共移动了282个磁道，平均寻找长度为31.3。

#### LOOK调度算法

+ 为了解决必须移动到两边磁道的缺点，LOOK规定如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向。
+ 优点：比起SCAN算法来,不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短。

对于例题，按照LOOK规则，到了184就可以立刻回头，所以移动顺序为150、160、184、90、58、55、39、38、18。一共移动了250个磁道，平均寻找长度为27.5。

#### 循环扫描算法

+ 即C-SCAN算法，为了解决每个位置磁道的响应频率不平均，规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而返回时直接快速移动至起始端而不处理任何请求。
+ 优点：比起SCAN来，对于各个位置磁道的响应频率很平均。
+ 缺点：
  + 平均寻道时间更长。
  + 只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了。
  + 磁头返回时其实只需要返回到18号磁道即可，不需要返回到最边缘的磁道。

对于例题，按照C-SCAN规则，先访问150号，然后移动到200达到边缘，立刻返回到0的位置不处理，从0开始向右扫描，所以移动顺序为150、160、184、200、0、18、38、39、55、58、90。一共移动了390个磁道，平均寻找长度为43.3。

#### C-LOOK调度算法

+ 为了解决必须移动到两边磁道的缺点，C-LOOK基于C-SCAN，规定如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向，且磁头只用返回到有磁道访问请求的位置即可。
+ 优点：比起C-SCAN算法来，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短.

对于例题，按照C-LOOK规则，先访问150号，然后移动到184，立刻返回到最靠左的18号，开始向右扫描，所以移动顺序为150、160、184、18、38、39、55、58、90。一共移动了322个磁道，平均寻找长度为35.8。

#### N步扫描算法

+ 即NStepSCAN算法，在SSTF，SCAN及CSCAN几种调度算法中，都可能会出现磁臂停留在某处不动的情况，例如，有一个或几个进程对某一磁道有较高的访问频率，即这个(些)进程反复请求对某一磁道的I/O操作，从而垄断了整个磁盘设备。我们把这一现象称为“磁臂粘着”（Armstickiness）。
+ 在高密度磁盘上容易出现此情况。N步SCAN算法是将磁盘请求队列分成若干个长度为N的子队列，磁盘调度将按FCFS算法依次处理这些子序列。而每处理一个队列时又是按SCAN算法，对一个队列处理完毕后，再处理其他队列。当正在处理某子序列时，如果又出现新的磁盘I/O请求，便将新请求进程放入其他队列，这样就可避免出现粘着现象。
+ 当N值取得很大时，会使N步扫描法的性能接近于SCAN算法的性能；当N=1时，N步SCAN算法便蜕化为FCFS算法。

#### 分步扫描算法

+ 即FSCAN算法，实质上是N步SCAN算法的简化，即FSCAN只将磁盘请求队列分成两个子队列。
+ 一个是当前所有请求磁盘I/O的进程形成的队列，由磁盘调度按SCAN算法进行处理。在扫描期间，将新出现的所有请求磁盘I/O的进程，放入另一个等待处理的请求队列。这样，所有的新请求都将被推迟到下一次扫描时处理。

### 延迟时间处理

磁头在读取一块内容后需要一段时间处理，由于盘片不断旋转，从而在处理本块内容时，回错过相邻扇区的处理，从而只能等待下次再旋转到此扇区进行读取，所以如果逻辑上相邻的扇区在物理上也相邻，则读入几个连续的逻辑扇区，可能需要很长的延迟时间。

#### 磁盘地址结构设计

+ 为什么磁盘的物理地址是（柱面号，盘面号，扇区号）而不是（盘面号，面号，扇区号）。
+ 读取地址连续的磁盘块时，采用（柱面号，盘面号，扇区号）的地址结构可以减少磁头移动消耗的时间。
+ （柱面号，盘面号，扇区号）若要连续读取物理地址（000，00，000）~（000，01，111）的扇区，读取完（000，00，000）~（000，00，111）由于柱面号/磁道号相同，只是盘面号不同，因此不需要移动磁头臂。只需要激活相邻盘面的磁头即可。
+ 若物理地址结构是（盘面号，柱面号，扇区号），且需要连续读取物理地址（00, 000,000）~（00,001,111）的扇区，则（00,000,000）~（00,000,111）转两圈可读完，之后再读取物理地址相邻的区域，即（00,001,000）~（00,001,111 ），需要启动磁头臂，将磁头移动到下一个磁道，花费时间更多。

#### 交替编号

让逻辑上相邻的扇区在物理上有一定的间隔，可以使读取连续的逻辑扇区所需要的延迟时间更小。

#### 错位命名

若相邻的盘面相对位置相同处扇区编号相同，则会出现不能连续读取的问题。所以使用错位命名，同一柱面不同盘面的扇区编号不同，从而有足够的时间来处理。

### 磁盘的管理

#### 磁盘初始化

1. 进行低级格式化（物理格式化），将磁盘的各个磁道划分为扇区。一个扇区通常可分为头、数据区域（如512B大小)、尾三个部分组成。管理扇区所需要的各种数据结构一般存放在头、尾两个部分，包括扇区校验码（如奇偶校验、CRC循环冗余校验码等，校验码用于校验扇区中的数据是否发生错误）。
2. 将磁盘分区，每个分区由若干柱面组成（即分为我们熟悉的C盘、D盘、E盘）。
3. 进行逻辑格式化，创建文件系统。包括创建文件系统的根目录、初始化存储空间管理所用的数据结构（如位示图、空闲分区表）。

#### 引导块

+ 计算机开机时需要进行一系列初始化的工作，这些初始化工作是通过执行初始化程序（自举程序）完成的。
+ 初始化程序可以放在ROM（只读存储器）中。ROM中的数据在出厂时就写入了，并且以后不能再修改。
+ 一般ROM因为无法修改所以只会存放很小的自举装入程序。
+ 完整的自举程序放在磁盘的启动块（即引导块/启动分区）上，启动块位于磁盘的固定位置。
+ 开机时计算机先运行自举装入程序出通过执行该程序就可找到引导块,并将完整的自举程序读入内存，完成初始化。
+ 拥有启动分区的磁盘称为启动磁盘或系统磁盘（C盘）。

#### 坏块管理

+ 坏了、无法正常使用的扇区就是“坏块”。这属于硬件故障,操作系统是无法修复的。应该将坏块标记出来,以免错误地使用到它。
+ 对于简单的磁盘，可以在逻辑格式化时（建立文件系统时）对整个磁盘进行坏块检查，标明哪些扇区是坏扇区，比如在FAT表上标明。在这种方式中，坏块对操作系统不透明。
+ 对于复杂的磁盘，磁盘控制器（磁盘设备内部的一个硬件部件）会维护一个坏块链表。
+ 在磁盘出厂前进行低级格式化（物理格式化）时就将坏块链进行初始化。
+ 操作系统会保留一些“备用扇区”，用于替换坏块。这种方案称为扇区备用。且这种处理方式中，坏块对操作系统透明。
