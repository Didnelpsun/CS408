# 内存管理

## 内存管理概念

### 内存管理基础知识

#### 内存

+ 内存是用于存放数据的硬件。程序执行前需要先放到内存中才能被CPU处理用于缓冲速度。
+ 内存地址从0开始，每个地址对应一个存储单元。
+ 存储单元的大小不定：
  + 按字节编址，则每个存储单元大小为1B，八个二进制位。
  + 按字编址，每个存储单元大小为一个字，根据计算机的字长确定大小，若字长为16位，则一个字大小为16个二进制位。
+ 相对地址又称逻辑地址，绝对地址又称物理地址。编译时只考虑逻辑地址，实际放入内存再考虑物理地址。

#### 程序运行过程

+ 程序运行过程：
  1. 编译：由编译程序将用户源代码编译成若干个目标模块（编译就是把高级语言翻译为机器语言）。
  2. 链接：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块。
  3. 装入（装载）：由装入程序将装入模块装入内存运行。
+ 链接的三种方式（将独立的逻辑地址合并为完整的逻辑地址。）：
  1. 静态链接：在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开。
  2. 装入时动态链接：将各目标模块装入内存时，边装入边链接的链接方式。
  3. 运行时动态链接：在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。
+ 装入的三种方式（将逻辑地址转换为物理地址）：
  1. 绝对装入（单道程序阶段、未产生操作系统）：在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。
     + 绝对装入只适用于单道程序环境。
     + 程序中使用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。
     + 通常情况下都是编译或汇编时再转换为绝对地址。
  2. 静态重定位（可重定位装入）（多道批处理操作系统）：编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，使用单独的装入程序将装入模块装入到内存的适当位置。装入时对地址进行“重定位”，将逻辑地址变换为物理地址（地址变换是在装入时一次完成的）。
     + 静态重定位的特点是在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。
     + 作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间。
  3. 动态重定位（动态运行时装入）（现代操作系统）：编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才进行。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定位寄存器的支持。
     + 采用动态重定位时允许程序在内存中发生移动。
     + 可将程序分配到不连续的存储区中：在程序运行前只需裂入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存。
     + 便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。

#### 内存管理功能

1. 操作系统负责内存空间的分配与回收。
2. 操作系统需要提供某种技术从逻辑上对内存空间进行扩充。
3. 操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换。
4. 操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰：
   + 在CPU中设置一对上、下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界。
   + 采用重定位寄存器（又称基址寄存器）和界地址寄存器（又称限长寄存器）进行越界检查。重定位寄存器中存放的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址。

### 内存空间分配回收

分为：

+ 连续分配管理：
  + 单一连续分配。
  + 固定分区分配。
  + 动态分区分配。
+ 非连续分配管理（离散分配方式）：
  + 基本分页存储管理。
  + 基本分段存储管理。
  + 段页式存储管理。

连续分配是指为用户进程分配的必须是一个连续的内存空间。而非连续分配反之。

+ 内部碎片，分配给某进程的内存区域中，如果有些部分没有用上。
+ 外部碎片，是指内存中的某些空闲分区由于太小而难以利用。

#### 在单一连续分配

+ 内存被分为系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据:用户区用于存放用户进程相关数据。
+ 内存中只能有一道用户程序，用户程序独占整个用户区空间。
+ 优点：
  + 实现简单。
  + 无外部碎片。
  + 可以采用覆盖技术扩充内存。
  + 不一定需要采取内存保护（如早期的PC操作系统Ms-Dos）。
+ 缺点：
  + 只能用于单用户、单任务的操作系统中。
  + 有内部碎片。即分配给某进程的内存区域中，如果有些区域没有用上的部分
  + 存储器利用率极低。

#### 固定分区分配

+ 将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业。
+ 分区的方式：
  + 分区大小相等：缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合。
  + 分区大小不等：增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分（比如:划分多个小分区、适量中等分区、少量大分区）。
+ 记录分区的方法：操作系统需要建立一个数据结构——分区说明表，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的天小、起始地址、状态（是否已分配）。
+ 分区分配过程：当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状态为“己分配”。
+ 优点：
  + 实现简单。
  + 无外部碎片。
+ 缺点：
  + 当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能。
  + 会产生内部碎片，内存利用率低。

#### 动态分区分配

+ 动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。
+ 记录分区的方法：
  + 空闲分区表：每空闲分区对应表项。表项中包含分区号、分区大小、分区起始地址、分区状态等信息。
  + 空闲分区链：每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息。
+ 分配分区：
  + 当选择的分区分区大小大于分配空间，则分区大小相减，并修改起始地址。
  + 当选择的分区分区大小等于分配空间，则删除该表项。
+ 回收分区：
  + 若回收区的后面或前面有一个相邻的空闲分区则合并为一个。
  + 若回收区的后面和前面都有一个相邻的空闲分区则合并为一个。
  + 若回收区的后面或前面都没有一个相邻的空闲分区，则增加一个表项。
+ 动态分区分配会导致外部碎片，可用通过**紧凑**（拼凑）技术来移动进程位置合并空闲空间。

动态分区分配算法，为了解决动态分区分配方式中如何从多个空闲分区中选择一个分区分配：

1. 首次适应算法（First Fit）：
   + 算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。
   + 如何实现：空闲分区以**地址**递增的次序排列。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。
   + 优点：
     + 首次适应算法每次都要从头查找，每次都需要检索低地址的小分区。但是这种规则也决定了当低地址部分有更小的分区可以满足需求时，会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的天分区保留下来。
     + 算法开销小，每次分区后不需要对分区队列重新排序。
2. 最佳适应算法（Best Fit）：
   + 算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，优先使用更小的空闲区。
   + 如何实现：空闲分区按**容量**递增次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。当分配完后需要重新调整空闲分区链（或空闲分区表）。
   + 优点：容易保存大分区。
   + 缺点：
     + 每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。因此这种方法会产生很多的外部碎片且很难查找回收。
     + 算法开销大，每次分区外需要对分区队列进程重新排序。
3. 最坏适应算法（Worst Fit）或最大适应算法（Largest Fit）：
   + 算法思想：为了解决最佳适应算法的问题――即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。
   + 如何实现：空闲分区按**容量**递减次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。当分配完后需要重新调整空闲分区链（或空闲分区表）。
   + 优点：可用减少难以利用的小碎片。
   + 缺点：
     + 每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。如果之后有“大进程”到达，就没有内存分区可用了。
     + 算法开销大，每次分区外需要对分区队列进程重新排序。
4. 临近适应算法（Next Fit）：
   + 算法思想:首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。
   + 如何实现:空闲分区以地址递增的顺序排列（可排成一个循环链表）。每次分配内存时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。
   + 优点：减少了检索空闲分区的次数，提高了效率。
   + 缺点：邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用。

所以综合来看，首次适应算法效果最好就。

#### 基本分页存储管理

+ 将内存空间分为一个个大小相等的分区（比如每个分区4KB），每个分区就是一个“页框”，或称“页帧”、“内存块”、“物理块”。每个页框有一个编号，即“页框号”（或者“内存块号”、“页帧号”、“物理块号”）页框号从0开始。
+ 将用户进程的地址空间也分为与页框大小相等的一个个区域，称为“页”或“页面”。每个页面也有一个编号，即“页号”，页号也是从0开始。所以页面不同于页框，是进程的逻辑概念。（进程的最后一个页面可能没有一个页框那么大。因此，页框不能太大，否则可能产生过大的内部碎片）
+ 操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的页面与内存的页框有一一对应的关系。
+ 各个页面不必连续存放，也不必按先后顺序来，可以放到不相邻的各个页框中。
+ 为了方便计算页号、页内偏移量、页面大小一般设为出的整数幂。
+ 如果每个页面大小为$2^k$B，用二进制数表示逻辑地址，则末尾k位即为页内偏移量，其余部外就是页号
+ 因为允许将进程的各个页离散地存储在内存不同的物理块中，但系统应能保证进程的正确运行，即能在内存中找到每个页面所对应的物理块，所以为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表，其中页表大小也与页面一样被页框约束。
  + 一个进程对应一张页表。
  + 进程的每一页对应一个页表项。
  + 每个页表项由“页号”和“块号”组成。完成从逻辑的页号向物理的块号的映射。
  + 页表记录进程页面和实际存放的内存块之间的对应关系。

**例题** 假设某系统物理内存大小为4GB，页面大小为4KB，则每个页表项至少应该为多少字节？

4GB = $2^{32}$B，4KB = $2^{12}$B。

因此4GB的内存总共会被分为$2^{32}/2^{12}= 2^{20}$个内存块，因此内存块号的范围应该是$0\cdots2^{20}-1$，因此至少要20个二进制位才能表示这么多的内存块号，因此至少要3个字节才够，因为每个字节8位，$3\times8=24$。

所以最少为三个字节。

深入来看，因为每页表项会顺序连续存储在内存中，若该页表在内存中存放的起始地址是X，则M号页对应的页表项存放在内存地址X+3*M。

同时因为页面大小为4KB，所以每个页框（即可用存放的最大值）大小为4*1024/3=1365个页表项，但是此时会余下4\*1024/3=1B页内碎片，所以一定会在中间空出1B内存，所以1365号页在页框约束下会在新的下一个页框存储，表项会存放在X+3\*1365+1处。这时候地址公式就不管用了。

而如果每个页表项占4字节，则每个页框刚好能放下1024个页表项，从而没有余数，能减少查找的麻烦。

所以理论上3B就能表示内存块的范围，但是为了方便页表查找（对齐），实际上会多一些字节，使得每个页面能装下整数个页表项。

#### 基本地址变换机构

可用借助页表进行转换，通常会在系统中设置一个页表寄存器（PTR），存放页表在内存中的起始地址F和页表长度M（即这个进程里有多少页）。进程未执行时，页表的始址和页表长度放在进程控制块（PCB）中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。

在页式存储管理的系统中时，只用确定页面大小和逻辑结构就能得到物理地址。

基本地址变换机构需要先查询页表，再查询内存两次操作：

1. 要算出逻辑地址A对应的页号P与页内偏移量W。页号P=逻辑地址A/页面长度L（取除法的整数部分）。页内偏移量W=A逻辑地址%页面长度L（取除法的余数部分）。
2. 检测页号P是否越界。如果页号P大于等于页表长度M，则内中断（因为页号从0开始，页表长度至少为1，从而P=M页会越界）。
3. 根据页表寄存器中的页表项地址PA=页表起始地址F+页号P*页表项长度PL，得到页表中对应的页表项，从而确定页面存放的内存块号B。
   + 页表长度指的是这个页表中总共有几个页表项，即总共有几个页。
   + 页表项长度指的是每个页表顶占多大的存储空间。
   + 页面大小指的是一个页面占多大的存储空间。
4. 最后物理地址E=内存块号B*页面大小L+页内偏移量W（如果内存块号和业内偏移量用二进制表示，则直接拼接起来就是最终物理地址了）。

**例题** 若页面大小L为1K字节，页号2对应的内存块号B=8，将逻辑地址A=2500转换为物理地址E。

等价描述：某系统按字节寻址，逻辑地址结构中，页内偏移量占10位，页号2对应的内存块号b=8，将逻辑地址A=2500转换为物理地址E。

按照等价描述，若一个页面的页内偏移量占10位，所以页面大小需要10位来表示，即页面大小为$2^{10}B=1KB$。

第一步，计算页号和页内偏移量。页号P=A/L=2500/1024=2，页内偏移量W=A%L=2500%1024=452。

第二步，没有越界，其存放的内存块号为8。

第三步，物理地址E=B\*L+W=8\*1024+452=8848。

#### 具有快表的地址变换机构

+ 时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行;如果某个数据被访问过，不久之后该数据很可能再次被访问（因为程序中存在大量的循环）。
+ 空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问（因为很多数据在内存中都是连续存放的）。
+ 快表，又称相连寄存器（TLB)，是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。
+ 由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。
+ 因为局部性原理，一般来说快表的命中率可以达到90%以上。
+ 快表的地址变换过程：
  1. CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。
  2. 如果找到匹配的页号（即命中），说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。
  3. 如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照一定的页面置换算法对旧的页表项进行替换。因此，若快表未命中，则访问某个逻辑地址需要两次访存。

**例题** 某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。访问一次快表耗时1μs，访问一次内存耗时100μs。若快表的命中率为90%，那么访问一个逻辑地址的平均耗时是多少?

若快表命中，则只用查找一次快表和一次内存，若快表不命中，则要查找一次快表和两次内存。

所以(1+100)\*0.9+(1+100+100)*0.1=111μs。

若该系统支持快表慢表同时查找，则为(1+100)\*0.9+(100+100)*0.1=110.9μs。

#### 两级页表

单级页表的缺点：

1. 单级页表的所有表项都必须连续存储，实现起来比较困难。
2. 进程在一段时间内只需要访问少数页面就可用正常运行，无需整个页表都常驻内存。

将页表进行分组离散地放入内存块，并为离散分组的页表再建立一张页表，称为页目录表、外层页表或顶层页表，页目录表页保存序号和内存块号两项。两级页表结构的逻辑地址结构分为一级页号、二级页号和页内偏移量三项。

#### 基本分段存储管理

#### 段页式存储管理

### 内存空间扩充

内存空间的扩充（用容量小的内存运行大的程序）有三种技术：

1. 覆盖技术。
2. 交换技术。
3. 虚拟存储技术。

#### 覆盖技术

覆盖技术在同一个程序或进程中执行。

+ 覆盖技术的思想：将程序分为多个段（多个模块）。常用的段常驻内存，不常用的段在需要时调入内存。
+ 内存中分为一个“固定区”和若干个“覆盖区”。
+ 需要常驻内存的段放在“固定区”中，调入后就不再调出（除非运行结束）。
+ 不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存。
+ 按照自身代码逻辑结构，让那些不可能同时被访问的程序段共享同一个覆盖区。
+ 缺点：
  + 必须由程序员声明覆盖结构，操作系统完成自动覆盖。
  + 对用户不透明，增加了用户编程负担。

#### 交换技术

交换技术在不同进程或作业之间进行的。

+ 交换（对换）技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）。
+ 交换的位置：具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式;对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用连续分配方式（学过文件管理章节后即可理解）。总之，对换区的I/o速度比文件区的更快。
+ 交换的时机：交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程；如果缺页率明显下降、就可以暂停换出。
+ 交换进程的选择：
  + 可优先换出阻塞进程。
  + 可换出优先级低的进程。
  + 为了防止优先级低的进程在被调入内存后很快又被换出，考虑进程在内存的驻留时间。
+ 暂时换出外存等待的进程状态是挂起状态。
+ 处理机调度的中级调度（内存调度）就是交换技术的实现。进程的PCB常驻内存。

## 虚拟内存管理
