# 进程管理

## 进程与线程

### 进程的概念

+ 程序指一个指令序列。
+ 系统为每个运行的程序配置一个数据结构，称为**进程控制块PCB**，用来描述进程的各种信息，如程序代码存放位置。
+ PCB、程序段、数据段三个部分构成了进程实体（进程映像），简称为进程。
+ 创建进程就是创建PCB，销毁进程就是销毁PCB，PCB是进程存在的唯一标志。
+ 进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。

#### 进程的结构

+ 程序段：包括程序代码，程序运行时使用、产生的运算数据。如全局变量、局部变量、宏定义的常量。
+ 数据段：存放程序运行过程中处理的各种数据。
+ PCB：操作系统用PCB来管理进程，所以PCB包含所有管理进程所需的信息。
  + 进程描述信息：
    + 进程标识符PID。
    + 用户标识符UID。
  + 进程控制和管理信息：
    + 进程当前状态。
    + 进程优先级。
  + 资源分配清单：
    + 程序段指针。
    + 数据段指针。
    + 键盘。
    + 鼠标。
  + 处理机相关信息：
    + 各种寄存器值。

#### 进程的特征

+ 动态性：是进程最基本的特征，进程是程序的一次执行过程，是动态地产生、变化和消亡的。
+ 并发性：内存中有多个进程实体，各进程可并发执行。
+ 独立性：进程是资源分配、接受调度、能独立运行、独立获得资源、独立接受调度的基本单位。
+ 异步性：各进程按各自独立的、不可预知的速度向前推进，操作系统要提供“进程同步机制”来解决异步问题。
+ 结构性：每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成。

#### 进程的组织

当一个系统中存在多格PCB时，需要以适当的方式组织PCB。

+ 链接方式：
  + 按照进程状态将PCB分为多个队列。如执行指针（指针数为最大执行并行数）、就绪队列指针（一般会把优先级高的进程放在队头）、阻塞队列指针（许多操作系统会根据阻塞原因的不同将其分为多个阻塞队列）。
  + 操作系统持有指向各个队列的指针。
+ 索引方式：
  + 根据进程状态的不同建立索引表。如执行指针、就绪表指针、阻塞表指针。
  + 操作系统持有指向各个索引表的指针。

### 进程的状态

#### 基本进程状态

具有三种基本状态和其他两种状态：

+ 运行态：占有CPU并已经在CPU上运行。
+ 就绪态：已经具备运行条件，但是由于没有空闲CPU，导致暂时不能运行。
+ 阻塞态（等待态）：因等待某一事件而暂时不能运行，只有分配到位才能考虑分配CPU。
+ 创建态（新建态）：为进程分配所需的内存空间等系统资源，为其创建、初始化PCB。
+ 终止态（结束态）：进程运行结束或出现错误导致进程被撤销，操作系统需要回收进程资源，撤销PCB等工作，以防止内存泄漏。
+ 挂起态：暂时不能获得服务，进程映像调到外存等待（阻塞态的进程映像还在内存中等待）。分为：
  + 就绪挂起态。
  + 阻塞挂起态。

#### 进程状态的转换

+ 创建态到就绪态：系统完成创建进程等工作并准备好处理机等资源。
+ 就绪态到运行态：占有CPU资源，进程被调用。
+ 运行态到就绪态：时间片到或处理机（包含CPU和内存的一系列硬件）被抢占。
+ 运行态到阻塞态：进程主动用系统调用的方式申请某种系统资源，或请求等待某个事件发生。
+ 阻塞态到就绪态：申请的资源被分配或等待的事件发生。
+ 运行态到终止态：进程运行结束或运行过程中遇到不可修复的错误。
+ 就绪挂起态到就绪态：激活。
+ 就绪态到就绪挂起态：挂起。
+ 阻塞挂起态到阻塞态：激活。
+ 阻塞态到阻塞挂起态：挂起。
+ 阻塞挂起态到就绪挂起态：阻塞事件发生。
+ 运行态到就绪挂起态：运行中内存空间不足，或优先级更高的进程进入队列。
+ 创建态到就绪挂起态：创建后发现内存空间不足。

### 进程的控制

#### 进程控制的概念

+ 进程控制指对系统中的所有进程实施有效的管理，具有创建新进程、撤销已有进程、实现进程状态转换功能。
+ 如进程组织所说，通过将PCB指针放入各种状态的进程队列中转换进程状态来实现控制。
+ 进程控制由原语实现。
  + 特点是执行期间不能中断。
  + 这种不能中断的操作就是原子操作。
  + 原语采取“关中断指令”（不监听外部中断信息）和“开中断指令”（开始监听外部中断信息）实现。
  + 关/开中断指令的权限很大，所以必然是核心态下执行的特权指令。从而原语必然运行在核心态。

#### 进程控制的原语

+ 过程的创建：
  + 创建原语：
    + 申请空白PCB。
    + 为新进程分配所需资源。
    + 初始化PCB。
    + 将PCB插入就绪队列。
  + 引起进程创建的事件：
    + 用户登录：分时系统中，用户登录成功，系统会为其建立一个新进程。
    + 作业调度：多道批处理系统中，有新的作业进入内存时，会为其创建一个新进程。
    + 提供服务：用户向系统提出请求时，会创建一个新进程来处理请求。
    + 应用请求：由用户进程主动请求创建一个子进程。
+ 进程终止：
  + 撤销原语：
    + 从PCB集合中找到终止进程的PCB。
    + 若进程正在运行，则立刻剥夺其CPU交给其他进程。
    + 若是普通的终止，父进程终止时会将其子进程交给init进程收养。
    + 若是整个进程组的进程，则终止其所有子进程。
    + 将进程所有的资源交给父进程或操作系统。
    + 删除PCB。
  + 引起进程终止的事件：
    + 正常结束。
    + 异常结束。
    + 外界干预。
+ 进程阻塞：
  + 阻塞原语：
    + 找到要阻塞的进程对应的PCB。
    + 包含进程运行现场，将PCB状态信息设置为阻塞态，暂停进程。
    + 将PCB插入事件等待队列。
  + 引起进程阻塞的事件：
    + 需要等待系统分配资源。
    + 需要等待相互合作的其他进程完成工作。
+ 进程唤醒：
  + 唤醒原语：
    + 在事件等待队列中找到PCB。
    + 将PCB从等待队列中移除，设置进程为就绪态。
    + 将PCB插入就绪队列，等待被调度。
  + 引起进程唤醒的事件：
    + 等待的事件的发生（因何事被阻塞因何事被唤醒）。
+ 进程切换：
  + 切换原语：
    + 将运行环境信息存入PCB。
    + PCB移入相应队列。
    + 选择另一个进程执行，并更新其PCB。
    + 根据PCB恢复新进程所需的运行环境。
  + 引起进程切换的事件：
    + 当前时间片到。
    + 有更高优先级进程到达。
    + 当前进程主动阻塞。
    + 当前进程终止。

### 进程的通信

进程通信是进程之间的信息交换。

为了保证安全，一个进程不能直接访问另一个进程的地址空间。

+ 共享存储：分配一个可以共同使用的共享空间，进程对其的使用必须是互斥的。
  + 基于数据结构：共享空闲只能放固定的数据结构如数组等。速度慢，限制多，是低级通信方式。
  + 基于存储取：内存中划出一块共享存储区，数据的形式、存放位置都由进程控制而非操作系统。速度更快，限制少，是高级通信方式。
+ 管道通信：指用于链接读写进程的一个共享文件，又名pipe文件，其实就是内存中开辟一个大小固定的缓冲区。  
  + 只能使用半双工的通信，某一时间段内只能单向传输，若要双向同时通信则必须设置两个管道。
  + 进程需要互斥访问管道。
  + 数据以字符流的形式写入管道，当满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞。
  + 如果没有写满则不允许读，如果没有读空则不允许写。
  + 数据一旦被读出就被管道抛弃，所以读进程只能至多有一个，否则可能会读错。
+ 信息传递：进程间的数据交换以格式化的消息为单位。进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换。
  + 消息包括消息头和消息体，消息头包括：发送进程ID、接受进程ID、消息类型、消息长度等格式化的信息。
  + 消息传递包括：
    + 直接通信方式：消息直接挂到接受进程的信息缓冲队列上。
    + 间接通信方式：消息先发送到中间实体（信箱）中，因此也称为信箱通信方式，如计算机网络中的电子邮件系统。

### 线程

#### 线程的概念

传统而看，进程是程序的一次执行，但是程序的多个功能不能由一个程序顺序处理就能完成，所以一个进程需要同时进行多个任务，所以就引入了线程来增加并发度。

线程是基本的CPU执行单元，是程序执行流的最小单位。进程只作为除CPU之外的系统资源的分配单元，即打印机等都是分配给进程而不是线程。

#### 进入线程的变化

+ 系统分配调度：
  + 传统进程机制中，进程是资源分配、调度的基本单位。
  + 引入线程后，进程是资源分配的基本单位，线程是调度的基本单位。
+ 并发性：
  + 传统进程机制中，只能进程间并发。
  + 引入线程后，各线程间也能并发，提升了并发度。
+ 系统开销：
  + 传统的进程间并发，需要切换进程的运行环境，系统开销很大。
  + 线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小。
  + 引入线程后，并发所带来的系统开销减小。

#### 线程的属性

+ 线程是处理机调度的单位。
+ 多CPU计算机中，各个线程可占用不同的CPU。
+ 每个线程都有一个线程ID、线程控制块(TCB)。
+ 线程也有就绪、阻塞、运行三种基本状态。
+ 线程几乎不拥有系统资源。
+ 同一进程的不同线程间共享进程的资源。
+ 由于共享内存地址空间，同-进程中的线程间通信甚至无需系统干预。
+ 同一进程中的线程切换，不会引起进程切换。
+ 不同进程中的线程切换，会引起进程切换。
+ 切换同进程内的线程，系统开销很小。
+ 切换进程，系统开销较大。

#### 线程的实现

+ 用户级线程：
  + 用户级线程由应用程序通过线程库实现。所有的线程管理工作都由应用程序负责（包括线程切换）。
  + 用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。
  + 在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。用户级线程对用户不透明，对操作系统透明。
  + “ 用户级线程”就是“从用户视角看能看到的线程”。
+ 内核级线程（内核支持的线程）：
  + 内核级线程的管理工作由操作系统内核完成。
  + 线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。
  + “内核级线程” 就是“从操作系统内核视角看能看到的线程”。
  + 由于操作系统只能看见内核级线程，所以只有内核级线程才是处理机分配的单位。

#### 多线程模型

对于用户级线程映射到内核级线程的问题出现了“多线程模型”问题。

+ 多对一模型：
  + 多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。
  + 优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高。
  + 缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。
+ 一对一模型：
  + 一个用户及线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。
  + 优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。
  + 缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。
+ 多对多模型：
  + 在同时支持用户级线程和内核级线程的系统中，可以使用二者结合的方式，将$n$个用户级线程映射到$m$个内核级线程上（$n\geqslant m$）。
  + 克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。

## 处理机调度

### 处理机调度的概念

+ 处理机：包括中央处理器，主存储器，输入输出接口，加接外围设备就构成完整的计算机系统。处理机是处理计算机系统中存储程序和数据，并按照程序规定的步骤执行指令的部件。
+ 处理机调度：在多道程序设计系统中，内存中有多道程序运行，他们相互争夺处理机这一重要的资源。处理机调度就是从就绪队列中，按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程并发地执行。

### 处理机调度的层次

+ 高级调度（作业调度）：
  + 由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序。一般一个作业包含多个进程。
  + 高级调度按一定的原则从外存上处于后备队列的作业中挑选一个(或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB），以使它（们）获得竞争处理机的权利。
  + 高级调度是辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。
  + 高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。
+ 中级调度（内存调度）：
  + 引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。这么做的目的是为了提高内存利用率和系统吞吐量。
  + 暂时调到外存等待的进程状态为挂起状态。值得注意的是，PCB并不会一起调到外存，而是会常驻内存。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到的挂起队列中。
  + 中级调度就是要决定将哪个处于挂起状态的进程重新调入内存。
  + 一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。
+ 低级调度（进程调度)：
  + 其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。
  + 进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。
  + 进程调度的频率很高，一般几十毫秒一次。

&nbsp;|工作内容|发生位置|发生频率|对进程状态的影响
:----:|:------:|:-----:|:-----:|:-------------:
高级调度（作业调度）|按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程|外存→内存（面向作业）|一个作业一个调入一次调出|无→创建态→就绪态
中级调度（内存调度）|按照某种规则，从挂起队列中选择合适的进程将其数据调回内存|外存→内存（面向进程）|中等|挂起态→就绪态（阻塞挂起→阻塞态）
低级调度(进程调度）|按照某种规则，从就绪队列中选择一个进程为其分配处理机|内存→CPU|最高|就绪态→运行态

### 进程调度

进程调度是最低级的调度也是其他调度的基础。

#### 进程调度的时机

需要进行进程调度和切换：

+ 当前运行程序主动放弃处理机：
  + 进程正常终止。
  + 出现异常终止。
  + 进程主动请求阻塞（如等待IO）。
+ 当前运行程序被动放弃处理机：
  + 分配时间片用完。
  + 有更紧急的事件需要处理（如IO中断）。
  + 优先级更高进程进入就绪队列。

不能进行进程调度和切换：

+ 在处理中断的过程中。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换。
+ 进程在操作系统**内核程序临界区**中。
  + 临界资源:一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。
  + 临界区：访问临界资源的那段代码。
  + 内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列（由各就绪进程的PCB组成）。
  + 进程访问时会上锁，而如果还没退出临界区（还没解锁）就进行进程调度但是进程调度相关的程序也需要访问就绪队列，但此时就绪队列被锁住了，因此无法顺利进行进程调度。
  + 内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。因此在访问内核程序临界区期间不能进行调度与切换。
  + 而如果是普通程序临界区时，如在打印机打印完成之前，进程一直处于临界区内，临界资源不会解锁。但打印机又是慢速设备，此时如果一直不允许进程调度的话就会导致CPU一直空闲，所以为了保证效率进程在操作系统普通程序临界区时运行进程调度。
+ 在原子操作过程中（原语）。原子操作不可中断，要一气呵成（如修改PCB中进程状态标志，并把PCB放到相应队列）。

#### 进程调度的方式

针对操作系统是否可以剥夺进程处理机，进程调度方式分为：

+ 非剥夺调度方式，又称非抢占方式：
  + 只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。
  + 实现简单，系统开销小但是无法及时处理紧急任务。
  + 适合于早期的批处理系统。
+ 剥夺调度方式，又称抢占方式：
  + 当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。
  + 可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。
  + 适合于分时操作系统、实时操作系统。

#### 进程切换与过程

进程调度与进程切换的区别：

+ 狭义的进程调度指的是从就绪队列中选中一个要运行的进程。（这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换）。
+ 进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程。
+ 广义的进程调度包含了选择一个进程和进程切换两个步骤。

进程切换的过程主要完成了：

1. 对原来运行进程各种数据的保存
2. 对新的进程各种数据的恢复。
（如:程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）。

<span style="color:orange">注意：</span>进程切换是有代价的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。

### 调度算法

指作业与进程的调度算法。

#### 算法评价指标

+ CPU利用率：CPU忙碌时间占总时间的比例。其中利用率=忙碌时间/总时间。
+ 系统吞吐量：单位时间内完成作业的数量。系统吞吐量=总共完成多少道作业/总时间。
+ 周转时间：从作业被提交到系统开始到作业完成为止的时间间隔。
  + 它包括四个部分：作业在外存后备队列上等待作业调度（高级调度）的时间、进程在就绪队列上等待进程调度（低级调度）的时间、进程在CPU上执行的时间、进程等待I/O操作完成的时间。后三项在一个作业的整个处理过程中，可能发生多次。
  + （作业）周转时间=作业完成时间-作业提交时间。
  + 平均周转时间=各作业周转时间之和/作业数。
  + 带权周转时间=作业周转时间/作业实际运行的时间=(作业完成时间-作业提交时间)/作业实际运行的时间（≥1）。
  + 平均带权周转时间=各作业带权周转时间之和/作业数。
+ 等待时间：指进程或作业处于等待处理机状态时间之和。
  + 对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。
  + 对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。
  + 一个作业总共需要被CPU服务多久，被I/O设备服务多久一般是确定不变的，因此调度算法其实只会影响作业或进程的等待时间。当然，与前面指标类似，也有“平均等待时间”来评价整体性能。
  + 如果一个进程到达后要么等待要么运行，则等待时间=周转时间-运行时间。
  + 如果一个进程又有计算又有I/O操作，则等待时间=周转时间-运行时间-I/O操作时间。
+ 响应时间：从用户提交请求到首次产生响应所用的时间。

#### 先来先服务

即FCFS算法。

+ 算法思想：主要从“公平”的角度考虑。
+ 算法规则：按照作业/进程到达的先后顺序进行服务。
+ 用于作业/进程调度：用于作业调度时，考虑的是哪个作业先到达后备队列；用于进程调度时，考虑的是哪个进程先到达就绪队列。
+ 是否可抢占：非抢占式的算法。
+ 优缺点：
  + 优点:公平、算法实现简单。
  + 缺点:排在长作业(进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。即FCFS算法对长作业有利，对短作业不利。
+ 是否会导致饥饿：不会。

**例题：**各进程到达就绪队列的时间、需要的运行时间如下表所示。使用先来先服务调度算法，计算各进程的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周转时间。

进程|到达时间|运行时间
:--:|:-----:|:------:
P1|0|7
P2|2|4
P3|4|1
P4|5|4

根据先来先服务的思想，根据到达的顺序，得到调度顺序为：P1、P2、P3、P4。

所以P1在0到达，0+7=7完成。P2在2到达，而7时P1完成。所以P2要等待7-2=5，所以P2从7开始，在7+4=11完成。P3在4到达，所以需要等待11-4=7，从11开始，在11+1=12结束。P4在5到达，需要等待12-5-7，从12开始，在12+4=16结束。

进程|到达时间|运行时间|等待时间|开始时间|完成时间
:--:|:-----:|:------:|:-----:|:-----:|:------:
P1|0|7|0|0|7
P2|2|4|5|7|11
P3|4|1|7|11|12
P4|5|4|7|12|16

因为周转时间=完成时间-到达时间。所以P1=7-0=7，P2=11-2=9，P3=12-4=8，P4=16-5=11。

带权周转时间=周转时间/运行时间。所以P1=7/7=1，P2=9/4=2.25，P3=8/1=8，PR=11/4=2.75。

等待时间=周转时间-运行时间。根据表格可得。

所以平均周转时间=(7+9+8+11)/4=8.75。平均带权周转时间=(1+2.25+8+2.75)/4=3.5。平均等待时间=(0+5+7+7)/4=4.75。

#### 短作业优先

即
