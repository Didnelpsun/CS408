# 进程管理

## 进程与线程

### 进程的概念

+ 程序指一个指令序列。
+ 系统为每个运行的程序配置一个数据结构，称为**进程控制块PCB**，用来描述进程的各种信息，如程序代码存放位置。
+ PCB、程序段、数据段三个部分构成了进程实体（进程映像），简称为进程。
+ 创建进程就是创建PCB，销毁进程就是销毁PCB，PCB是进程存在的唯一标志。
+ 进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。

#### 进程的结构

+ 程序段：包括程序代码，程序运行时使用、产生的运算数据。如全局变量、局部变量、宏定义的常量。
+ 数据段：存放程序运行过程中处理的各种数据。
+ PCB：操作系统用PCB来管理进程，所以PCB包含所有管理进程所需的信息。
  + 进程描述信息：
    + 进程标识符PID。
    + 用户标识符UID。
  + 进程控制和管理信息：
    + 进程当前状态。
    + 进程优先级。
  + 资源分配清单：
    + 程序段指针。
    + 数据段指针。
    + 键盘。
    + 鼠标。
  + 处理机相关信息：
    + 各种寄存器值。

#### 进程的特征

+ 动态性：是进程最基本的特征，进程是程序的一次执行过程，是动态地产生、变化和消亡的。
+ 并发性：内存中有多个进程实体，各进程可并发执行。
+ 独立性：进程是资源分配、接受调度、能独立运行、独立获得资源、独立接受调度的基本单位。
+ 异步性：各进程按各自独立的、不可预知的速度向前推进，操作系统要提供“进程同步机制”来解决异步问题。
+ 结构性：每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成。

#### 进程的组织

当一个系统中存在多格PCB时，需要以适当的方式组织PCB。

+ 链接方式：
  + 按照进程状态将PCB分为多个队列。如执行指针（指针数为最大执行并行数）、就绪队列指针（一般会把优先级高的进程放在队头）、阻塞队列指针（许多操作系统会根据阻塞原因的不同将其分为多个阻塞队列）。
  + 操作系统持有指向各个队列的指针。
+ 索引方式：
  + 根据进程状态的不同建立索引表。如执行指针、就绪表指针、阻塞表指针。
  + 操作系统持有指向各个索引表的指针。

### 进程的状态

#### 基本进程状态

具有三种基本状态和其他两种状态：

+ 运行态：占有CPU并已经在CPU上运行。
+ 就绪态：已经具备运行条件，但是由于没有空闲CPU，导致暂时不能运行。
+ 阻塞态（等待态）：因等待某一事件而暂时不能运行，只有分配到位才能考虑分配CPU。
+ 创建态（新建态）：为进程分配所需的内存空间等系统资源，为其创建、初始化PCB。
+ 终止态（结束态）：进程运行结束或出现错误导致进程被撤销，操作系统需要回收进程资源，撤销PCB等工作，以防止内存泄漏。
+ 挂起态：暂时不能获得服务，进程映像调到外存等待（阻塞态的进程映像还在内存中等待）。分为：
  + 就绪挂起态。
  + 阻塞挂起态。

#### 进程状态的转换

+ 创建态到就绪态：系统完成创建进程等工作并准备好处理机等资源。
+ 就绪态到运行态：占有CPU资源，进程被调用。
+ 运行态到就绪态：时间片到或处理机（包含CPU和内存的一系列硬件）被抢占。
+ 运行态到阻塞态：进程主动用系统调用的方式申请某种系统资源，或请求等待某个事件发生。
+ 阻塞态到就绪态：申请的资源被分配或等待的事件发生。
+ 运行态到终止态：进程运行结束或运行过程中遇到不可修复的错误。
+ 就绪挂起态到就绪态：激活。
+ 就绪态到就绪挂起态：挂起。
+ 阻塞挂起态到阻塞态：激活。
+ 阻塞态到阻塞挂起态：挂起。
+ 阻塞挂起态到就绪挂起态：阻塞事件发生。
+ 运行态到就绪挂起态：运行中内存空间不足，或优先级更高的进程进入队列。
+ 创建态到就绪挂起态：创建后发现内存空间不足。

### 进程的控制

#### 进程控制的概念

+ 进程控制指对系统中的所有进程实施有效的管理，具有创建新进程、撤销已有进程、实现进程状态转换功能。
+ 如进程组织所说，通过将PCB指针放入各种状态的进程队列中转换进程状态来实现控制。
+ 进程控制由原语实现。
  + 特点是执行期间不能中断。
  + 这种不能中断的操作就是原子操作。
  + 原语采取“关中断指令”（不监听外部中断信息）和“开中断指令”（开始监听外部中断信息）实现。
  + 关/开中断指令的权限很大，所以必然是核心态下执行的特权指令。从而原语必然运行在核心态。

#### 进程控制的原语

+ 过程的创建：
  + 创建原语：
    + 申请空白PCB。
    + 为新进程分配所需资源。
    + 初始化PCB。
    + 将PCB插入就绪队列。
  + 引起进程创建的事件：
    + 用户登录：分时系统中，用户登录成功，系统会为其建立一个新进程。
    + 作业调度：多道批处理系统中，有新的作业进入内存时，会为其创建一个新进程。
    + 提供服务：用户向系统提出请求时，会创建一个新进程来处理请求。
    + 应用请求：由用户进程主动请求创建一个子进程。
+ 进程终止：
  + 撤销原语：
    + 从PCB集合中找到终止进程的PCB。
    + 若进程正在运行，则立刻剥夺其CPU交给其他进程。
    + 若是普通的终止，父进程终止时会将其子进程交给init进程收养。
    + 若是整个进程组的进程，则终止其所有子进程。
    + 将进程所有的资源交给父进程或操作系统。
    + 删除PCB。
  + 引起进程终止的事件：
    + 正常结束。
    + 异常结束。
    + 外界干预。
+ 进程阻塞：
  + 阻塞原语：
    + 找到要阻塞的进程对应的PCB。
    + 包含进程运行现场，将PCB状态信息设置为阻塞态，暂停进程。
    + 将PCB插入事件等待队列。
  + 引起进程阻塞的事件：
    + 需要等待系统分配资源。
    + 需要等待相互合作的其他进程完成工作。
+ 进程唤醒：
  + 唤醒原语：
    + 在事件等待队列中找到PCB。
    + 将PCB从等待队列中移除，设置进程为就绪态。
    + 将PCB插入就绪队列，等待被调度。
  + 引起进程唤醒的事件：
    + 等待的事件的发生（因何事被阻塞因何事被唤醒）。
+ 进程切换：
  + 切换原语：
    + 将运行环境信息存入PCB。
    + PCB移入相应队列。
    + 选择另一个进程执行，并更新其PCB。
    + 根据PCB恢复新进程所需的运行环境。
  + 引起进程切换的事件：
    + 当前时间片到。
    + 有更高优先级进程到达。
    + 当前进程主动阻塞。
    + 当前进程终止。

### 进程的通信

进程通信是进程之间的信息交换。

为了保证安全，一个进程不能直接访问另一个进程的地址空间。

+ 共享存储：分配一个可以共同使用的共享空间，进程对其的使用必须是互斥的。
  + 基于数据结构：共享空闲只能放固定的数据结构如数组等。速度慢，限制多，是低级通信方式。
  + 基于存储取：内存中划出一块共享存储区，数据的形式、存放位置都由进程控制而非操作系统。速度更快，限制少，是高级通信方式。
+ 管道通信：指用于链接读写进程的一个共享文件，又名pipe文件，其实就是内存中开辟一个大小固定的缓冲区。  
  + 只能使用半双工的通信，某一时间段内只能单向传输，若要双向同时通信则必须设置两个管道。
  + 进程需要互斥访问管道。
  + 数据以字符流的形式写入管道，当满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞。
  + 如果没有写满则不允许读，如果没有读空则不允许写。
  + 数据一旦被读出就被管道抛弃，所以读进程只能至多有一个，否则可能会读错。
+ 信息传递：进程间的数据交换以格式化的消息为单位。进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换。
  + 消息包括消息头和消息体，消息头包括：发送进程ID、接受进程ID、消息类型、消息长度等格式化的信息。
  + 消息传递包括：
    + 直接通信方式：消息直接挂到接受进程的信息缓冲队列上。
    + 间接通信方式：消息先发送到中间实体（信箱）中，因此也称为信箱通信方式，如计算机网络中的电子邮件系统。

### 线程

#### 线程的概念

传统而看，进程是程序的一次执行，但是程序的多个功能不能由一个程序顺序处理就能完成，所以一个进程需要同时进行多个任务，所以就引入了线程来增加并发度。

线程是基本的CPU执行单元，是程序执行流的最小单位。进程只作为除CPU之外的系统资源的分配单元，即打印机等都是分配给进程而不是线程。

#### 进入线程的变化

+ 系统分配调度：
  + 传统进程机制中，进程是资源分配、调度的基本单位。
  + 引入线程后，进程是资源分配的基本单位，线程是调度的基本单位。
+ 并发性：
  + 传统进程机制中，只能进程间并发。
  + 引入线程后，各线程间也能并发，提升了并发度。
+ 系统开销：
  + 传统的进程间并发，需要切换进程的运行环境，系统开销很大。
  + 线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小。
  + 引入线程后，并发所带来的系统开销减小。

#### 线程的属性

+ 线程是处理机调度的单位。
+ 多CPU计算机中，各个线程可占用不同的CPU。
+ 每个线程都有一个线程ID、线程控制块(TCB)。
+ 线程也有就绪、阻塞、运行三种基本状态。
+ 线程几乎不拥有系统资源。
+ 同一进程的不同线程间共享进程的资源。
+ 由于共享内存地址空间，同-进程中的线程间通信甚至无需系统干预。
+ 同一进程中的线程切换，不会引起进程切换。
+ 不同进程中的线程切换，会引起进程切换。
+ 切换同进程内的线程，系统开销很小。
+ 切换进程，系统开销较大。

#### 线程的实现

+ 用户级线程：
  + 用户级线程由应用程序通过线程库实现。所有的线程管理工作都由应用程序负责（包括线程切换）。
  + 用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。
  + 在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。用户级线程对用户不透明，对操作系统透明。
  + “ 用户级线程”就是“从用户视角看能看到的线程”。
+ 内核级线程（内核支持的线程）：
  + 内核级线程的管理工作由操作系统内核完成。
  + 线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。
  + “内核级线程” 就是“从操作系统内核视角看能看到的线程”。
  + 由于操作系统只能看见内核级线程，所以只有内核级线程才是处理机分配的单位。

#### 多线程模型

对于用户级线程映射到内核级线程的问题出现了“多线程模型”问题。

+ 多对一模型：
  + 多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。
  + 优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高。
  + 缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。
+ 一对一模型：
  + 一个用户及线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。
  + 优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。
  + 缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。
+ 多对多模型：
  + 在同时支持用户级线程和内核级线程的系统中，可以使用二者结合的方式，将$n$个用户级线程映射到$m$个内核级线程上（$n\geqslant m$）。
  + 克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。

## 处理机调度

### 处理机调度的概念

+ 处理机：包括中央处理器，主存储器，输入输出接口，加接外围设备就构成完整的计算机系统。处理机是处理计算机系统中存储程序和数据，并按照程序规定的步骤执行指令的部件。
+ 处理机调度：在多道程序设计系统中，内存中有多道程序运行，他们相互争夺处理机这一重要的资源。处理机调度就是从就绪队列中，按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程并发地执行。

### 处理机调度的层次

+ 高级调度（作业调度）：
  + 由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序。一般一个作业包含多个进程。
  + 高级调度按一定的原则从外存上处于后备队列的作业中挑选一个(或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB），以使它（们）获得竞争处理机的权利。
  + 高级调度是辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。
  + 高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。
+ 中级调度（内存调度）：
  + 引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。这么做的目的是为了提高内存利用率和系统吞吐量。
  + 暂时调到外存等待的进程状态为挂起状态。值得注意的是，PCB并不会一起调到外存，而是会常驻内存。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到的挂起队列中。
  + 中级调度就是要决定将哪个处于挂起状态的进程重新调入内存。
  + 一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。
+ 低级调度（进程调度)：
  + 其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。
  + 进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。
  + 进程调度的频率很高，一般几十毫秒一次。

&nbsp;|工作内容|发生位置|发生频率|对进程状态的影响
:----:|:------:|:-----:|:-----:|:-------------:
高级调度（作业调度）|按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程|外存→内存（面向作业）|一个作业一个调入一次调出|无→创建态→就绪态
中级调度（内存调度）|按照某种规则，从挂起队列中选择合适的进程将其数据调回内存|外存→内存（面向进程）|中等|挂起态→就绪态（阻塞挂起→阻塞态）
低级调度(进程调度）|按照某种规则，从就绪队列中选择一个进程为其分配处理机|内存→CPU|最高|就绪态→运行态

### 进程调度

进程调度是最低级的调度也是其他调度的基础。

#### 进程调度的时机

需要进行进程调度和切换：

+ 当前运行程序主动放弃处理机：
  + 进程正常终止。
  + 出现异常终止。
  + 进程主动请求阻塞（如等待IO）。
+ 当前运行程序被动放弃处理机：
  + 分配时间片用完。
  + 有更紧急的事件需要处理（如IO中断）。
  + 优先级更高进程进入就绪队列。

不能进行进程调度和切换：

+ 在处理中断的过程中。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换。
+ 进程在操作系统**内核程序临界区**中。
  + 临界资源:一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。
  + 临界区：访问临界资源的那段代码。
  + 内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列（由各就绪进程的PCB组成）。
  + 进程访问时会上锁，而如果还没退出临界区（还没解锁）就进行进程调度但是进程调度相关的程序也需要访问就绪队列，但此时就绪队列被锁住了，因此无法顺利进行进程调度。
  + 内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。因此在访问内核程序临界区期间不能进行调度与切换。
  + 而如果是普通程序临界区时，如在打印机打印完成之前，进程一直处于临界区内，临界资源不会解锁。但打印机又是慢速设备，此时如果一直不允许进程调度的话就会导致CPU一直空闲，所以为了保证效率进程在操作系统普通程序临界区时运行进程调度。
+ 在原子操作过程中（原语）。原子操作不可中断，要一气呵成（如修改PCB中进程状态标志，并把PCB放到相应队列）。

#### 进程调度的方式

针对操作系统是否可以剥夺进程处理机，进程调度方式分为：

+ 非剥夺调度方式，又称非抢占方式：
  + 只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。
  + 实现简单，系统开销小但是无法及时处理紧急任务。
  + 适合于早期的批处理系统。
+ 剥夺调度方式，又称抢占方式：
  + 当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。
  + 可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。
  + 适合于分时操作系统、实时操作系统。

#### 进程切换与过程

进程调度与进程切换的区别：

+ 狭义的进程调度指的是从就绪队列中选中一个要运行的进程。（这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换）。
+ 进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程。
+ 广义的进程调度包含了选择一个进程和进程切换两个步骤。

进程切换的过程主要完成了：

1. 对原来运行进程各种数据的保存
2. 对新的进程各种数据的恢复。
（如:程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）。

<span style="color:orange">注意：</span>进程切换是有代价的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。

### 调度算法

指作业与进程的调度算法。

+ 批处理系统算法：
  + FCFS。
  + SJF/SPF/SRTN。
  + HRRN。
+ 交互式系统算法：
  + RR。
  + PS。
  + MFQ。

#### 算法评价指标

+ CPU利用率：CPU忙碌时间占总时间的比例。其中利用率=忙碌时间/总时间。
+ 系统吞吐量：单位时间内完成作业的数量。系统吞吐量=总共完成多少道作业/总时间。
+ 周转时间：从作业被提交到系统开始到作业完成为止的时间间隔。
  + 它包括四个部分：作业在外存后备队列上等待作业调度（高级调度）的时间、进程在就绪队列上等待进程调度（低级调度）的时间、进程在CPU上执行的时间、进程等待I/O操作完成的时间。后三项在一个作业的整个处理过程中，可能发生多次。
  + （作业）周转时间=作业完成时间-作业提交时间。
  + 平均周转时间=各作业周转时间之和/作业数。
  + 带权周转时间=作业周转时间/作业实际运行的时间=(作业完成时间-作业提交时间)/作业实际运行的时间（≥1）。
  + 平均带权周转时间=各作业带权周转时间之和/作业数。
+ 等待时间：指进程或作业处于等待处理机状态时间之和。
  + 对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。
  + 对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。
  + 一个作业总共需要被CPU服务多久，被I/O设备服务多久一般是确定不变的，因此调度算法其实只会影响作业或进程的等待时间。当然，与前面指标类似，也有“平均等待时间”来评价整体性能。
  + 如果一个进程到达后要么等待要么运行，则等待时间=周转时间-运行时间。
  + 如果一个进程又有计算又有I/O操作，则等待时间=周转时间-运行时间-I/O操作时间。
+ 响应时间：从用户提交请求到首次产生响应所用的时间。

#### 先来先服务

即FCFS算法。

+ 算法思想：主要从“公平”的角度考虑。
+ 算法规则：按照作业/进程到达的先后顺序进行服务。
+ 用于作业/进程调度：用于作业调度时，考虑的是哪个作业先到达后备队列；用于进程调度时，考虑的是哪个进程先到达就绪队列。
+ 是否可抢占：非抢占式的算法。
+ 优缺点：
  + 优点:公平、算法实现简单。
  + 缺点:排在长作业(进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。即FCFS算法对长作业有利，对短作业不利。
+ 是否会导致饥饿：不会。

**例题：**各进程到达就绪队列的时间、需要的运行时间如下表所示。使用先来先服务调度算法，计算各进程的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周转时间。

进程|到达时间|运行时间
:--:|:-----:|:------:
P1|0|7
P2|2|4
P3|4|1
P4|5|4

根据先来先服务的思想，根据到达的顺序，得到调度顺序为：P1、P2、P3、P4。

所以P1在0到达，0+7=7完成。P2在2到达，而7时P1完成。所以P2要等待7-2=5，所以P2从7开始，在7+4=11完成。P3在4到达，所以需要等待11-4=7，从11开始，在11+1=12结束。P4在5到达，需要等待12-5-7，从12开始，在12+4=16结束。

进程|到达时间|运行时间|等待时间|开始时间|完成时间
:--:|:-----:|:------:|:-----:|:-----:|:------:
P1|0|7|0|0|7
P2|2|4|5|7|11
P3|4|1|7|11|12
P4|5|4|7|12|16

因为周转时间=完成时间-到达时间。所以P1=7-0=7，P2=11-2=9，P3=12-4=8，P4=16-5=11。

带权周转时间=周转时间/运行时间。所以P1=7/7=1，P2=9/4=2.25，P3=8/1=8，PR=11/4=2.75。

等待时间=周转时间-运行时间。根据表格可得。

所以平均周转时间=(7+9+8+11)/4=8.75。平均带权周转时间=(1+2.25+8+2.75)/4=3.5。平均等待时间=(0+5+7+7)/4=4.75。

#### 短作业优先

即SJF算法。

+ 算法思想：追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间。
+ 算法规则：最短的作业/进程优先得到服务（所谓“最短”，是指要求服务时间最短）。
+ 用于作业/进程调度：即可用于作业调度，也可用于进程调度。用于进程调度时称为“短进程优先(SPF, Shortest Process First）算法”。
+ 优缺点：
  + 优点：“最短的”平均等待时间、平均周转时间。
  + 缺点：不公平。对短作业有利，对长作业不利。可能产生饥饿现象。另外，作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先。
+ 是否可抢占：SJF和SPF是非抢占式的算法。但是也有抢占式的版本―——最短剩余时间优先算法（SRTN, Shortest Remaining Time Next）。
+ 是否会导致饥饿：会。如果源源不断地有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生“饥饿”现象
。如果一直得不到服务，则称为“饿死”

1．如果题目中未特别说明，所提到的“短作业/进程优先算法”默认是非抢占式的。2．很多书上都会说“SJF调度算法的平均等待时间、平均周转时间最少”，严格来说，这个表述是错误的，不严谨的。最短剩余时间优先算法得到的平均等待时间、平均周转时间还要更少。应该加上一个条件“在所有进程同时可运行时，采用SJF调度算法的平均等待时间、平均周转时间最少”，或者说“在所有进程都几乎同时到达时，采用SJF调度算法的平均等待时间、平均周转时间最少”。如果不加上述前提条件，则应该说“抢占式的短作业/进程优先调度算法（最短剩余时间优先, SRNT算法）的平均等待时间、平均周转时间最少”。
3．虽然严格来说，SJF的平均等待时间、平均周转时间并不一定最少，但相比于其他算法（如FCFS），SJF依然可以获得较少的平均等待时间、平均周转时间。
4．如果选择题中遇到“SJF算法的平均等待时间、平均周转时间最少”的选项，那最好判断其他选项是不是有很明显的错误，如果没有更合适的选项，那也应该选择该选项。

**例题：**各进程到达就绪队列的时间、需要的运行时间如下表所示。使用非抢占式短进程优先调度算法和抢占式短进程优先调度算法，分别计算各进程的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周转时间。

进程|到达时间|运行时间
:--:|:-----:|:------:
P1|0|7
P2|2|4
P3|4|1
P4|5|4

如果使用非抢占式的，因为每次选择当前已经到达且运行时间最短的作业/进程，因为P1第一个到达，所以第一个开始，P1完成时是7，P2P3P4都到达了，所以依次选最短运行时间的开始，所以调度顺序为P1、P3、P2、P4。

所以周转时间为7、4、10、11。带权周转时间为1、4、2.5、2.75。等待时间为0、3、6、7。平均周转时间为8。平均带权周转时间为2.56。平均等待时间为4。

如果使用抢占式的，若新到达进程剩余时间要比当前运行的进程剩余时间更短，则由新进程抢占处理机。

0时P1到达，P1剩余时间为7，所以P1开始运行。2时P2到达，此时P1剩余时间为7-2=5，而P2剩余时间为4-0=4，4<5，所以P2抢占P1处理机。4时P3到达，此时P2剩余时间为4-2=2，而P3剩余时间为1-0=1，所以P3又抢占P2处理机。到5时P4到达，此时P3正好运行完，所以要考虑P1P2P4三个的剩余时间，分别为5、2、4，所以P2抢占处理机运行。7时P2运行完，P4抢占处理机。11时P4运行完，P1抢占处理机。最后16时P1运行完，作业全部结束。

所以周转时间为16、5、1、6。带权周转时间为2.28、1.25、1、1.5。等待时间分别为9、1、0、2。平均周转时间为7。平均带权周转时间为1.5。平均等待时间为3。

#### 高响应比优先

即HRRN算法。

+ 算法思想：要综合考虑作业/进程的等待时间和要求服务的时间。
+ 算法规则：在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务。响应比=(等待时间+要求服务时间)/要求服务时间（响应比≥1）。
+ 用于作业/进程调度：即可用于作业调度，也可用于进程调度。
+ 是否可抢占：非抢占式的算法。因此只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比。
+ 优缺点：
  + 综合考虑了等待时间和运行时间（要求服务时间）。
  + 等待时间相同时，要求服务时间短的优先(SJF的优点）。
  + 要求服务时间相同时，等待时间长的优先（FCFS的优点）。
  + 对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题。
+ 是否会导致饥饿：不会。

**例题：**各进程到达就绪队列的时间、需要的运行时间如下表所示。使用高响应比优先调度算法，计算各进程的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周转时间。

进程|到达时间|运行时间
:--:|:-----:|:------:
P1|0|7
P2|2|4
P3|4|1
P4|5|4

需要利用公式计算响应比，最重要的是等待时间和运行时间。当0时P1到达，P1运行。7时P1完成主动放弃处理机，此时P2P3P4全部到达了，而响应比分别为(5+4)/4=2.25、(3+1)/1=3、(2+4)/4=1.5，所以选择P3上处理机运行。8时，响应比分别为2.5、1.75，P2运行。12时P4运行。

#### 时间片轮转

即RR算法。

+ 算法思想：公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应。
+ 算法规则：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。
+ 用于作业/进程调度：用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）。
+ 是否可抢占：若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知CPU时间片已到。
+ 优缺点：
  + 优点：
    + 公平。
    + 响应快，适用于分时操作系统。
  + 缺点：
    + 由于高频率的进程切换，因此有一定开销。
    + 不区分任务的紧急程度。
+ 是否会导致饥饿：不会。

+ 常用于分时操作系统，更注重响应时间，所以不怎么关系周转时间。
+ 如果时间片太大，每个进程在一个时间片内就可以完完成，则时间片轮转算法会退化为先来先服务算法，增大进程响应时间，所以时间片不能太大。
+ 如果时间片太小，进程切换会频繁发生，需要保存现场恢复环境，增加时间开销。
+ 一般设计时间片段时要让切换进程的开销不超过1%。

**例题：**各进程到达就绪队列的时间、需要的运行时间如下表所示。使用时间片轮转调度算法，分析时间片大小为2时的进程运行状态。

进程|到达时间|运行时间
:--:|:-----:|:------:
P1|0|7
P2|2|4
P3|4|1
P4|5|4

<span style="color:orange">注意：</span>当同一时刻既有时间片用完也有新进程到达时，默认新到达进程先进入队列，时间片用完的进程后进入。

若时间片为2：

当0时，因为只有P1到达就绪队列，所以P1运行一个时间片。

当2时，P1时间片运行完，余下5个时间。正好P2到达就绪队列，所以P1处理机被剥夺，重新放到就绪队列尾，让P2运行一个时间片。

当4时，P2时间片运行完，余下2个时间。正好P3到达就绪队列加入队尾，此时P1到达队头，所以P2处理机被剥夺，重新放到就绪队列尾，让P1运行一个时间片。

当5时，P4到达加入就绪队列。此时就绪队列上有P3、P2、P4。

当6时，P1时间片运行完，余下3个时间。此时P3到达队头，所以P1处理机被剥夺，重新放到就绪队尾，让P3运行。

当7时，虽然P3时间片没有用完，但是由于P3只需一个单位的时间，所以主动放弃处理机，发生调度，让P2运行一个时间片。

当9时，P2正好运行完也用完时间片，P4上处理机。

当11时，P4时间片用完，余下2个时间，此时P1到达队头，所以P4处理机被剥夺，重新放到就绪队尾，让P1运行。

当13时，P1时间片用完，余下1个时间，此时P4到达队头，所以P1处理机被剥夺，重新放到就绪队尾，让P4运行。

当15时，P4正好运行完也用完时间片，P4上处理机。

当16时，P1运行完，主动放弃处理机。

#### 优先级

即PS算法。

+ 算法思想：随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序。
+ 算法规则：调度时选择优先级最高的作业/进程。
+ 用于作业/进程调度：既可用于作业调度，也可用于进程调度。甚至，还会用于在之后会学习的I/O调度中。
+ 是否可抢占：抢占式、非抢占式都有。做题时的区别在于：
  + 非抢占式只需在进程主动放弃处理机时进行调度即可。
  + 抢占式还需在就绪队列变化时，检查是否会发生抢占。
+ 优缺点：
  + 优点：用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业/进程的偏好程度。
  + 缺点：若源源不断地有高优先级进程到来，则可能导致饥饿。
+ 是否会导致饥饿：会。

+ 优先数与优先级的关系要看具体情况，如Windows优先级与优先数成正比，UNIX中成反比。
+ 优先级调度算法中就绪队列未必只有一个，可以按照不同优先级来组织。
+ 可以把优先级更高的进程排在队头位置。
+ 根据优先级是否可以动态改变，分为：
  + 静态优先级：创建进程时确定，一直保持不变
  + 动态优先级：创建进程时有初始值，之后根据情况动态调整优先级。
+ 设置进程优先级：
  + 系统进程高于用户进程。
  + 前台进程高于后台进程。
  + 操作系统更偏好I/O型进程（I/O繁忙型进程）而不是计算型进程（CPU繁忙型进程），I/O设备和CPU可以并行工作。如果优先让I/O繁忙型进程优先运行的话，则越有可能让I/O设备尽早地投入工作，则资源利用率、系统吞吐量都会得到提升。
+ 调整动态优先级：
  + 若进程在就绪队列中等待了很长时间，则提升其优先级。
  + 若进程占用处理机很长时间，则降低其优先级。
  + 若进程频繁进行I/O操作，则提升其优先级。

**例题：**各进程到达就绪队列的时间、需要的运行时间、进程优先数如下表所示。使用非抢占式与抢占式优先级调度算法，分析进程运行状态。（优先级越大，优先级越高）

进程|到达时间|运行时间|优先数
:--:|:-----:|:------:|:---:
P1|0|7|1
P2|2|4|2
P3|4|1|3
P4|5|4|2

非抢占式：

0时只有P1到达，所以P1开始处理。

2时P2到达，4时P3到达，5时P4到达。

7时P1运行完，因为P3优先级更高，所以运行P3。

8时P3运行完，P2P4优先级相同，但是由于P2先到，所以P2上处理机。

12时P2运行完，P4上处理机。

16时P4运行完。

抢占式：

0时P1到达，P1上处理机。

2时P2到达，且P2优先级2大于P1优先级1，所以P2上处理机，P1余下5。

4时P3到达，且P3优先级3大于P2优先级2，所以P3上处理机，P2余下2。

5时P3运行结束，且P4到达，插入就绪队列队尾，P2进入队列时间更早，所以P2上处理机。

7时P2运行结束，且P4优先级4大于P1优先级1，所以P4上处理机。

11时P4运行结束，P1上处理机。

16时P1运行结束。

#### 多级反馈队列

即MFQ算法。

+ 算法思想：对其他调度算法的折中权衡。
+ 算法规则：
  1. 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大。
  2. 新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾如果此时已经是在最下级的队列，则重新放回该队列队尾。
  3. 只有第k级队列为空时，才会为k+1级队头的进程分配时间片
+ 用于作业/进程调度：用于进程调度。
+ 是否可抢占：抢占式的算法。在k级队列的进程运行过程中，若更上级的队列（1~k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾。
+ 优缺点：
  + 对各类型进程相对公平（FCFS的优点）。
  + 每个新到达的进程都可以很快就得到响应（RR的优点）。
  + 短进程只用较少的时间就可完成(SPF的优点）。
  + 不必实现估计进程的运行时间（避免用户作假）。
  + 可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程（拓展：可以将因I/O而阻塞的进程重新放回原队列，这样I/O型进程就可以保持较高优先级）
+ 是否会导致饥饿：会。

**例题：**各进程到达就绪队列的时间、需要的运行时间如下表所示。使用多级反馈队列调度算法，分析进程运行状态。

进程|到达时间|运行时间
:--:|:-----:|:------:
P1|0|7
P2|2|4
P3|4|1
P4|5|4

设置多级就绪队列，各级队列优先级从高到低，时间片从小到大。

新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片。

若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经在最下级的队列，则重新放回最下级队列队尾。

只有第k级队列为空时，才会为k+1级队头的进程分配时间片。

被抢占处理机的进程重新放回原队列队尾。

定义多级就绪队列如下（优先级与优先数成正比）：

队列序号|优先级|时间片大小
:-----:|:----:|:-------:
1|3|1
2|2|2
3|1|4

0时首先P1进入第一级队列，此时P1优先级为4，时间片为1，所以P1会运行1。

1时P1余下6，没有运行完，进入第二级队列的队尾。

2时P2进入第一级队列，优先级更高，所以P1被剥夺处理机，此时P1还余下5，回退第二级队列，P2开始运行。

3时P2运行一个时间片后余下3，加入第二级队列队尾。此时第二级队列头部为P1，所以P1开始运行。

4时P3进入第一级队列，优先级更高，所以P1被剥夺处理机，此时P1还余下4，回退第二级队列。

5时P4进入第一级队列，此时P3也正好运行完，处理机交给P4。

6时P4运行一个时间片后余下3，加入到第二级队列尾部。第二级队列此时顺序为P2（余3）、P1（余4）、P4（余3），所以P2开始运行。

8时P2运行一个时间片后余下1，加入到第三级队列中。P1开始占有处理机。

10时P1运行一个时间后余下2，加入到第三级队列中。P4开始占有处理机。

12时P4运行一个时间后余下1，加入到第三级队列中。第二级队列为空，开始运行第三级队列，P2开始占有处理机。

13时P2处理完，P1占有处理机。

15时P1处理完，P4占有处理机。

16时P4处理完，全部结束。

## 进程同步与互斥

### 进程同步与互斥的基本概念

#### 进程同步

+ 同步也称为直接制约关系。
+ 在多道程序环境下，进程是并发执行的，不同进程之间存在着不同的相互制约关系。为了协调进程之间的相互制约关系，如等待、传递信息等，引入了进程同步的概念。进程同步是为了解决进程的异步问题。
+ 异步性：进程具有异步性的特征。指各并发执行的进程以各自独立的、不可预知的速度向前推进。

#### 进程互斥

+ 互斥也称间接制约关系。
+ 进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。
+ 资源共享方式分为：
  + 互斥共享方式：允许多个进程使用，但是同一个时间段内只允许一个进程访问该资源。
  + 同时共享方式：允许一个时间短内由多个进程在宏观上同时对其访问。

#### 临界资源

+ 我们把一个时间段内只允许一个进程使用的资源称为临界资源。许多物理设备（比如摄像头、打印机）都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。
+ 对临界资源的访问，必须互斥地进行，从逻辑上分为四个部分：
  + 进入区：负责检查是否可进入临界区，若可进入则应设置**正在访问临界资源**的标志（上锁），以阻止其他进程同时进入临界区。
  + 临界区（临界段）：实际访问临界资源的代码。
  + 退出区：负责解除**正在访问临界资源**的标志（解锁）。
  + 剩余区：做其他处理。
  + 进入区和退出区是实现互斥的代码段。

#### 互斥访问的原则

1. 空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。
2. 忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待。
3. 有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）。
4. 让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。

### 进程互斥的软件实现

#### 单标志法

算法思想：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予。

```cpp
// turn表示当前允许进入临界区的进程号
int turn = 0;

// P0进程
while (turn != 1); // ①
critical section; // ②
turn = 1; // ③
remainder section; // ④

// P1进程
while(turn != 0); // ⑤
critical section; // ⑥
turn = 0; // ⑦
remainder section;// ⑧
```

优点：

+ turn的初值为0，即刚开始只允许0号进程进入临界区。
+ 若P1先上处理机运行，则会一直卡在⑤，无法使用临界资源。
+ 直到P1的时间片用完，发生调度，切换P0上处理机运行。
+ 而代码①不会卡住P0，P0可以正常访问临界区，在P0访问临界区期间即时切换回P1，P1依然会卡在⑤。
+ 只有P0在退出区将turn改为1后，P1才能进入临界区。
+ 因此，该算法可以实现同一时刻最多只允许一个进程访问临界。

缺点：

+ turn表示当前允许进入临界区的进程号，而只有当前允许进入临界区的进程在访问了临界区之后，才会修改turn的值。
+ 也就是说，对于临界区的访问，一定是按P0→P1→P0→P1→……这样轮流访问。
+ 如果P0进程一直不访问临界区，那么临界资源会被P0一直占用。
+ 违背了空闲让进的原则。

#### 双标志先检查法

算法思想：设置一个布尔型数组flag[\]，数组中各个元素用来标记各进程想进入临界区的意愿，比如`flag[0] = ture`意味着0号进程 P0现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志 flag[i]设为true，之后开始访问临界区。

```cpp
// 表示进入临界区意愿的数组
bool flag[2];
//刚开始设置为两个进程都不想进入临界区
flag [0] = false;
flag [1] = false;

// P0进程
while (flag[1]); // ①
flag[0] = true; // ②
critical section; // ③
flag [0] = false; // ④
remainder section;

// P1进程
while (flag[0]); // ⑤
flag[1] = true; // ⑥
critical section; // ⑦
flag[1] = false; // ⑧
remainder section;
```

若按照①⑤②⑥③⑦.….的顺序执行，P0和P1将会同时访问临界区。因此，双标志先检查法的主要问题是：违反忙则等待原则。

### 进程互斥的硬件实现

