# 指令系统

## 指令格式

指如何使用二进制代码表示指令。

### 指令定义

+ 指令（又称机器指令）：是指示计算机执行某种操作的命令，是计算机运行的最小功能单位。
+ 一台计算机的所有指令的集合构成该机的指令系统，也称为指令集。一台计算机只能执行自己指令系统中的指令，不能执行其他系统的指令。
+ 一条指令通常要包括操作码字段（OP）和地址码字段（A）两部分。
+ 操作码指出该指令要执行什么操作，地址码指出指令要操作的数据的地址。

### 指令字长

+ 固定：指令字长=存储字长。
+ 可变：按字节的倍数变化。
+ 指令字长取决于：
  1. 操作码长度。
  2. 操作数地址长度。
  3. 操作数地址个数。

### 地址码

+ 一条指令的执行分为三步，四次访存：
  1. 取指令。
  2. 取两个操作数。
  3. 取回结果。
+ 四地址指令：操作码+操作数1地址+操作数2地址+结果地址+下指令地址。
+ 三地址指令：操作码+操作数1地址+操作数2地址+结果地址。下一条指令的寻址靠程序计数器PC完成。一共访存四次。
+ 二地址指令：操作码+操作数1地址+操作数2地址。将结果存到操作数1地址或操作数2地址中。一共访存四次，若使用累加器ACC暂存结果则只用访存三次。
+ 一地址指令：操作码+操作数地址：
  + 只需要一个操作数的指令操作，如加一、减一、取反、求补等。只需要三次访存。
  + 隐含约定的目的地址为累加器ACC的地址。只需要两次访存。
+ 零地址指令：只有操作码：
  + 不需要操作数。如空操作、停机、关中断等。
  + 堆栈计算机，两个操作数隐含存放在栈顶和次栈顶，计算结果压回栈顶。
+ 用硬件资源减少地址码字段的优势：
  + 扩大指令寻址范围。
  + 缩短指令字长。
  + 减少访存次数。

### 操作码

#### 定长操作码

+ 指令字的最高位部分分配固定的若干位表示操作码。
+ 若有$n$位操作码，则有$2^n$条指令。
+ 优点：能简化计算机硬件设计，提高指令译码和识别速度。
+ 缺点：指令数量增加时会占用更多固定位，留给表示操作数地址的位数有限。
+ 一般这种操作码用于指令字长较长的情况。

#### 拓展操作码

+ 拓展操作码是变成操作码实现的一种，让操作码长度随地址码减少而增加。
+ 优点：在指令字长有限的前提下能保持比较丰富的指令种类。
+ 缺点：增加了指令译码和分析的难度，使控制器的设计复杂化。

+ 假设指令字长为16位，前4位为基本操作码字段OP，另有3个4位长的地址字段A1、A2和A3。4位基本操作码若全部用于三地址指令，则有16条。
+ 但至少须将1111留作扩展操作码之用，即三地址指今为15条。所以目前就留下来了前4位操作数为1111的指令，这是只有四位操作码。
+ 然后将留下来的指令的操作码位拓展为八位，将A1的位用作操作码，即将1111 0000 A2 A3到1111 1110 A2 A3作为二地址指令，二地址指也为15条。同样将1111 1111的指令作为下一个拓展操作码备用。
+ 同样将留下来的指令的操作码拓展为十二位，将A1A2的位用作操作码，即将1111 1111 0000 A3到1111 1111 1110 A3作为一地址指令，一地址指令也为15条。同样将1111 1111 1111的指令作为下一个拓展操作码备用。
+ 最后将操作码拓展为十六位，将A1A2A3全部作为操作码，即将1111 1111 1111 0000到1111 1111 1111 1111作为零地址指令，零地址指令为16条。
+ 在设计扩展操作码指令格式时，必须注意以下两点:
  1. 不允许短码是长码的前缀，即短操作码不能与长操个码的前面部分的代码相同，不然无法区分长码和短码。
  2. 各指令的操作码一定不能重复。
+ 通常情况下，对使用频率较高的指令，分配较短的操作码，对使用频率较低的指令，分配较长的操作码，从而尽可能减少指令译码和分析的时间。

**例题** 设指令字长固定为16位，试设计一套指令系统满足：

a)有15条三地址指令

b)有12条二地址指令

c)有62条一地址指令

d)有32条零地址指令

若要15条三地址码，而一共要从0到三位的地址，指令字长为16位。

所以三地址指令的操作码长度为4位，这样一共能得到0000 A1 A2 A3到1110 A1 A2 A3一共15条三地址指令。1111 A1 A2 A3用于拓展。

而对于二地址指令，一定是以1111开始的，由于只需要12条二地址指令，拓展A1作为操作码时，只用用到0000到1011就可以了，即而二地址指令从1111 0000 A2 A3到1111 1011 A2 A3。剩下的1100 1101 1110 1111都是以11开头，所以1111 11XX A2 A3用于拓展。

对于一地址指令，需要62条，而2的八次方减一为63，所以一地址指令的操作码至少还要拓展8位。最后的1111一定要留给下一位拓展，所以1111 1100到1111 1110的最后一个操作码范围是0000到1111全部用到，这样一共满足了3×16=48个，还需要14个，所以1111 1111只还要满足14个就可以了，即1111 1111 0000到1111 1111 1101，1111 1111 1110和1111 1111 1111留给零地址指令拓展。

而零地址指令必然以1111 1111 111开头，正好余下2+4=6位也就是32条零地址指令可以满足条件。

假设地址长度为$n$，长一层留出$m$中状态，则下一层可以拓展出$m\times2^n$种状态。

### 操作类型

1. 数据传输：
   1. LOAD：把存储器的数据放到寄存器中。
   2. STORE：把寄存器的数据放到存储器中。
2. 算术逻辑：
   1. 算术：加、减、乘、除、自加一、自减一、求补、浮点运算、十进制运算。
   2. 逻辑：与、或、非、异或、位操作、位测试、位清除、位求反。
3. 移位操作：
   1. 算术移位。
   2. 逻辑移位。
   3. 循环移位（带进位和不带进位）。
4. 转移操作：
   1. 无条件转移：JMP。
   2. 条件转移：JZ：结果为0；JO：结果溢出；JC：结果进位。
   3. 调用CALL和返回RETURN。
   4. 陷阱Trap和陷阱指令。（意外事故的中断）
5. 输入输出操作。

## 指令寻址

### 操作数类型与存放方式

#### 操作数类型

+ 地址：无符号整数。
+ 数字：定点数浮点数、十进制数。
+ 字符：ASCIl。
+ 逻辑数：逻辑运算。

#### 存放方式

+ 大端方式：字地址为高字节地址。如012345。
+ 小端方式：字地址为低字节地址。如452301。
+ 按字节地址寻址：给出个字节地址，可以取出长度为一个字节的数据。
+ 按字地址寻址：给出个字地址，可以取出长度为一个字的数据。
+ 按字节编址：每个字节存储单元都有一个地址编号。每个字中最小的字节地址就是字地址。
+ 按字编址：每个字存储单元都有一个地址编号。但是按字编址就无法直接取出字节地址。所以一般只按字节编址。
+ 三个字长：
  1. 机器字长：CPU一次能处理的二进制数据的位数。一般等于内部寄存器的位数。
  2. 指令字长：一个指令字中包含二进制代码的位数。若是单字长指令则指令字长等于机器字长，若是半字长指令等则不相等。
  3. 存储字长：一个存储单元存储二进制代码的长度。
+ 从任意位置开始存储：
  + 优点：不浪费存储资源。
  + 缺点：除了访问一个字节之外，访阿其它任何类型的数据，都可能花费两个存储周期的时间。读写控制比较复杂。


## 指令集计算机

