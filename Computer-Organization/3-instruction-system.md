# 指令系统

## 指令格式

指如何使用二进制代码表示指令。

### 指令定义

+ 指令（又称机器指令）：是指示计算机执行某种操作的命令，是计算机运行的最小功能单位。
+ 一台计算机的所有指令的集合构成该机的指令系统，也称为指令集。一台计算机只能执行自己指令系统中的指令，不能执行其他系统的指令。
+ 一条指令通常要包括操作码字段（OP）和地址码字段（A）两部分。
+ 操作码指出该指令要执行什么操作，地址码指出指令要操作的数据的地址。

### 指令字长

+ 固定：指令字长=存储字长。
+ 可变：按字节的倍数变化。
+ 指令字长取决于：
  1. 操作码长度。
  2. 操作数地址长度。
  3. 操作数地址个数。

### 地址码

+ 一条指令的执行分为三步，四次访存：
  1. 取指令。
  2. 取两个操作数。
  3. 取回结果。
+ 四地址指令：操作码+操作数1地址+操作数2地址+结果地址+下指令地址。
+ 三地址指令：操作码+操作数1地址+操作数2地址+结果地址。下一条指令的寻址靠程序计数器PC完成。一共访存四次。
+ 二地址指令：操作码+操作数1地址+操作数2地址。将结果存到操作数1地址或操作数2地址中。一共访存四次，若使用累加器ACC暂存结果则只用访存三次。
+ 一地址指令（单地址指令）：操作码+操作数地址：
  + 只需要一个操作数的指令操作，如加一、减一、取反、求补等。只需要三次访存。
  + 隐含约定的目的地址为累加器ACC的地址。只需要两次访存。
+ 零地址指令：只有操作码：
  + 不需要操作数。如空操作、停机、关中断等。
  + 堆栈计算机，两个操作数隐含存放在栈顶和次栈顶，计算结果压回栈顶。
+ 用硬件资源减少地址码字段的优势：
  + 扩大指令寻址范围。
  + 缩短指令字长。
  + 减少访存次数。

### 操作码

#### 定长操作码

+ 指令字的最高位部分分配固定的若干位表示操作码。
+ 若有$n$位操作码，则有$2^n$条指令。
+ 优点：能简化计算机硬件设计，提高指令译码和识别速度。
+ 缺点：指令数量增加时会占用更多固定位，留给表示操作数地址的位数有限。
+ 一般这种操作码用于指令字长较长的情况。

#### 拓展操作码

+ 拓展操作码是变成操作码实现的一种，让操作码长度随地址码减少而增加。
+ 优点：在指令字长有限的前提下能保持比较丰富的指令种类。
+ 缺点：增加了指令译码和分析的难度，使控制器的设计复杂化。

+ 假设指令字长为16位，前4位为基本操作码字段OP，另有3个4位长的地址字段A1、A2和A3。4位基本操作码若全部用于三地址指令，则有16条。
+ 但至少须将1111留作扩展操作码之用，即三地址指今为15条。所以目前就留下来了前4位操作数为1111的指令，这是只有四位操作码。
+ 然后将留下来的指令的操作码位拓展为八位，将A1的位用作操作码，即将1111 0000 A2 A3到1111 1110 A2 A3作为二地址指令，二地址指也为15条。同样将1111 1111的指令作为下一个拓展操作码备用。
+ 同样将留下来的指令的操作码拓展为十二位，将A1A2的位用作操作码，即将1111 1111 0000 A3到1111 1111 1110 A3作为一地址指令，一地址指令也为15条。同样将1111 1111 1111的指令作为下一个拓展操作码备用。
+ 最后将操作码拓展为十六位，将A1A2A3全部作为操作码，即将1111 1111 1111 0000到1111 1111 1111 1111作为零地址指令，零地址指令为16条。
+ 在设计扩展操作码指令格式时，必须注意以下两点:
  1. 不允许短码是长码的前缀，即短操作码不能与长操个码的前面部分的代码相同，不然无法区分长码和短码。
  2. 各指令的操作码一定不能重复。
+ 通常情况下，对使用频率较高的指令，分配较短的操作码，对使用频率较低的指令，分配较长的操作码，从而尽可能减少指令译码和分析的时间。

**例题** 设指令字长固定为16位，试设计一套指令系统满足：

a)有15条三地址指令

b)有12条二地址指令

c)有62条一地址指令

d)有32条零地址指令

若要15条三地址码，而一共要从0到三位的地址，指令字长为16位。

所以三地址指令的操作码长度为4位，这样一共能得到0000 A1 A2 A3到1110 A1 A2 A3一共15条三地址指令。1111 A1 A2 A3用于拓展。

而对于二地址指令，一定是以1111开始的，由于只需要12条二地址指令，拓展A1作为操作码时，只用用到0000到1011就可以了，即而二地址指令从1111 0000 A2 A3到1111 1011 A2 A3。剩下的1100 1101 1110 1111都是以11开头，所以1111 11XX A2 A3用于拓展。

对于一地址指令，需要62条，而2的八次方减一为63，所以一地址指令的操作码至少还要拓展8位。最后的1111一定要留给下一位拓展，所以1111 1100到1111 1110的最后一个操作码范围是0000到1111全部用到，这样一共满足了3×16=48个，还需要14个，所以1111 1111只还要满足14个就可以了，即1111 1111 0000到1111 1111 1101，1111 1111 1110和1111 1111 1111留给零地址指令拓展。

而零地址指令必然以1111 1111 111开头，正好余下2+4=6位也就是32条零地址指令可以满足条件。

假设地址长度为$n$，长一层留出$m$中状态，则下一层可以拓展出$m\times2^n$种状态。

### 操作类型

1. 数据传输：
   1. LOAD：把存储器的数据放到寄存器中。
   2. STORE：把寄存器的数据放到存储器中。
2. 算术逻辑：
   1. 算术：加、减、乘、除、自加一、自减一、求补、浮点运算、十进制运算。
   2. 逻辑：与、或、非、异或、位操作、位测试、位清除、位求反。
3. 移位操作：
   1. 算术移位。
   2. 逻辑移位。
   3. 循环移位（带进位和不带进位）。
4. 转移操作：
   1. 无条件转移：JMP。
   2. 条件转移：JZ：结果为0；JO：结果溢出；JC：结果进位。
   3. 调用CALL和返回RETURN。
   4. 陷阱Trap和陷阱指令。（意外事故的中断）
5. 输入输出操作。

## 指令寻址方式

### 操作数类型与存放方式

#### 操作数类型

+ 地址：无符号整数。
+ 数字：定点数浮点数、十进制数。
+ 字符：ASCIl。
+ 逻辑数：逻辑运算。

#### 存放方式

+ 大端方式：字地址为高字节地址。如012345。
+ 小端方式：字地址为低字节地址。如452301。
+ 按字节地址寻址：给出个字节地址，可以取出长度为一个字节的数据。
+ 按字地址寻址：给出个字地址，可以取出长度为一个字的数据。
+ 按字节编址：每个字节存储单元都有一个地址编号。每个字中最小的字节地址就是字地址。
+ 按字编址：每个字存储单元都有一个地址编号。但是按字编址就无法直接取出字节地址。所以一般只按字节编址。
+ 三个字长：
  1. 机器字长：CPU一次能处理的二进制数据的位数。一般等于内部寄存器的位数。
  2. 指令字长：一个指令字中包含二进制代码的位数。若是单字长指令则指令字长等于机器字长，若是半字长指令等则不相等。
  3. 存储字长：一个存储单元存储二进制代码的长度。
+ 从任意位置开始存储：
  + 优点：不浪费存储资源。
  + 缺点：除了访问一个字节之外，访阿其它任何类型的数据，都可能花费两个存储周期的时间。读写控制比较复杂。
+ 从一个存储字的起始位置开始访问，其余位置置空或填充：
  + 优点：无论访问何种类型的数据，在一个周期内均可完成，读写控制简单。
  + 缺点：浪费了宝贵的存储资源。
+ 边界对准方式，从地址的整数倍位置开始访问：
  + 由于不同的机器数据字长不同，每台机器处理的数据字长也不统一，为了便于硬件实现，通常要求多字节的数据在存储器的存放方式能满足“边界对准”的要求。
  + 数据存放的起始地址是数据长度（按照编址单位进行计算）的整数倍。
  + 本方案是前两个方案的折衷，在一个周期内可以完成存储访问，空间浪费也不太严重。

### 指令寻址

用于确定要执行的下一条指令的地址。始终由程序计数器PC给出。

+ 顺序寻址：由PC自动加上某个数寻址下一个要操作的指令。
+ 跳跃寻址：由转移指令指出。如执行到操作码为JMP，则跳跃到保存的地址码所指向的指令地址进行执行。

### 数据寻址

+ 用于确定本条指令的数据地址。
+ 具体的数据寻址分为：
  + 主存寻址：数据都存储在主存中
    + 隐含寻址。
    + 立即寻址。
    + 直接寻址。
    + 间接寻址。
  + 寄存器寻址：数据都存储在寄存器中
    + 寄存器寻址。
    + 寄存器间接寻址。
  + 偏移寻址：都需要加一个偏移量
    + 相对寻址。
    + 基址寻址。
    + 变址寻址。
  + 堆栈寻址。
  
+ 此时指令就需要由：操作码OP+寻址地址（寻址方式）+形式地址A组成。形式地址不再是实际的地址，而是指令字中的地址。
+ 有效地址EA就是通过寻址特征和形式地址进行运算得到的。
+ 无论是有多少个地址，都必须给出成对的寻址特征和形式地址。

#### 隐含寻址

+ 不是明显地给出操作数的地址，而是在指令中隐含着操作数的地址。
+ 如单地址指令，隐含约定另一个操作数的目的地址为累加器ACC的地址。
+ 优点：有利于缩短指令字长。
+ 缺点：需增加存储操作数或隐含地址的硬件。

#### 立即寻址

+ 形式地址不是地址（称为立即数），直接采用补码形式存储操作数本身。
+ 地址形式为：操作码OP+#+立即数。#即表示立即寻址特征。
+ 立即寻址的指令执行：
  1. 取指令，访存1次。
  2. 执行指令，直接取指令操作数，访存0次。
  3. 暂不考虑如何存结果。
  4. 共访存1次。
+ 优点：指令执行阶段不访问主存，指令执行时间最短。
+ 缺点：
  + 形式地址A的位数限制了立即数的范围。
  + 如A的位数为$n$，且立即数采用补码时，可表示的数据范围为$[-2^{n-1},2^{n-1}-1]$。

#### 直接寻址

+ 指令字中的形式地址A就是操作数的真实地址EA，即EA=A。
+ 直接寻址的指令执行：
  1. 取指令，访存1次。
  2. 执行指令，取操作数，访存1次。
  3. 暂不考虑如何存结果。
  4. 共访存2次。
+ 优点：简单，指令执行阶段仅访问一次主存，不需专门计算操作数的地址。
+ 缺点：
  + 形式地址A的位数决定了该指令操作数的寻址范围。
  + 操作数的地址不易修改。

#### 间接寻址

+ 指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数有效地址所在的存储单元的地址，也就是操作数地址的地址，即EA=(A)。
+ 间接寻址的指令执行：
  1. 取指令，访存1次。
  2. 执行指令，取操作数地址，取操作数，访存2次。
  3. 暂不考虑如何存结果。
  4. 共访存3次。
+ 若间址次数为n，则访问时间为n+2。
+ 优点：
  + 可扩大寻址范围（有效地址EA的位数大于形式地址A的位数）。
  + 便于编制程序（用间接寻址可以方便地完成子程序返回）。
+ 缺点：指令在执行阶段要多次访存（一次间址需两次访存，多次寻址需根据存储字的最高位确定几次访存）。

#### 寄存器寻址

+ 在指令字中直接给出操作数所在的寄存器编号，即EA=Ri，其操作数在由Ri所指的寄存器内。
+ 类似于直接寻址，只是数据在主存中变为在寄存器中。寄存器编号就是形式地址。
+ 寄存器寻址的指令执行：
  1. 取指令，访存1次。
  2. 执行指令，由于操作数在寄存器中，寄存器集成在CPU中，所以不需要访问主存，访存0次。
  3. 暂不考虑如何存结果。
  4. 共访存1次。
+ 优点：
  + 指令在执行阶段不访问主存，只访问寄存器，指令字短且执行速度快。
  + 支持向量/矩阵运算。
+ 缺点：
  + 寄存器价格昂贵。
  + 计算机中寄存器个数有限。

#### 寄存器间接寻址

+ 寄存器Ri中给出的不是一个操作数，而是操作数所在主存单元的地址，即EA=(Ri)。
+ 寄存器间接寻址的指令执行：
  1. 取指令，访存1次。
  2. 执行指令，先访问寄存器获得地址，再根据地址在主存中访问，访存1次。
  3. 暂不考虑如何存结果。
  4. 共访存2次。
+ 优点：与一般间接寻址相比速度更快。
+ 缺点：指令的执行阶段需要访问主存（因为操作数在主存中）。

#### 基址寻址

+ 将CPU中基址寄存器（BR）的内容加上指令格式中的形式地址A,而形成操作数的有效地址，即EA=(BR)+A。
+ 分为隐式基址寄存器（专用寄存器BR）和显式基址寄存器（需要指定某通用寄存器为基址寄存器）。
+ 基址寄存器是面向操作系统的，其内容由操作系统或管理程序确定，用户不可改变。在程序执行过程中，基址寄存器的内容不变（作为基地址)，形式地址可变（作为偏移量）。
+ 当采用通用寄存器作为基址寄存器时，可由用户决定哪个寄存器作为基址寄存器，但其内容仍由操作系统确定。
+ 优点：
  + 可扩大寻址范围（基址寄存器的位数大于形式地址A的位数）。
  + 用户不必考虑自己的程序存于主存的哪一空间区域，故有利于多道程序设计，以及可用于编制浮动程序。

#### 变址寻址

+ 有效地址EA等于指令字中的形式地址A与变址寄存器IX的内容相加之和，即EA=(IX)+A。
+ 其中IX为变址寄存器（专用），也可用通用寄存器作为变址寄存器。
+ 与基址寄存器不同的是，变址寄存器是面向用户的，在程序执行过程中，变址寄存器的内容可由用户改变（作为偏移量），形式地址A不变（作为基地址）。
+ 优点：
  + 可扩大寻址范围（变址寄存器的位数大于形式地址A的位数）。
  + 在数组处理过程中，可设定A为数组的首地址，不断改变变址寄存器IX的内容，便可很容易形成数组中任一数据的地址，特别适合编制循环程序。
+ 变址寻址与基址寻址配合使用：EA=A+(BR)+(IX)。
+ 变址寻址与间接寻址配合使用：
  + 先变址后间址，EA=(A+(IX))。
  + 先间址后变址，EA=(A)+(IX)。

#### 相对寻址

+ 把程序计数器PC的内容加上指令格式中的形式地址A而形成操作数的有效地址，即EA=(PC)+A，其中A是相对于当前指令地址的位移量，可正可负，补码表示。
+ 优点：
  + 操作数的地址不是固定的，它随着PC值的变化而变化，并且与指令地址之间总是相差一个固定值，因此便于程序浮动。
  + 相对寻址广泛应用于转移指令。

**例题** 某机器指令字长为16位，主存按字节编址，取指令时，每取一个字节PC自动加1。当前指令地址为2000H，指令内容为相对寻址的无条件转移指令，指令中第一个字节为操作码，第二个字节为形式地址，当前形式地址为40H。

(1)求取指令后及指令执行后PC内容。

PC指向当前指令地址2000H，因为第一个字节为操作码，所以PC指向2001H，第二个字节为形式地址，PC指向2002H。由于形式地址为40H，所以实际地址EA=(PC)+A=2002H+40H=2042H。

执行指令后跳转到所指向的地址2042H。

(2)若要求转移到1F0OH，求形式地址的内容。

即(PC)+A=2002H+A=1F00H。即=1EFFH+1H-2002H=FEFDH+1H=FEFEH。

#### 堆栈寻址

+ 操作数存放在堆栈中，隐含使用堆栈指针（SP）作为操作数地址。
+ 堆栈是存储器（或专用寄存器组）中一块特定的按“后进先出（LIFO）”原则管理的存储区，该存储区中被读/写单元的地址是用一个特定的寄存器给出的,该寄存器称为堆栈指针（SP）。
+ 寄存器做堆栈就是硬堆栈，主存做堆栈就是软堆栈。

## 指令集计算机

### 复杂指令集计算机

+ 即Complex Instruction Set Computer，CISC。
+ 一条指令完成一个复杂的基本功能。
+ 代表：x86架构，主要用于笔记本和台式机。
+ 80-20规律：典型程序中80%的语句仅仅使用处理机20%的指令。

### 精简指令集计算机

+ 即Reduced Innstruction Set Computer，RISC。
+ 一条指令完成一个基本动作，多条指令组合完成一个复杂的基本功能。
+ 代表：ARM架构，主要用于手机和平板。

对比项目\类别|CISC|RISC
:----------:|:---:|:--:
指令系统|复杂，庞大|简单，精简
指令数目|一般大于200条|一般小于100条
指令字长|不固定|定长
可访存指令|不加限制|只有Load/Store指令
各种指令执行时间|相差较大|绝大多数在一个周期内完成
各种指令使用频度|相差很大|大都比较常用
通用寄存器数量|较少|多
目标代码|难以用优化编译生成高效的目标代码程序|采用优化的编译程序，生成代码较为高效
控制方式|绝大多数为微程序控制|多课绝大多数为组合逻辑控制
指令流水线|可以通过一定方式实现|必须实现
