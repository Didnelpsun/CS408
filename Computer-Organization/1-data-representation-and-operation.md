# 数据表示与运算

## 数制与编码

### 进位计数制

+ 真值：符合人类习惯的数字。
+ 机器数：数字实际存到机器里的形式，正负号需要被“数字化”。

#### 十进制

+ 符号反映权重。
+ 符号所在位置也反映权重。
+ $K_nK_{n-1}\cdots K_2K_1K_0K_{-1}K_{-2}\cdots K_{-m}=K_n\times10^n+K_{n-1}\times10^{n-1}\cdots K_2\times10^2+K_1\times10^1+K_0\times10^0+K_{-1}\times10^{-1}+K_{-2}\times10^{-2}\cdots K_{-m}\times10^{-m}$。

#### R进制

+ 基数：每个数码位所用到的不同符号的个数，r进制的基数r。
+ R进制转换为十进制：$K_nK_{n-1}\cdots K_2K_1K_0K_{-1}K_{-2}\cdots K_{-m}=K_n\times r^n+K_{n-1}\times r^{n-1}\cdots K_2\times r^2+K_1\times r^1+K_0\times r^0+K_{-1}\times r^{-1}+K_{-2}\times r^{-2}\cdots K_{-m}\times r^{-m}=\sum_{i=-m}^nK_i\times r^i$。
+ 二进制：0、1。
+ 使用二进制的原因：
  1. 可使用两个稳定状态的物理器件表示。
  2. 0，1正好对应逻辑值假、真。方便实现逻辑运算。
  3. 可很方便地使用逻辑门电路实现算术运算。
+ 八进制：0、1、2、3、4、5、6、7。可以用下标方式表明，也可以用结束的O或开头的0表示。如$(1643)_8$、01643、1643O。
+ 十进制：0、1、2、3、4、5、6、7、8、9。可以用下标方式表明，也可以用结束的D表示，如$(1643)_{10}$、1643D。
+ 十六进制：0、1、2、3、4、5、6、7、8、9、A、B、C、D、E、F。可以用下标方式表明，也可以用结束的H或开头的0x表示。如$(1643)_{16}$、0x1643、1643H。

#### 二进制与八进制或十六进制转换

+ 二进制转换八进制：三位一组，每组转换成对应的八进制符号，整数部分不全则最高位用0填充，小数部分不全则最低位用0填充。
+ 二进制转换十六进制：四位一组，每组转换成对应的十六进制符号，整数部分不全则最高位用0填充，小数部分不全则最低位用0填充。
+ 八进制转换二进制：每位八进制对应的三位二进制。
+ 十六进制转换二进制：每位十六进制对应的四位二进制。

十进制|二进制|八进制|十六进制
:---:|:----:|:----:|:-----:
0|0000|0|0
1|0001|1|1
2|0010|2|2
3|0011|3|3
4|0100|4|4
5|0101|5|5
6|0110|6|6
7|0111|7|7
8|1000|10|8
9|1001|11|9
10|1010|12|A
11|1011|13|B
12|1100|14|C
13|1101|15|D
14|1110|16|E
15|1111|17|F

#### 十进制转换为R进制

+ 整数部分需要使用除基取余法，小数部分需要使用乘基取整法。
+ 对于十进制数，需要把它分为整数部分和小数部分两个部分进行处理。
+ 已知R进制转换为十进制的方法：$K=K_nK_{n-1}\cdots K_2K_1K_0K_{-1}K_{-2}\cdots K_{-m}=K_n\times r^n+K_{n-1}\times r^{n-1}\cdots K_2\times r^2+K_1\times r^1+K_0\times r^0+K_{-1}\times r^{-1}+K_{-2}\times r^{-2}\cdots K_{-m}\times r^{-m}$。
+ 分为整数部分和小数部分：$K=N+F$。
+ 首先把整数拿出来得到$N=K_n\times r^n+K_{n-1}\times r^{n-1}\cdots K_2\times r^2+K_1\times r^1+K_0\times r^0$。
+ 对这个数除以基数$r$，得到$X=K_n\times r^{n-1}+K_{n-1}\times r^{n-2}\cdots K_2\times r^1+K_1\times r^0$，这时候就会得到一个余数$K_0$。所以$N=rX+K_0$，这时候就能算出$K_0$这个位数了。
+ 同理再将得到的商$X$同样除以$r$，就能得到$K_1$，所以不断递归就会得到整数部分所有的$K_i$。
+ 得到的$K_i$是从低位排到高位。
+ 对于小数部分$F=K_{-1}\times r^{-1}+K_{-2}\times r^{-2}\cdots K_{-m}\times r^{-m}$。
+ 对这个数乘基数$r$，得到$K_{-1}\times r^0+K_{-2}\times r^{-1}\cdots K_{-m}\times r^{-m+1}$，取这个常数$K_{-1}$就是想要的答案。将乘积减去这个整数部分得到后面处理的数据
+ 同理再将得到的数据不断乘基数，就能得到小数部分所有的$K_i$。
+ 得到的$K_i$是从高位排到低位。
+ 将整数和小数合在一起就是最后的结果。
+ 有时候小数会出现无法彻底转换的情况，需要考虑保留多少位。

**例题** 将十进制的75.3转换为二进制并保留三位。

首先将75拿出来，以基数2相除：

75÷2=37……1，37÷2=18……1，18÷2=9……0，9÷2=4……1，4÷2=2……0，2÷2=1……0，1÷2=0……1，这个顺序是从低位到高位的，所以75转换二进制就是1001011。

然后是对小数0.3的处理：

0.3×2=0.6=0+0.6，0.6×2=1.2=1+0.2，0.2×2=0.4=0+0.4，这个顺序是从高位到低位的，所以0.3转换二进制就是0.01。

所以转换最后得到1001011.01。

同理也可以使用拼凑法将数字拼凑成对应的数值。这种方法对于只有整数的数值比较好用。

$2^{12}$|$2^{11}$|$2^{10}$|$2^{9}$|$2^{8}$|$2^{7}$|$2^{6}$|$2^{5}$|$2^{4}$|$2^{3}$|$2^{2}$|$2^{1}$|$2^{0}$|$2^{-1}$|$2^{-2}$|$2^{-3}$
:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:
4096|2048|1024|512|256|128|64|32|16|8|4|2|1|0.5|0.25|0.125

### BCD码

即Binary-Coded Decimal，用二进制编码的十进制。

使用4bit来表示0到9这十个数，而4bit能表示十六个数，所以会冗余六个组合。

#### 8421码

8421码是一种有权码，第1、2、3、4位分别对应8、4、2、1，使用常规的二进制来表示十进制：

0|1|2|3|4|5|6|7|8|9
:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:
0000|0001|0010|0011|0100|0101|0110|0111|1000|1001

如985用8421码表示就是1001 1000 0101。

使用8421码表示的数字进行算术运算的方式是先按照二进制的方式进行运算，若最后结果不在映射表中，即落在没有定义的1010到1111中，就直接加上6（因为有六位无效，所以加上六位跳过无效的位数）从而进一位，多了一段补全0。每个段对应的数值合在一起就是原来的结果。

如5+8=0101+1000=1101=13，不在映射表中，则对1101加6，即计算19，得到1 0011这个值，补齐得到0001 0011，而按照8421码，最高位的0001不再代表权值16，而代表十位的1，而后面是3，从而组合在一起就代表了13。

#### 余三码

在8421码的基础上全部加上三：

0|1|2|3|4|5|6|7|8|9
:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:
0011|0100|0101|0110|0111|1000|1001|1010|1011|1100

余三码因为加上了三，所以每一位的权值映射关系就破坏了，所以这是一种无权码，不能分别对应8、4、2、1的值。

#### 2421码

与8421码一样都是一种有权码，但是映射的方式不同，第1、2、3、4位分别对应2、4、2、1。

0|1|2|3|4|5|6|7|8|9
:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:
0000|0001|0010|0011|0100|1011|1100|1101|1110|1111

### 字符与字符串

#### 英文字符表示

ASCII码，数字英文符号一共128个字符，使用7位就可以表示128个字符，但是通常会高位补0凑足1B：

+ 其中32到126是可印刷字符，其他都是控制或通信字符。
+ 数字：48（0011 0000）到57（0011 1001），后面4位就是数字的8421码。
+ 大写字母：65（0100 0001）到90（0101 1010），前面三位是010，后面五位代表1到26。
+ 小写字母：97（0110 0001）到122（0111 1010），前面三位是011，后面五位代表1到26。

#### 中文字符表示

+ GB 2312-80：1980年推出汉字加符号共7445个表示的字符。中文有两个字节。
  + 区位码：94个区，每个区94位。
  + 国标码：为了中文字符表示与英文字符表示共存，防止GB编码被认为是ASCII码的0到32位的控制或通信字符，所以在94区94位的基础上还要各自加上32，即20H，防止信息交换时冲突。
  + 汉字内码：国标码只能用于信息传输，而如果是存储在计算机上，由于前128位已经被ASCII码占用了，所以在国标码的基础上再各自加80H（128），从而计算机识别字符时，看到0到128之间的就能辨认出是ASCII码，大于128的就是GB码。因为ASCII码高位是0，而GB码是两个字节且高位都是1。
+ 输入编码：如拼音、五笔等供人类输入，输入编码输入后转换为国标码再转成汉字内码存储。
+ 汉字字形码：把汉字输出成汉字的样子。

#### 字符串

+ 若一个计算机按字节编址，则每个地址对应Q1B。
+ 很多语言中将'\0'即00H作为字符串结束标志。
+ 大端模式：将数据的最高有效字节存放在低地址单元中。
+ 小端模式：将数据的最高有效字节存放在高地址单元中

### 数据校验

现在计算机组成原理不考数据校验，但是只是内容移动到计算机网络里。具体可以看计算机网络。

+ 校验原理就是将更多字节映射到有限个合法状态，从而有多个冗余的非法状态，更容易判断是否非法。
+ 码字：由若干位代码组成的一个字。
+ 两个码字间的距离：将两个码字逐位进行对比，具有不同的位的个数。
+ 码距：一种编码方案可能有若干个合法码字，各合法码字间的最小距离。
+ 当码距=1时，无检错能力；当码距=2时，有检错能力；当码距≥3时，若设计合理，可能具有检错、纠错能力。

#### 奇偶校验码

+ 奇校验码：整个校验码（有效信息位和校验位）中为1的个数为奇数。
+ 偶校验码：整个校验码（有效信息位和校验位）中为1的个数为偶数。
+ 偶位数出错时无法校验。
+ 对原始数据进行异或（模2加）运算，得到的结果即为校验位。
+ 对所有数据进行异或运算，结果为0表示未出错，为1代表出错。
+ 码距为2，只能检错，不能纠错。

#### 海明码

+ 将信息分组进行偶校验，从而得到多个校验位，从而能携带多种状态信息。
+ 设信息位为$n$，校验位为$k$，从而能表达$2^k$中状态，而信息位+校验位一共$n+k$位，只错一位的状态种数加上一种正确状态为$n+k+1$，从而$2^k\geqslant n+k+1$。
+ 令信息位为$D_i$，校验位为$P_j$，总海明码为$H_k$，其中校验位$P_j$必须放在海明码$H_k$位号位$2^{j-1}$的位置上，即1、2、4、8等。
+ 如果没有发生错误，则每一位进行检错都是0，若出现1，则说明出错。
+ 为了检测是一位错还是两位错，一般会加上一个全校验位，对整体进行偶校验。
+ 具有一位和两位的纠错检错能力，三位以上则不能纠错。

n|1|2-4|5-11|12-26|27-57|58-120
:-:|:-:|:-:|:-:|:-:|:--:|:----:
k|2|3|4|5|6|7

#### 循环冗余校验码

+ 即CRC码，其思想是：
  1. 数据发送、接受方约定一个“除数”。
  2. K个信息位+R个校验位作为“被除数”，添加校验位后需保证除法的余数为0。
  3. 收到数据后，进行除法检查余数是否为0。
+ 得到CRC码的方法：
  1. 确定K和R以及生成多项式对应的二进制码。其中R位生成多项式的最高次幂数。
  2. 将信息码左移R位，低位补0。
  3. 使用模二除法。
  4. 余数就是校验位，只比多项式少一位。
  5. 对全部数据进行多项式除，余数为0代表无措。
  6. 若余数不为0，则出错。
  7. 若$n$个信息位，$k$个校验位，若生成多项式得当，且$2^k\geqslant n+k+1$，则CRC码可纠正一位错。实际上基本上不怎么用来纠错。

## 定点数

指小数点的位置不变，使用常规计数法，如96.94。

### 定点数表示

#### 无符号数

+ 整个机器字长的全部二进制位均为数值位，没有符号位，相当于数的绝对值。
+ $n$位无符号数表示范围为$[0,2^n-1]$。
+ 无符号数不涉及小数。

#### 有符号数

+ 定点整数：最高一位是符号位，0是正，1是负，小数点位置一般隐含在最后。
+ 定点小数：最高一位是符号位，0是正，1是负，小数点位置隐含在符号位后面。
+ 数值部分也称为尾数。要保存一个非整数需要保存定点整数与定点小数两个部分。

#### 原码

+ 原码：用尾数表示真值的绝对值，符号位“0/1”对应“正/负”。
+ 若机器字长为n+1位，则尾数占n位。
+ 若使用1B来保存数值，则+19D就是0001 0011，-19D就是1001 0011。
+ 有时1001 0011会写为1,0010011，其中的逗号只是为了标注正负号，本身是不存在的。
+ 若未指明机器字长，则最开头的多个0可以省略。如1001 0011可以表示为1,10011。
+ 同理小数也可以使用1.11表示，这是指-0.11。
+ 若机器字长$n+1$位，则原码整数的表示范围是$[-(2^n-1),2^n-1]$。
+ 若机器字长$n+1$位，则原码小数的表示范围是$[-(1-2^{-n}),1-2^{-n}]$。
+ 原码表示时真值0有+0和-0两种形式。

#### 反码

+ 反码：若符号位为0，则反码与原码相同，若符号位为1，则数值位全部取反。
+ 可以转换为原码再取反。
+ 若机器字长$n+1$位，则反码整数的表示范围是$[-(2^n-1),2^n-1]$。
+ 若机器字长$n+1$位，则反码小数的表示范围是$[-(1-2^{-n}),1-2^{-n}]$。
+ 反码表示时真值0有+0和-0两种形式。
+ 反码只是由原码转换为补码的一个中间态，实际上并没有作用。

#### 补码

+ 补码：若符号位为0，则反码与原码相同，若符号位为1，则数值位全部取反再加一，即反码加一。
+ 补码表示时真值0只有一种形式0000 0000。
+ 多出来的一种形式1000 0000表示$-2^7$和$-1$。
+ 若机器字长$n+1$位，则补码整数的表示范围是$[-2^n,2^n-1]$。
+ 若机器字长$n+1$位，则补码小数的表示范围是$[-1,1-2^{-n}]$。
+ 将负数补码转回原码的方法相同：尾数取反，末位加一。补码的补码就是原码。
+ 如果已知一个数值的补码，那么求这个值的负数的补码就是全部位取反，末位加一。
+ 如果已知一个负数的补码，那个求这个值的原码就是数值位取反再加一，或是负数补码中，最右边的1以及右边不变，最右边的1的左边取反。

#### 移码

+ 补码的基础上将符号位取反。
+ 移码只能用于表示整数，而不能表示定点小数。
+ 若机器字长$n+1$位，则移码整数的表示范围是$[-2^n,2^n-1]$。
+ 若机器字长$n+1$位，则移码小数的表示范围是$[-1,1-2^{-n}]$。
+ 移码由于负数的最高位为0，正数的最高位为1，从而能更方便对比大小。

机器数|无符号数|原码|反码|补码|移码
:----:|:------:|:--:|:--:|:--:|:--:
0000 0000|0|+0|+0|0|-128
0000 0001|1|+1|+1|+1|-127
...
0111 1101|125|+125|+125|+125|-3
0111 1110|126|+126|+126|+126|-2
0111 1111|127|+127|+127|+127|-1
1000 0000|128|-0|-127|-128|0
1000 0001|129|-1|-126|-127|1
1000 0010|130|-2|-125|-126|2
...
1111 1101|253|-125|-2|-3|125
1111 1110|254|-126|-1|-2|126
1111 1111|255|-127|-0|-1|127

#### 补码作用

+ 原码在计算时由于首位表示的是符号，所以需要考虑将加减运算转换的问题，而减法实现起来比较困难，就考虑是否可以将减法通过加法来实现。
+ 由于计算机码操作若最高位进一就被舍弃，则天然是进行模运算，所以可以通过数学模运算来实现机器码的运算。
+ 带余除法：设$x,m\in Z$，$m>0$则存在唯一决定的整数$q$和$r$，使得$x=q\cdot m+r\,,0\leqslant r<m$。
+ 若两个数绝对值之和为模，则互为补数。即模-数的绝对值=数的补数（正数）。从而数加上数的补数就得到了模。
+ 补码就是正数不变，负数取模的结果。如-66=- 0100 0010，而(1000 0000 - 0100 0010)mod(1111 1111)=1011 1110，也就是其补码。
+ 从而就可以用补数的加法替代原码转换的减法。
+ 所以补码可以让减法操作转换为加法操作，减少硬件成本。

### 定点数运算

#### 移位运算

+ 算术移位：通过改变各介数码位和小数点的相对位置，从而改变各数码位的位权。可用移位运算实现乘法、除法。
  + 原码的算数移位——符号位保持不变，仅对数值位进行移位：
    + 若右移高位补0，低位舍弃，右移代表除2，若移出的是0则刚好整除，若移出的是1则会整除余1丢失精度。
    + 若左移低位补0，低位舍弃，左移代表乘2，若移出的是0则刚好乘2，若移出的是1，则会严重误差。
  + 反码的算术移位——正数的反码与原码相同，所以正数的处理跟原码一样。而对于负数而言，反码的1等于原码的0，反码的0等于原码的1：
    + 若右移高位补1，低位舍弃。
    + 若左移高位补1，低位舍弃。
  + 补码的算术移位——正数的补码与原码相同，所以正数的处理跟原码一样。由于负数补码=反码末位加一，导致反码最右边几个连续的1都因进位而变为0，直到进位碰到第一个0为止。所以得到规律：
    + 负数补码中，最右边的1及其右边同原码一样。最右边的1的左边同反码一样。
    + 右移同反码，高位补1，低位舍弃。
    + 左移同原码，低位补0，高位舍弃。
+ 逻辑移位，可以视为对无符号数的算术移位：
  + 逻辑右移：高位补0，低位舍弃。
  + 逻辑左移：低位补0，高位舍弃。
+ 循环移位，将移出的一位放到另一端的端点，类似队列：
  + 循环右移：将最低位的一位移出放到最高位，其余右移一位。
  + 循环左移：将最高位的一位移出放到最低位，其余左移一位。
  + 进位位CF：保存计算是否进位。1代表产生进位，0代表未产生进位。
  + 带进位位的循环左移：需要加上进位位数值的循环左移。
  + 带进位位的循环右移：需要加上进位位数值的循环右移。

#### 加减运算

+ 原码的加减，由加法器和减法器两个硬件来实现，因为最高位为符号位，所以不能直接进行加减：
  + 原码的加法：
    + 正数+正数：绝对值做加法，结果为正数。
    + 负数+负数：绝对值做加法，结果为负数。
    + 正数+负数：绝对值大的减绝对值小的，符号同绝对值大的数。
    + 负数+正数：绝对值大的减绝对殖小的，符号同绝对值大的数。
  + 原码的减法，减数符号取反，转变为加法：
    + 正-负→正+正。
    + 负-正→负+负。
    + 正-正→正+负。
    + 负+正→负-负。
+ 补码的加减，由于减法器的硬件实现比较困难，所以原码的减法操作可以由补码来更简单实现，不用考虑符号位的异常，直接全部参与运算：
  + 如设机器字长为8位含一位符号位，A=15，B=-24，求A+B和A-B的补码。
  + A=+1111，从而原码补码为0000 1111，B=-11000，所以原码为1001 1000，反码为1110 0111，补码为1110 1000。
  + 所以A+B的补码等于A的补码加B的补码，为0000 1111+1110 1000=1111 0111，原码就是1000 1001，即-9，这与预期的一样。
  + 同理负数值的补码就是补码全部取反加1，所以A-B=0000 1111+0001 1000=0010 0111，即+39。
+ 溢出判断，由于使用补码进行加减操作都会变成加法，所以只用考虑加法溢出的处理。
  + 小于最小值就是下溢。只有负数+负数才会下溢得到正数。如-24-124=1110 1000+1000 0100=0110 1100=108。
  + 大于最大值就是上溢。只有正数+正数才会上溢得到负数。如15+124=0000 1111+0111 1100=1000 1011=-117。
  + 方法一，采用一位符号位（模二补码），根据符号位判断：
    + 设A的符号为$A_s$，B的符号为$B_s$，运算结果的符号为$S_s$。
    + 则溢出逻辑表达式为$V=A_sB_s\overline{S_s}+ \overline{A_s}\overline{B_s}S_s$（即$V=A_s\&\&B_s\&\&!(S_s)\mid\mid!(A_s)\&\&!(B_s)\&\&S_s$）。
    + 若$V=0$，表示无溢出，若$V=1$，表示有溢出。
    + 如-24-124=108产生了溢出，$A_s=1$、$B_s=1$、$S_s=0$，$V=A_sB_s\overline{S_s}+ \overline{A_s}\overline{B_s}S_s=1\,1\,1+0\,0\,0=1+0=1$，所以产生了溢出。
  + 方法二，采用一位符号位（模二补码），根据数据位进位1情况判断：
    + 符号位的进位$C_s=0$，最高数值位的进位$C_1=1$时产生了上溢。
    + 符号位的进位$C_s=1$，最高数值位的进位$C_1=0$时产生了下溢。
    + 如-24-124=1110 1000+1000 0100=0110 1100中符号位都为1，所以符号位进1，$C_s=1$，而最高数值位为1+0=1，没有进位，所以$C_1=0$，所以就产生了下溢。
  + 方法三，采用双符号位（模四补码），正数符号为00，负数符号为11。
    + 若两个符号位不同，则表示溢出，第一个符号位表示应该得到的符号位，第二个符号位代表实际得到的符号位。
    + 如-24-124=11,110 1000+11,000 0100=10,110 1100=108。下溢。
    + 如15+124=00,000 1111+00,111 1100=01,000 1011=-117。上溢。
    + 实际存储时只存储一个符号位，运算时会复制一个符号位。
+ 符号扩展：防止溢出的一个方法就是将短数据扩展为长数据。
  + 整数扩展，在原符号位和数值位中间添加新位，正数都填充0，对于负数：
    + 原码：扩展补0。
    + 反码：扩展补1。
    + 补码：扩展补1。
  + 小数扩展，在最后面添加新位，正数都填充0，对于负数：
    + 原码：扩展补0。
    + 反码：扩展补1。
    + 补码：扩展补0。

#### 乘法运算

对于原码的乘数运算可以参考十进制的乘数运算，将乘数一位一位的乘被乘数然后再全部相加得到的就是答案。而使用二进制的一位位乘法显然比十进制的一位位乘更简单。

##### 原码一位乘法

一般使用原码一位乘法，即每次只乘一位的数据。

在原码乘法时，可以先符号位单独处理，将两个符号进行异或操作，得到的结果就是最后的结果的符号。然后对数据的绝对值（去除符号位）进行一位位的乘法（位积）然后相加。

在运算器的组成时出现一个表格，说明在进行乘运算时，ACC保存乘积高位，MQ保存乘数与乘积低位，X保存被乘数。

原码一位乘法机器实现时就是按照这种方式计算：

1. 字长若为n+1位，则ACC、MQ、X全部初始化为n位，将被乘数的绝对值放入X中，MQ放入乘数的绝对值，ACC初始化为全0。
2. 将MQ的最右边的一位当做当前乘运算位，让其进行乘运算，运算规则是，若当前位是1，则ACC加上被乘数，即ACC+=X，若当前位是0，则ACC加上0（保持不变，跳过）。
3. 将ACC和MQ的数据连接在一起，全部逻辑右移一位，ACC数据高位补0，ACC最后一个低位移到MQ的最高位。将MQ的最后一位抛弃。若是第i轮逻辑右移，则MQ的前i位是结果的后i个低位值。
4. 从步骤二开始重复，字长若为n+1位，则重复n次，直到MQ的最后一位是符号位，则停止计算。此时ACC的全部和MQ的前n位都是结果。
5. 定点小数的小数位隐藏在符号位后面第一位，定点正数的小数位隐藏在MQ符号位的前一位。
6. 将两个符号位的异或结果赋值给积最高位。

**例题** 设机器字长为n+1=5位(含1位符号位），其中x的原码为1.1101，y的原码为0.1011，采用原码一位乘法求xy。

其中x就是-0.1101，而y就是+0.1011。先抛去符号位，就得到01101和01011两个数据。

将MQ、ACC、X都初始化为五位存储单元。X放入被乘数01101，MQ放入乘数01011，ACC为00000。

运算器结构：ACC与MQ相连，数据流是双向的，ACC与ALU相连，数据流是双向的，X的数据流向ALU。

此时MQ=01011，作为乘法单位的最后位为1，所以ACC+=X，从而=00000+01101=01101，这就是第一个的位积。

由于按照乘法规则，第二个位积计算时需要错位相加，计算机的处理方式是ACC和MQ的数据连在一起，全部逻辑右移一位（左边补0）。

所以ACC的数据由01101变为00110，最后的1移到MQ最高位，MQ由01011变为10101，最后的一位1溢出被抛弃，代表这一位的位积已经计算并相加完成，所以不用管了。此时结果的高位还在ACC中，而结果的低位从ACC移到了MQ中，在MQ的低位也不参与后面的运算，所以也不用管了。

然后计算下一个最低位的位积，此时MQ的最低位还是1，所以ACC+=X=00110+01101=10011。

同样计算完后再错位，进行逻辑右移，ACC由10011变成了01001，MQ由10101变成了11010，最低位的1被抛弃，此时MQ中已经有两个结果最低位。

此时MQ最低位为0，所以ACC保持不变，再逻辑右移一位，ACC由01001变为00100，MQ由11010变为11101，抛弃一位0，MQ有三个结果最低位。

此时MQ最低位为1，则ACC+=X=00100+01101=10001。

同样计算完后再错位，进行逻辑右移，ACC由10001变成了01000，MQ由11101变成了11110，最低位的1被抛弃，此时MQ中已经有四个结果最低位，此时MQ最低位是代表符号的0不参与运算。此时计算已经结束。

小数的小数点隐藏在第一位的后面，所以此时结果在ACC和MQ的前四位中，即0.10001111。最后加上符号异或结果，得到1.10001111。

##### 补码一位乘法

对于补码的乘法运算的逻辑也跟原码的类似，补码的计算就是使用Booth算法实现：

&nbsp;|原码|补码
:----:|:--:|:--:
计算流程|n轮加法、移位|n轮加法、移位，最后进行一次加法
加法的值|+0、+x的原码|+0、+x的补码、+(-x)的补码
判断加值的根据|MQ的最低位|MQ的最低位、辅助位
判断关系|MQ的最低位=1时，ACC+x的原码；MQ的最低位=0时，ACC不变|辅助位-MQ中最低位=1时，(ACC)+x的补码；辅助位-MQ中最低位=0时，ACC不变；辅助位-MQ中最低位=-1时，ACC+(-x)的补码
移位类型|逻辑右移|算术右移
符号位|不参与运算|参与运算

辅助位其实就是在MQ最后再加上一位，辅助位初始为0。每次右移会使MQ的最低位顶替原本的辅助位（事实上MQ共n+2位）。

为了保证统一，所以ACC和X都会增加一位，变成n+2位，多出来的一位就可以实现双符号位补码运算，二MQ还是用原理的单符号位。

为了加快运算会有辅助电路实现(-x)的补码的运算。

最后一次不需要移位直接根据辅助位和MQ最后一位判断进行相加。从而让乘数的符号位也参数运算中来确定最后结果的符号。

#### 除法运算

进行除法操作时，都是为了找到一位能让商乘除数能最大即余数最小但大于0的值。若除数被除数都是小数，可以同时乘一个数变成整数再运算。

所以可以忽略小数点，每确定一位商进行一次减法，若机器字长为n位，则得到n-1位余数，在余数末尾补0，再确定下一位商0或1，直到确定n位商即可停止。

在运算器的组成时出现一个表格，说明在进行除运算时，ACC保存被除数和余数，MQ保存商，X保存除数。

##### 原码恢复余数法

原码使用恢复余数法进行除运算：

1. 字长若为n+1位，则ACC、MQ、X全部初始化为n位，将被除数的绝对值放入ACC中，X放入除数的绝对值，MQ初始化为全0。
2. 将MQ的最右边的一位当做当前除运算位，让其进行除运算，运算规则是，默认商1，ACC-=X，即x的补码要加上除数的绝对值的负值的补码（减法都由补码的加法实现），判断是否有误。若结果高位为0则无误，高位为1则有误，错误则商改为0，并恢复余数，ACC加上X中除数的补码。
3. 将ACC和MQ的数据连接在一起，全部逻辑左移一位，MQ数据低位补0，MQ最高位的0移到ACC的最低位。将ACC的最高一位抛弃。若是第i轮逻辑左移，则MQ的后i位是当前计算的商的结果。
4. 从步骤二开始重复，字长若为n+1位，则左移n次，上商n+1次，直到MQ中全部是计算结果，则停止计算。此时MQ中保存商，ACC中保存左移n位的余数值，真正的余数应该是结果再乘上2的-n次方。
5. 定点小数的小数位隐藏在符号位后面第一位，定点正数的小数位隐藏在最后一位后。
6. 将两个符号位的异或结果赋值给商最高位。

**例题** 设机器字长为5位（含一位符号位），x=0.1011，y=0.1101，采用原码恢复余数法求x/y。

其中x就是+0.1011，而y就是+0.1101。先抛去符号位，就得到01011和01101两个数据。然后求出y绝对值的补码：01101和-y绝对值的补码：10011。

将MQ、ACC、X都初始化为五位存储单元。将被除数01011放入ACC中，将除数01101放入X中，商初始化为00000。

手算时每位商取0/1是通过判断当前余数和除数的大小确定的。而机器实现时就要通过ALU判断是ACC中的数更大还是X中的数更大，如果ACC的更大就商1，若X的更大就商0。

第一位默认商1，ACC-=X，ACC的01011和X的10011（X实际值的负值的补码）输入ALU进行加操作01011+10011=11110，返回给ACC，此时发现代表符号的最高位为1，代表出现了负数，就表明之前的商出错了，所以重新确定商为0，ACC要恢复余数，从而再加上y的补码：11110+01101=01011。

第一位的商计算完后需要进行计算，错位相除，所以同乘法一样，ACC和MQ的值都要逻辑左移一位，低位补0，所以MQ由00000还是变为00000，MQ的最高位的0移到ACC最低为，ACC最高位丢弃，由01011变成10110。

然后第二位默认商1，同样ACC-=X，10110+10011=01001，将这个值赋给ACC，发现符号位为0，代表正，商就没有问题，MQ为00001。

再次逻辑左移一位，MQ由00001变为00010，ACC由01001变为10010。

第三位默认商1，同样ACC-=X，10010+10011=00101，商没有问题，MQ为00011。

再次逻辑左移一位，MQ由00011变为00110，ACC由00101变为01010。

第四位默认商1，同样ACC-=X，01010+10011=11101，高位为1，商应该为0，MQ变为00110，ACC恢复余数：11101+01101=01010。

再次逻辑左移一位，MQ由00110变为01100，ACC由01010变为10100。

第五位默认商1，同样ACC-=X，10100+10011=00111，高位为0，商没有问题，MQ为01101。

此时计算结束，商为01101，余数为00111。

##### 原码加减交替法

因为恢复余数很麻烦，所以会考虑是否不用恢复余数，直接进行运算得到后面的结果。

假如令原始值为x，原始值加上-y绝对值的补码结果为a，y绝对值的补码为b，按恢复余数法，a这个余数是一个负值，所以要加上b即a+b变成原始值a+b=x，这时候商0，然后计算下一个商，余数a+b左移一位，即(a+b)×2=2a+2b，这时候商1看看结果是否正确，即2a+2b要减去y绝对值的补码（等价于加上-y绝对值的补码）2a+2b-b=2a+b。

所以如果得到了一个负的余数a，可以直接转换到2a+b这个结果，即直接左移一位余数再加上除数的补码就可以得到结果。

这就是加减交通法或不恢复余数法。

从而恢复余数法就是当余数为负时商0,并+|除数|，再左移，再-|除数|，而加减交替法是当余数为负时商0，并左移，再+[除数|，若余数为正时商1，并左移，再-|除数|。

值得注意的是，若在最后一步余数为负，需要商0，并加上除数的补码得到正确余数。

<span style="color:orange">注意：</span>在定点小数运算时，商只能是小数而不能是整数，所以被除数一定要小于除数，机器判断标准是看第一步计算的商，若第一步计算的商是1则代表结果大于1，机器就会报错。

##### 补码加减交替法

+ 符号位参与运算。
+ 被除数/余数、除数采用双符号位。
+ 被除数和除数同号，则被除数减去除数，异号则被除数加上除数。
+ 余数和除数同号，商1，余数左移一位减去除数;
+ 余数和除数异号，商0，余数左移一位加上除数。
+ 重复n次。
+ 最后一次计算时末位商横置为1，处理简单，而且精度误差也不会超过$2^{-n}$。

除法类型|符号位参与运算|加减次数|移位方向|移位次数次数|上商和加减原则|说明
:------:|:------------:|:------:|:------:|:----------:|:-----------:|:---:
原码加减交替法|否|N+1或N+2|左|N|余数的正负|若最终余数为负，需恢复余数
补码加减交替法|是|N+1|左|N|余数和除数是否同号|商末位恒置1

#### 强制类型转换

+ 无符号数与有符号数：不改变数据内容，只改变解释方式。
+ 长整数转短整数：高位截断，保留低位。
+ 短整数转长整数：符号扩展。

#### 数据存储与排列

+ 数据最左边的高位就是最高有效字节MSB。
+ 数据最右边的低位就是最低有效字节LSB。
+ 大端模式：将MSB存到最低地址，LSB存在最高地址。便于人类阅读。
+ 小端模式：将MSB存到最高地址，LSB存在最低地址。便于机器读取。
+ 边界对齐：
  + 现代计算机通常是按字节编址即每个字节对应一个地址通常。也支持按字、按半字、按字节寻址。
  + 假设存储字长为32位，则1个字=32bit，半字=16bit。每次访存只能读/写1个字。
  + 字地址转换为字节地址，只用逻辑左移两位就可以了，即乘以4，因为字长为32，而字节长8。
  + 使用边界对齐方式会让每个数据都能一次性读完而不用跨行读取，多余的空间用0填充。

## 浮点数

指小数点的位置不固定，如使用科学计数法，如9.694E2。

### 浮点数表示

#### 阶码与尾数

+ 定点数能表示的数字范围有限，但我们不能无限制地增加数据的长度。
+ 类似科学计数法，分为阶码和尾数两个部分，阶码反映数值大小、表示范围、小数点实际位置，尾数反映精度。
+ 对于二进制的浮点数，阶码是常用补码或移码表示的定点整数，而尾数是常用原码或补码表示的定点小数。
+ 若阶码的真值为$E$，尾数的真值为$M$，则浮点数的真值为$N=r^E\times M$，其中r为阶码的底，即基数，一般为2。

**例题** 若阶码和尾数都使用补码表示，求对应真值：a=0,01;1.1001。

a的阶码为0,01，是正数，所以补码与原码一样，从数值来看就是+1。而尾数1.1001代表负数，补码为反码加1，所以真值为1,0110+1=1,0111，即=-(0.25+0.125+0.0625)。所以a的真值就是2×(-0.0111)=-0.111=-0.875（相当于乘2左移一位）。

#### 尾数规格化

+ 左规：出现下溢需要左规，即若尾数的高位是无效值（即为0）则会丧失精度，所以我们需要尽可能将尾数多保存一些1，从而让最高位为1。所以需要让数值左移，让小数点右移，尾数算术左移n位，阶码减n，直到尾数最高位是有效值。
+ 右规：出现上溢需要右规，规范要求小数点要在第一个非0的数据右边，如果小数点前有超过1个有效位，则需要将数值右移，小数点左移，尾数算术右移n位，阶码加n，直到小数点在尾数最高位的右边。

**例题** 若a=010;00.1100，b=010;00.1000，求a+b的值。

已知分号前面的是阶码，后面是尾数，所以a和b都是2的010=2次幂。

由尾数的00代表a和b都是双符号位表示且都是正数。

所以a=2×2×00.1100，b=2×2×00.1000，则a+b=2×2×00.1100+2×2×00.1000=2×2×(00.1100+00.1000)=2×2×01.0100。

因为使用双符号位表示时，00代表正号，11表示负号，01时，称为上溢，为10时，称为下溢，此时结果为01，表示出现了上溢，这时候就需要右规。

阶码加一，变成2的三次方，尾数右移一位=2×2×2×00.1010。最后结果就是011;01010。

规格化浮点数的特点：

1. 用原码表示的尾数进行规格化，最高位数值一定为1：
   + 正数为0.1××...×的形式，其最大值表示为0.11...1；最小值表示为0.10...0。
   + 尾数的表示范围为$\dfrac{1}{2}\leqslant M\leqslant(1-2^{-n})$。
   + 负数为1.1××...×的形式，其最大值表示为1.10...0;最小值表示为1.11...1。
   + 尾数的表示范围为$-(1-2^{-n})\leqslant M\leqslant\dfrac{1}{2}$。
2. 用补码表示的尾数进行规格化，符号位与最高位数值一定相反：
   + 正数为0.1××...×的形式，其最大值表示为0.11...1；最小值表示为0.10...0。
   + 尾数的表示范围为$\dfrac{1}{2}\leqslant M\leqslant(1-2^{-n})$。
   + 负数为1.0××...×的形式，其最大值表示为1.01...1；最小值表示为1.00..0。（负数的补码1.0xx...x取反后就是1.1xx...x）
   + 尾数的表示范围为$-1\leqslant M\leqslant-(\dfrac{1}{2}+2^{-n})$。（补码中强制规定1.00...0就代表-1）

### IEEE 754标准

### 浮点数运算

## 算术逻辑单元

