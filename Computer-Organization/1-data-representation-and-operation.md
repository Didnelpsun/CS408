# 数据表示与运算

## 数制与编码

### 进位计数制

+ 真值：符合人类习惯的数字。
+ 机器数：数字实际存到机器里的形式，正负号需要被“数字化”。

#### 十进制

+ 符号反映权重。
+ 符号所在位置也反映权重。
+ $K_nK_{n-1}\cdots K_2K_1K_0K_{-1}K_{-2}\cdots K_{-m}=K_n\times10^n+K_{n-1}\times10^{n-1}\cdots K_2\times10^2+K_1\times10^1+K_0\times10^0+K_{-1}\times10^{-1}+K_{-2}\times10^{-2}\cdots K_{-m}\times10^{-m}$。

#### R进制

+ 基数：每个数码位所用到的不同符号的个数，r进制的基数r。
+ R进制转换为十进制：$K_nK_{n-1}\cdots K_2K_1K_0K_{-1}K_{-2}\cdots K_{-m}=K_n\times r^n+K_{n-1}\times r^{n-1}\cdots K_2\times r^2+K_1\times r^1+K_0\times r^0+K_{-1}\times r^{-1}+K_{-2}\times r^{-2}\cdots K_{-m}\times r^{-m}=\sum_{i=-m}^nK_i\times r^i$。
+ 二进制：0、1。
+ 使用二进制的原因：
  1. 可使用两个稳定状态的物理器件表示。
  2. 0，1正好对应逻辑值假、真。方便实现逻辑运算。
  3. 可很方便地使用逻辑门电路实现算术运算。
+ 八进制：0、1、2、3、4、5、6、7。可以用下标方式表明，也可以用结束的O或开头的0表示。如$(1643)_8$、01643、1643O。
+ 十进制：0、1、2、3、4、5、6、7、8、9。可以用下标方式表明，也可以用结束的D表示，如$(1643)_{10}$、1643D。
+ 十六进制：0、1、2、3、4、5、6、7、8、9、A、B、C、D、E、F。可以用下标方式表明，也可以用结束的H或开头的0x表示。如$(1643)_{16}$、0x1643、1643H。

#### 二进制与八进制或十六进制转换

+ 二进制转换八进制：三位一组，每组转换成对应的八进制符号，整数部分不全则最高位用0填充，小数部分不全则最低位用0填充。
+ 二进制转换十六进制：四位一组，每组转换成对应的十六进制符号，整数部分不全则最高位用0填充，小数部分不全则最低位用0填充。
+ 八进制转换二进制：每位八进制对应的三位二进制。
+ 十六进制转换二进制：每位十六进制对应的四位二进制。

十进制|二进制|八进制|十六进制
:---:|:----:|:----:|:-----:
0|0000|0|0
1|0001|1|1
2|0010|2|2
3|0011|3|3
4|0100|4|4
5|0101|5|5
6|0110|6|6
7|0111|7|7
8|1000|10|8
9|1001|11|9
10|1010|12|A
11|1011|13|B
12|1100|14|C
13|1101|15|D
14|1110|16|E
15|1111|17|F

#### 十进制转换为R进制

+ 整数部分需要使用除基取余法，小数部分需要使用乘基取整法。
+ 对于十进制数，需要把它分为整数部分和小数部分两个部分进行处理。
+ 已知R进制转换为十进制的方法：$K=K_nK_{n-1}\cdots K_2K_1K_0K_{-1}K_{-2}\cdots K_{-m}=K_n\times r^n+K_{n-1}\times r^{n-1}\cdots K_2\times r^2+K_1\times r^1+K_0\times r^0+K_{-1}\times r^{-1}+K_{-2}\times r^{-2}\cdots K_{-m}\times r^{-m}$。
+ 分为整数部分和小数部分：$K=N+F$。
+ 首先把整数拿出来得到$N=K_n\times r^n+K_{n-1}\times r^{n-1}\cdots K_2\times r^2+K_1\times r^1+K_0\times r^0$。
+ 对这个数除以基数$r$，得到$X=K_n\times r^{n-1}+K_{n-1}\times r^{n-2}\cdots K_2\times r^1+K_1\times r^0$，这时候就会得到一个余数$K_0$。所以$N=rX+K_0$，这时候就能算出$K_0$这个位数了。
+ 同理再将得到的商$X$同样除以$r$，就能得到$K_1$，所以不断递归就会得到整数部分所有的$K_i$。
+ 得到的$K_i$是从低位排到高位。
+ 对于小数部分$F=K_{-1}\times r^{-1}+K_{-2}\times r^{-2}\cdots K_{-m}\times r^{-m}$。
+ 对这个数乘基数$r$，得到$K_{-1}\times r^0+K_{-2}\times r^{-1}\cdots K_{-m}\times r^{-m+1}$，取这个常数$K_{-1}$就是想要的答案。将乘积减去这个整数部分得到后面处理的数据
+ 同理再将得到的数据不断乘基数，就能得到小数部分所有的$K_i$。
+ 得到的$K_i$是从高位排到低位。
+ 将整数和小数合在一起就是最后的结果。
+ 有时候小数会出现无法彻底转换的情况，需要考虑保留多少位。

**例题** 将十进制的75.3转换为二进制并保留三位。

首先将75拿出来，以基数2相除：

75÷2=37……1，37÷2=18……1，18÷2=9……0，9÷2=4……1，4÷2=2……0，2÷2=1……0，1÷2=0……1，这个顺序是从低位到高位的，所以75转换二进制就是1001011。

然后是对小数0.3的处理：

0.3×2=0.6=0+0.6，0.6×2=1.2=1+0.2，0.2×2=0.4=0+0.4，这个顺序是从高位到低位的，所以0.3转换二进制就是0.01。

所以转换最后得到1001011.01。

同理也可以使用拼凑法将数字拼凑成对应的数值。这种方法对于只有整数的数值比较好用。

$2^{12}$|$2^{11}$|$2^{10}$|$2^{9}$|$2^{8}$|$2^{7}$|$2^{6}$|$2^{5}$|$2^{4}$|$2^{3}$|$2^{2}$|$2^{1}$|$2^{0}$|$2^{-1}$|$2^{-2}$|$2^{-3}$
:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:
4096|2048|1024|512|256|128|64|32|16|8|4|2|1|0.5|0.25|0.125

### BCD码

即Binary-Coded Decimal，用二进制编码的十进制。

使用4bit来表示0到9这十个数，而4bit能表示十六个数，所以会冗余六个组合。

#### 8421码

8421码是一种有权码，第1、2、3、4位分别对应8、4、2、1，使用常规的二进制来表示十进制：

0|1|2|3|4|5|6|7|8|9
:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:
0000|0001|0010|0011|0100|0101|0110|0111|1000|1001

如985用8421码表示就是1001 1000 0101。

使用8421码表示的数字进行算术运算的方式是先按照二进制的方式进行运算，若最后结果不在映射表中，即落在没有定义的1010到1111中，就直接加上6（因为有六位无效，所以加上六位跳过无效的位数）从而进一位，多了一段补全0。每个段对应的数值合在一起就是原来的结果。

如5+8=0101+1000=1101=13，不在映射表中，则对1101加6，即计算19，得到1 0011这个值，补齐得到0001 0011，而按照8421码，最高位的0001不再代表权值16，而代表十位的1，而后面是3，从而组合在一起就代表了13。

#### 余三码

在8421码的基础上全部加上三：

0|1|2|3|4|5|6|7|8|9
:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:
0011|0100|0101|0110|0111|1000|1001|1010|1011|1100

余三码因为加上了三，所以每一位的权值映射关系就破坏了，所以这是一种无权码，不能分别对应8、4、2、1的值。

#### 2421码

与8421码一样都是一种有权码，但是映射的方式不同，第1、2、3、4位分别对应2、4、2、1。

0|1|2|3|4|5|6|7|8|9
:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:
0000|0001|0010|0011|0100|1011|1100|1101|1110|1111

### 字符与字符串

#### 英文字符表示

ASCII码，数字英文符号一共128个字符，使用7位就可以表示128个字符，但是通常会高位补0凑足1B：

+ 其中32到126是可印刷字符，其他都是控制或通信字符。
+ 数字：48（0011 0000）到57（0011 1001），后面4位就是数字的8421码。
+ 大写字母：65（0100 0001）到90（0101 1010），前面三位是010，后面五位代表1到26。
+ 小写字母：97（0110 0001）到122（0111 1010），前面三位是011，后面五位代表1到26。

#### 中文字符表示

+ GB 2312-80：1980年推出汉字加符号共7445个表示的字符。中文有两个字节。
  + 区位码：94个区，每个区94位。
  + 国标码：为了中文字符表示与英文字符表示共存，防止GB编码被认为是ASCII码的0到32位的控制或通信字符，所以在94区94位的基础上还要各自加上32，即20H，防止信息交换时冲突。
  + 汉字内码：国标码只能用于信息传输，而如果是存储在计算机上，由于前128位已经被ASCII码占用了，所以在国标码的基础上再各自加80H（128），从而计算机识别字符时，看到0到128之间的就能辨认出是ASCII码，大于128的就是GB码。因为ASCII码高位是0，而GB码是两个字节且高位都是1。
+ 输入编码：如拼音、五笔等供人类输入，输入编码输入后转换为国标码再转成汉字内码存储。
+ 汉字字形码：把汉字输出成汉字的样子。

#### 字符串

+ 若一个计算机按字节编址，则每个地址对应Q1B。
+ 很多语言中将'\0'即00H作为字符串结束标志。
+ 大端模式：将数据的最高有效字节存放在低地址单元中。
+ 小端模式：将数据的最高有效字节存放在高地址单元中

### 数据校验

现在计算机组成原理不考数据校验，但是只是内容移动到计算机网络里。具体可以看计算机网络。

+ 校验原理就是将更多字节映射到有限个合法状态，从而有多个冗余的非法状态，更容易判断是否非法。
+ 码字：由若干位代码组成的一个字。
+ 两个码字间的距离：将两个码字逐位进行对比，具有不同的位的个数。
+ 码距：一种编码方案可能有若干个合法码字，各合法码字间的最小距离。
+ 当码距=1时，无检错能力；当码距=2时，有检错能力；当码距≥3时，若设计合理，可能具有检错、纠错能力。

#### 奇偶校验码

+ 奇校验码：整个校验码（有效信息位和校验位）中为1的个数为奇数。
+ 偶校验码：整个校验码（有效信息位和校验位）中为1的个数为偶数。
+ 偶位数出错时无法校验。
+ 对原始数据进行异或（模2加）运算，得到的结果即为校验位。
+ 对所有数据进行异或运算，结果为0表示未出错，为1代表出错。
+ 码距为2，只能检错，不能纠错。

#### 海明码

+ 将信息分组进行偶校验，从而得到多个校验位，从而能携带多种状态信息。
+ 设信息位为$n$，校验位为$k$，从而能表达$2^k$中状态，而信息位+校验位一共$n+k$位，只错一位的状态种数加上一种正确状态为$n+k+1$，从而$2^k\geqslant n+k+1$。
+ 令信息位为$D_i$，校验位为$P_j$，总海明码为$H_k$，其中校验位$P_j$必须放在海明码$H_k$位号位$2^{j-1}$的位置上，即1、2、4、8等。
+ 如果没有发生错误，则每一位进行检错都是0，若出现1，则说明出错。
+ 为了检测是一位错还是两位错，一般会加上一个全校验位，对整体进行偶校验。
+ 具有一位和两位的纠错检错能力，三位以上则不能纠错。

n|1|2-4|5-11|12-26|27-57|58-120
:-:|:-:|:-:|:-:|:-:|:--:|:----:
k|2|3|4|5|6|7

#### 循环冗余校验码

+ 即CRC码，其思想是：
  1. 数据发送、接受方约定一个“除数”。
  2. K个信息位+R个校验位作为“被除数”，添加校验位后需保证除法的余数为0。
  3. 收到数据后，进行除法检查余数是否为0。


## 定点数

## 浮点数

## 算术逻辑单元

