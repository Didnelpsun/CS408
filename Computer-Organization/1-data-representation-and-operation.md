# 数据表示与运算

## 数制与编码

### 进位计数制

+ 真值：符合人类习惯的数字。
+ 机器数：数字实际存到机器里的形式，正负号需要被“数字化”。

#### 十进制

+ 符号反映权重。
+ 符号所在位置也反映权重。
+ $K_nK_{n-1}\cdots K_2K_1K_0K_{-1}K_{-2}\cdots K_{-m}=K_n\times10^n+K_{n-1}\times10^{n-1}\cdots K_2\times10^2+K_1\times10^1+K_0\times10^0+K_{-1}\times10^{-1}+K_{-2}\times10^{-2}\cdots K_{-m}\times10^{-m}$。

#### R进制

+ 基数：每个数码位所用到的不同符号的个数，r进制的基数r。
+ R进制转换为十进制：$K_nK_{n-1}\cdots K_2K_1K_0K_{-1}K_{-2}\cdots K_{-m}=K_n\times r^n+K_{n-1}\times r^{n-1}\cdots K_2\times r^2+K_1\times r^1+K_0\times r^0+K_{-1}\times r^{-1}+K_{-2}\times r^{-2}\cdots K_{-m}\times r^{-m}=\sum_{i=-m}^nK_i\times r^i$。
+ 二进制：0、1。
+ 使用二进制的原因：
  1. 可使用两个稳定状态的物理器件表示。
  2. 0，1正好对应逻辑值假、真。方便实现逻辑运算。
  3. 可很方便地使用逻辑门电路实现算术运算。
+ 八进制：0、1、2、3、4、5、6、7。可以用下标方式表明，也可以用结束的O或开头的0表示。如$(1643)_8$、01643、1643O。
+ 十进制：0、1、2、3、4、5、6、7、8、9。可以用下标方式表明，也可以用结束的D表示，如$(1643)_{10}$、1643D。
+ 十六进制：0、1、2、3、4、5、6、7、8、9、A、B、C、D、E、F。可以用下标方式表明，也可以用结束的H或开头的0x表示。如$(1643)_{16}$、0x1643、1643H。

#### 二进制与八进制或十六进制转换

+ 二进制转换八进制：三位一组，每组转换成对应的八进制符号，整数部分不全则最高位用0填充，小数部分不全则最低位用0填充。
+ 二进制转换十六进制：四位一组，每组转换成对应的十六进制符号，整数部分不全则最高位用0填充，小数部分不全则最低位用0填充。
+ 八进制转换二进制：每位八进制对应的三位二进制。
+ 十六进制转换二进制：每位十六进制对应的四位二进制。

十进制|二进制|八进制|十六进制
:---:|:----:|:----:|:-----:
0|0000|0|0
1|0001|1|1
2|0010|2|2
3|0011|3|3
4|0100|4|4
5|0101|5|5
6|0110|6|6
7|0111|7|7
8|1000|10|8
9|1001|11|9
10|1010|12|A
11|1011|13|B
12|1100|14|C
13|1101|15|D
14|1110|16|E
15|1111|17|F

#### 十进制转换为R进制

+ 整数部分需要使用除基取余法，小数部分需要使用乘基取整法。
+ 对于十进制数，需要把它分为整数部分和小数部分两个部分进行处理。
+ 已知R进制转换为十进制的方法：$K=K_nK_{n-1}\cdots K_2K_1K_0K_{-1}K_{-2}\cdots K_{-m}=K_n\times r^n+K_{n-1}\times r^{n-1}\cdots K_2\times r^2+K_1\times r^1+K_0\times r^0+K_{-1}\times r^{-1}+K_{-2}\times r^{-2}\cdots K_{-m}\times r^{-m}$。
+ 分为整数部分和小数部分：$K=N+F$。
+ 首先把整数拿出来得到$N=K_n\times r^n+K_{n-1}\times r^{n-1}\cdots K_2\times r^2+K_1\times r^1+K_0\times r^0$。
+ 对这个数除以基数$r$，得到$X=K_n\times r^{n-1}+K_{n-1}\times r^{n-2}\cdots K_2\times r^1+K_1\times r^0$，这时候就会得到一个余数$K_0$。所以$N=rX+K_0$，这时候就能算出$K_0$这个位数了。
+ 同理再将得到的商$X$同样除以$r$，就能得到$K_1$，所以不断递归就会得到整数部分所有的$K_i$。
+ 得到的$K_i$是从低位排到高位。
+ 对于小数部分$F=K_{-1}\times r^{-1}+K_{-2}\times r^{-2}\cdots K_{-m}\times r^{-m}$。
+ 对这个数乘基数$r$，得到$K_{-1}\times r^0+K_{-2}\times r^{-1}\cdots K_{-m}\times r^{-m+1}$，取这个常数$K_{-1}$就是想要的答案。将乘积减去这个整数部分得到后面处理的数据
+ 同理再将得到的数据不断乘基数，就能得到小数部分所有的$K_i$。
+ 得到的$K_i$是从高位排到低位。
+ 将整数和小数合在一起就是最后的结果。
+ 有时候小数会出现无法彻底转换的情况，需要考虑保留多少位。

**例题** 将十进制的75.3转换为二进制并保留三位。

首先将75拿出来，以基数2相除：

75÷2=37……1，37÷2=18……1，18÷2=9……0，9÷2=4……1，4÷2=2……0，2÷2=1……0，1÷2=0……1，这个顺序是从低位到高位的，所以75转换二进制就是1001011。

然后是对小数0.3的处理：

0.3×2=0.6=0+0.6，0.6×2=1.2=1+0.2，0.2×2=0.4=0+0.4，这个顺序是从高位到低位的，所以0.3转换二进制就是0.01。

所以转换最后得到1001011.01。

同理也可以使用拼凑法将数字拼凑成对应的数值。这种方法对于只有整数的数值比较好用。

$2^{12}$|$2^{11}$|$2^{10}$|$2^{9}$|$2^{8}$|$2^{7}$|$2^{6}$|$2^{5}$|$2^{4}$|$2^{3}$|$2^{2}$|$2^{1}$|$2^{0}$|$2^{-1}$|$2^{-2}$|$2^{-3}$
:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:
4096|2048|1024|512|256|128|64|32|16|8|4|2|1|0.5|0.25|0.125

### BCD码

即Binary-Coded Decimal，用二进制编码的十进制。

使用4bit来表示0到9这十个数，而4bit能表示十六个数，所以会冗余六个组合。

#### 8421码

8421码是一种有权码，第1、2、3、4位分别对应8、4、2、1，使用常规的二进制来表示十进制：

0|1|2|3|4|5|6|7|8|9
:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:
0000|0001|0010|0011|0100|0101|0110|0111|1000|1001

如985用8421码表示就是1001 1000 0101。

使用8421码表示的数字进行算术运算的方式是先按照二进制的方式进行运算，若最后结果不在映射表中，即落在没有定义的1010到1111中，就直接加上6（因为有六位无效，所以加上六位跳过无效的位数）从而进一位，多了一段补全0。每个段对应的数值合在一起就是原来的结果。

如5+8=0101+1000=1101=13，不在映射表中，则对1101加6，即计算19，得到1 0011这个值，补齐得到0001 0011，而按照8421码，最高位的0001不再代表权值16，而代表十位的1，而后面是3，从而组合在一起就代表了13。

#### 余三码

在8421码的基础上全部加上三：

0|1|2|3|4|5|6|7|8|9
:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:
0011|0100|0101|0110|0111|1000|1001|1010|1011|1100

余三码因为加上了三，所以每一位的权值映射关系就破坏了，所以这是一种无权码，不能分别对应8、4、2、1的值。

#### 2421码

与8421码一样都是一种有权码，但是映射的方式不同，第1、2、3、4位分别对应2、4、2、1。

0|1|2|3|4|5|6|7|8|9
:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:
0000|0001|0010|0011|0100|1011|1100|1101|1110|1111

### 字符与字符串

#### 英文字符表示

ASCII码，数字英文符号一共128个字符，使用7位就可以表示128个字符，但是通常会高位补0凑足1B：

+ 其中32到126是可印刷字符，其他都是控制或通信字符。
+ 数字：48（0011 0000）到57（0011 1001），后面4位就是数字的8421码。
+ 大写字母：65（0100 0001）到90（0101 1010），前面三位是010，后面五位代表1到26。
+ 小写字母：97（0110 0001）到122（0111 1010），前面三位是011，后面五位代表1到26。

#### 中文字符表示

+ GB 2312-80：1980年推出汉字加符号共7445个表示的字符。中文有两个字节。
  + 区位码：94个区，每个区94位。
  + 国标码：为了中文字符表示与英文字符表示共存，防止GB编码被认为是ASCII码的0到32位的控制或通信字符，所以在94区94位的基础上还要各自加上32，即20H，防止信息交换时冲突。
  + 汉字内码：国标码只能用于信息传输，而如果是存储在计算机上，由于前128位已经被ASCII码占用了，所以在国标码的基础上再各自加80H（128），从而计算机识别字符时，看到0到128之间的就能辨认出是ASCII码，大于128的就是GB码。因为ASCII码高位是0，而GB码是两个字节且高位都是1。
+ 输入编码：如拼音、五笔等供人类输入，输入编码输入后转换为国标码再转成汉字内码存储。
+ 汉字字形码：把汉字输出成汉字的样子。

#### 字符串

+ 若一个计算机按字节编址，则每个地址对应Q1B。
+ 很多语言中将'\0'即00H作为字符串结束标志。
+ 大端模式：将数据的最高有效字节存放在低地址单元中。
+ 小端模式：将数据的最高有效字节存放在高地址单元中

### 数据校验

现在计算机组成原理不考数据校验，但是只是内容移动到计算机网络里。具体可以看计算机网络。

+ 校验原理就是将更多字节映射到有限个合法状态，从而有多个冗余的非法状态，更容易判断是否非法。
+ 码字：由若干位代码组成的一个字。
+ 两个码字间的距离：将两个码字逐位进行对比，具有不同的位的个数。
+ 码距：一种编码方案可能有若干个合法码字，各合法码字间的最小距离。
+ 当码距=1时，无检错能力；当码距=2时，有检错能力；当码距≥3时，若设计合理，可能具有检错、纠错能力。

#### 奇偶校验码

+ 奇校验码：整个校验码（有效信息位和校验位）中为1的个数为奇数。
+ 偶校验码：整个校验码（有效信息位和校验位）中为1的个数为偶数。
+ 偶位数出错时无法校验。
+ 对原始数据进行异或（模2加）运算，得到的结果即为校验位。
+ 对所有数据进行异或运算，结果为0表示未出错，为1代表出错。
+ 码距为2，只能检错，不能纠错。

#### 海明码

+ 将信息分组进行偶校验，从而得到多个校验位，从而能携带多种状态信息。
+ 设信息位为$n$，校验位为$k$，从而能表达$2^k$中状态，而信息位+校验位一共$n+k$位，只错一位的状态种数加上一种正确状态为$n+k+1$，从而$2^k\geqslant n+k+1$。
+ 令信息位为$D_i$，校验位为$P_j$，总海明码为$H_k$，其中校验位$P_j$必须放在海明码$H_k$位号位$2^{j-1}$的位置上，即1、2、4、8等。
+ 如果没有发生错误，则每一位进行检错都是0，若出现1，则说明出错。
+ 为了检测是一位错还是两位错，一般会加上一个全校验位，对整体进行偶校验。
+ 具有一位和两位的纠错检错能力，三位以上则不能纠错。

n|1|2-4|5-11|12-26|27-57|58-120
:-:|:-:|:-:|:-:|:-:|:--:|:----:
k|2|3|4|5|6|7

#### 循环冗余校验码

+ 即CRC码，其思想是：
  1. 数据发送、接受方约定一个“除数”。
  2. K个信息位+R个校验位作为“被除数”，添加校验位后需保证除法的余数为0。
  3. 收到数据后，进行除法检查余数是否为0。
+ 得到CRC码的方法：
  1. 确定K和R以及生成多项式对应的二进制码。其中R位生成多项式的最高次幂数。
  2. 将信息码左移R位，低位补0。
  3. 使用模二除法。
  4. 余数就是校验位，只比多项式少一位。
  5. 对全部数据进行多项式除，余数为0代表无措。
  6. 若余数不为0，则出错。
  7. 若$n$个信息位，$k$个校验位，若生成多项式得当，且$2^k\geqslant n+k+1$，则CRC码可纠正一位错。实际上基本上不怎么用来纠错。

## 定点数

指小数点的位置不变，使用常规计数法，如96.94。

### 定点数表示

#### 无符号数

+ 整个机器字长的全部二进制位均为数值位，没有符号位，相当于数的绝对值。
+ $n$位无符号数表示范围为$[0,2^n-1]$。
+ 无符号数不涉及小数。

#### 有符号数

+ 定点整数：最高一位是符号位，0是正，1是负，小数点位置一般隐含在最后。
+ 定点小数：最高一位是符号位，0是正，1是负，小数点位置隐含在符号位后面。
+ 数值部分也称为尾数。要保存一个非整数需要保存定点整数与定点小数两个部分。

#### 原码

+ 原码：用尾数表示真值的绝对值，符号位“0/1”对应“正/负”。
+ 若机器字长为n+1位，则尾数占n位。
+ 若使用1B来保存数值，则+19D就是0001 0011，-19D就是1001 0011。
+ 有时1001 0011会写为1,0010011，其中的逗号只是为了标注正负号，本身是不存在的。
+ 若未指明机器字长，则最开头的多个0可以省略。如1001 0011可以表示为1,10011。
+ 同理小数也可以使用1.11表示，这是指-0.11。
+ 若机器字长$n+1$位，则原码整数的表示范围是$[-(2^n-1),2^n-1]$。
+ 若机器字长$n+1$位，则原码小数的表示范围是$[-(1-2^{-n}),1-2^{-n}]$。
+ 原码表示时真值0有+0和-0两种形式。

#### 反码

+ 反码：若符号位为0，则反码与原码相同，若符号位为1，则数值位全部取反。
+ 可以转换为原码再取反。
+ 若机器字长$n+1$位，则反码整数的表示范围是$[-(2^n-1),2^n-1]$。
+ 若机器字长$n+1$位，则反码小数的表示范围是$[-(1-2^{-n}),1-2^{-n}]$。
+ 反码表示时真值0有+0和-0两种形式。
+ 反码只是由原码转换为补码的一个中间态，实际上并没有作用。

#### 补码

+ 补码：若符号位为0，则反码与原码相同，若符号位为1，则数值位全部取反再加一，即反码加一。
+ 补码表示时真值0只有一种形式0000 0000。
+ 多出来的一种形式1000 0000表示$-2^7$和$-1$。
+ 若机器字长$n+1$位，则补码整数的表示范围是$[-2^n,2^n-1]$。
+ 若机器字长$n+1$位，则补码小数的表示范围是$[-1,1-2^{-n}]$。
+ 将负数补码转回原码的方法相同：尾数取反，末位加一。补码的补码就是原码。
+ 如果已知一个数值的补码，那么求这个值的负数的补码就是全部位取反，末位加一。
+ 如果已知一个负数的补码，那个求这个值的原码就是数值位取反再加一，或是负数补码中，最右边的1以及右边不变，最右边的1的左边取反。

#### 移码

+ 补码的基础上将符号位取反。
+ 移码只能用于表示整数，而不能表示定点小数。
+ 若机器字长$n+1$位，则移码整数的表示范围是$[-2^n,2^n-1]$。
+ 若机器字长$n+1$位，则移码小数的表示范围是$[-1,1-2^{-n}]$。
+ 移码由于负数的最高位为0，正数的最高位为1，从而能更方便对比大小。

机器数|无符号数|原码|反码|补码|移码
:----:|:------:|:--:|:--:|:--:|:--:
0000 0000|0|+0|+0|0|-128
0000 0001|1|+1|+1|+1|-127
...
0111 1101|125|+125|+125|+125|-3
0111 1110|126|+126|+126|+126|-2
0111 1111|127|+127|+127|+127|-1
1000 0000|128|-0|-127|-128|0
1000 0001|129|-1|-126|-127|1
1000 0010|130|-2|-125|-126|2
...
1111 1101|253|-125|-2|-3|125
1111 1110|254|-126|-1|-2|126
1111 1111|255|-127|-0|-1|127

#### 补码作用

+ 原码在计算时由于首位表示的是符号，所以需要考虑将加减运算转换的问题，而减法实现起来比较困难，就考虑是否可以将减法通过加法来实现。
+ 由于计算机码操作若最高位进一就被舍弃，则天然是进行模运算，所以可以通过数学模运算来实现机器码的运算。
+ 带余除法：设$x,m\in Z$，$m>0$则存在唯一决定的整数$q$和$r$，使得$x=q\cdot m+r\,,0\leqslant r<m$。
+ 若两个数绝对值之和为模，则互为补数。即模-数的绝对值=数的补数（正数）。从而数加上数的补数就得到了模。
+ 补码就是正数不变，负数取模的结果。如-66=- 0100 0010，而(1000 0000 - 0100 0010)mod(1111 1111)=1011 1110，也就是其补码。
+ 从而就可以用补数的加法替代原码转换的减法。
+ 所以补码可以让减法操作转换为加法操作，减少硬件成本。

### 定点数运算

#### 定点数移位运算

+ 算术移位：通过改变各介数码位和小数点的相对位置，从而改变各数码位的位权。可用移位运算实现乘法、除法。
  + 原码的算数移位——符号位保持不变，仅对数值位进行移位：
    + 若右移高位补0，低位舍弃，右移代表除2，若移出的是0则刚好整除，若移出的是1则会整除余1丢失精度。
    + 若左移低位补0，低位舍弃，左移代表乘2，若移出的是0则刚好乘2，若移出的是1，则会严重误差。
  + 反码的算术移位——正数的反码与原码相同，所以正数的处理跟原码一样。而对于负数而言，反码的1等于原码的0，反码的0等于原码的1：
    + 若右移高位补1，低位舍弃。
    + 若左移高位补1，低位舍弃。
  + 补码的算术移位——正数的补码与原码相同，所以正数的处理跟原码一样。由于负数补码=反码末位加一，导致反码最右边几个连续的1都因进位而变为0，直到进位碰到第一个0为止。所以得到规律：
    + 负数补码中，最右边的1及其右边同原码一样。最右边的1的左边同反码一样。
    + 右移同反码，高位补1，低位舍弃。
    + 左移同原码，低位补0，高位舍弃。
+ 逻辑移位，可以视为对无符号数的算术移位：
  + 逻辑右移：高位补0，低位舍弃。
  + 逻辑左移：低位补0，高位舍弃。
+ 循环移位，将移出的一位放到另一端的端点，类似队列：
  + 循环右移：将最低位的一位移出放到最高位，其余右移一位。
  + 循环左移：将最高位的一位移出放到最低位，其余左移一位。
  + 进位位CF：保存计算是否进位。1代表产生进位，0代表未产生进位。
  + 带进位位的循环左移：需要加上进位位数值的循环左移。
  + 带进位位的循环右移：需要加上进位位数值的循环右移。

#### 定点数加减运算

+ 原码的加减，由加法器和减法器两个硬件来实现，因为最高位为符号位，所以不能直接进行加减：
  + 原码的加法：
    + 正数+正数：绝对值做加法，结果为正数。
    + 负数+负数：绝对值做加法，结果为负数。
    + 正数+负数：绝对值大的减绝对值小的，符号同绝对值大的数。
    + 负数+正数：绝对值大的减绝对殖小的，符号同绝对值大的数。
  + 原码的减法，减数符号取反，转变为加法：
    + 正-负→正+正。
    + 负-正→负+负。
    + 正-正→正+负。
    + 负+正→负-负。
+ 补码的加减，由于减法器的硬件实现比较困难，所以原码的减法操作可以由补码来更简单实现，不用考虑符号位的异常，直接全部参与运算：
  + 如设机器字长为8位含一位符号位，A=15，B=-24，求A+B和A-B的补码。
  + A=+1111，从而原码补码为0000 1111，B=-11000，所以原码为1001 1000，反码为1110 0111，补码为1110 1000。
  + 所以A+B的补码等于A的补码加B的补码，为0000 1111+1110 1000=1111 0111，原码就是1000 1001，即-9，这与预期的一样。
  + 同理负数值的补码就是补码全部取反加1，所以A-B=0000 1111+0001 1000=0010 0111，即+39。
+ 溢出判断，由于使用补码进行加减操作都会变成加法，所以只用考虑加法溢出的处理。
  + 小于最小值就是下溢。只有负数+负数才会下溢得到正数。如-24-124=1110 1000+1000 0100=0110 1100=108。
  + 大于最大值就是上溢。只有正数+正数才会上溢得到负数。如15+124=0000 1111+0111 1100=1000 1011=-117。
  + 方法一，采用一位符号位（模二补码），根据符号位判断：
    + 设A的符号为$A_s$，B的符号为$B_s$，运算结果的符号为$S_s$。
    + 则溢出逻辑表达式为$V=A_sB_s\overline{S_s}+ \overline{A_s}\overline{B_s}S_s$（即$V=A_s\&\&B_s\&\&!(S_s)\mid\mid!(A_s)\&\&!(B_s)\&\&S_s$）。
    + 若$V=0$，表示无溢出，若$V=1$，表示有溢出。
    + 如-24-124=108产生了溢出，$A_s=1$、$B_s=1$、$S_s=0$，$V=A_sB_s\overline{S_s}+ \overline{A_s}\overline{B_s}S_s=1\,1\,1+0\,0\,0=1+0=1$，所以产生了溢出。
  + 方法二，采用一位符号位（模二补码），根据数据位进位1情况判断：
    + 符号位的进位$C_s=0$，最高数值位的进位$C_1=1$时产生了上溢。
    + 符号位的进位$C_s=1$，最高数值位的进位$C_1=0$时产生了下溢。
    + 如-24-124=1110 1000+1000 0100=0110 1100中符号位都为1，所以符号位进1，$C_s=1$，而最高数值位为1+0=1，没有进位，所以$C_1=0$，所以就产生了下溢。
  + 方法三，采用双符号位（模四补码），正数符号为00，负数符号为11。
    + 若两个符号位不同，则表示溢出，第一个符号位表示应该得到的符号位，第二个符号位代表实际得到的符号位。
    + 如-24-124=11,110 1000+11,000 0100=10,110 1100=108。下溢。
    + 如15+124=00,000 1111+00,111 1100=01,000 1011=-117。上溢。
    + 实际存储时只存储一个符号位，运算时会复制一个符号位。
+ 符号扩展：防止溢出的一个方法就是将短数据扩展为长数据。
  + 整数扩展，在原符号位和数值位中间添加新位，正数都填充0，对于负数：
    + 原码：扩展补0。
    + 反码：扩展补1。
    + 补码：扩展补1。
  + 小数扩展，在最后面添加新位，正数都填充0，对于负数：
    + 原码：扩展补0。
    + 反码：扩展补1。
    + 补码：扩展补0。

#### 定点数乘法运算

对于原码的乘数运算可以参考十进制的乘数运算，将乘数一位一位的乘被乘数然后再全部相加得到的就是答案。而使用二进制的一位位乘法显然比十进制的一位位乘更简单。

##### 原码一位乘法

一般使用原码一位乘法，即每次只乘一位的数据。

在原码乘法时，可以先符号位单独处理，将两个符号进行异或操作，得到的结果就是最后的结果的符号。然后对数据的绝对值（去除符号位）进行一位位的乘法（位积）然后相加。

在运算器的组成时出现一个表格，说明在进行乘运算时，ACC保存乘积高位，MQ保存乘数与乘积低位，X保存被乘数。

原码一位乘法机器实现时就是按照这种方式计算：

1. 字长若为n+1位，则ACC、MQ、X全部初始化为n位，将被乘数的绝对值放入X中，MQ放入乘数的绝对值，ACC初始化为全0。
2. 将MQ的最右边的一位当做当前乘运算位，让其进行乘运算，运算规则是，若当前位是1，则ACC加上被乘数，即ACC+=X，若当前位是0，则ACC加上0（保持不变，跳过）。
3. 将ACC和MQ的数据连接在一起，全部逻辑右移一位，ACC数据高位补0，ACC最后一个低位移到MQ的最高位。将MQ的最后一位抛弃。若是第i轮逻辑右移，则MQ的前i位是结果的后i个低位值。
4. 从步骤二开始重复，字长若为n+1位，则重复n次，直到MQ的最后一位是符号位，则停止计算。此时ACC的全部和MQ的前n位都是结果。
5. 定点小数的小数位隐藏在符号位后面第一位，定点正数的小数位隐藏在MQ符号位的前一位。
6. 将两个符号位的异或结果赋值给积最高位。

**例题** 设机器字长为n+1=5位(含1位符号位），其中x的原码为1.1101，y的原码为0.1011，采用原码一位乘法求xy。

其中x就是-0.1101，而y就是+0.1011。先抛去符号位，就得到01101和01011两个数据。

将MQ、ACC、X都初始化为五位存储单元。X放入被乘数01101，MQ放入乘数01011，ACC为00000。

运算器结构：ACC与MQ相连，数据流是双向的，ACC与ALU相连，数据流是双向的，X的数据流向ALU。

此时MQ=01011，作为乘法单位的最后位为1，所以ACC+=X，从而=00000+01101=01101，这就是第一个的位积。

由于按照乘法规则，第二个位积计算时需要错位相加，计算机的处理方式是ACC和MQ的数据连在一起，全部逻辑右移一位（左边补0）。

所以ACC的数据由01101变为00110，最后的1移到MQ最高位，MQ由01011变为10101，最后的一位1溢出被抛弃，代表这一位的位积已经计算并相加完成，所以不用管了。此时结果的高位还在ACC中，而结果的低位从ACC移到了MQ中，在MQ的低位也不参与后面的运算，所以也不用管了。

然后计算下一个最低位的位积，此时MQ的最低位还是1，所以ACC+=X=00110+01101=10011。

同样计算完后再错位，进行逻辑右移，ACC由10011变成了01001，MQ由10101变成了11010，最低位的1被抛弃，此时MQ中已经有两个结果最低位。

此时MQ最低位为0，所以ACC保持不变，再逻辑右移一位，ACC由01001变为00100，MQ由11010变为11101，抛弃一位0，MQ有三个结果最低位。

此时MQ最低位为1，则ACC+=X=00100+01101=10001。

同样计算完后再错位，进行逻辑右移，ACC由10001变成了01000，MQ由11101变成了11110，最低位的1被抛弃，此时MQ中已经有四个结果最低位，此时MQ最低位是代表符号的0不参与运算。此时计算已经结束。

小数的小数点隐藏在第一位的后面，所以此时结果在ACC和MQ的前四位中，即0.10001111。最后加上符号异或结果，得到1.10001111。

##### 补码一位乘法

对于补码的乘法运算的逻辑也跟原码的类似，补码的计算就是使用Booth算法实现：

&nbsp;|原码|补码
:----:|:--:|:--:
计算流程|n轮加法、移位|n轮加法、移位，最后进行一次加法
加法的值|+0、+x的原码|+0、+x的补码、+(-x)的补码
判断加值的根据|MQ的最低位|MQ的最低位、辅助位
判断关系|MQ的最低位=1时，ACC+x的原码；MQ的最低位=0时，ACC不变|辅助位-MQ中最低位=1时，(ACC)+x的补码；辅助位-MQ中最低位=0时，ACC不变；辅助位-MQ中最低位=-1时，ACC+(-x)的补码
移位类型|逻辑右移|算术右移
符号位|不参与运算|参与运算

辅助位其实就是在MQ最后再加上一位，辅助位初始为0。每次右移会使MQ的最低位顶替原本的辅助位（事实上MQ共n+2位）。

为了保证统一，所以ACC和X都会增加一位，变成n+2位，多出来的一位就可以实现双符号位补码运算，二MQ还是用原理的单符号位。

为了加快运算会有辅助电路实现(-x)的补码的运算。

最后一次不需要移位直接根据辅助位和MQ最后一位判断进行相加。从而让乘数的符号位也参数运算中来确定最后结果的符号。

#### 定点数除法运算

进行除法操作时，都是为了找到一位能让商乘除数能最大即余数最小但大于0的值。若除数被除数都是小数，可以同时乘一个数变成整数再运算。

所以可以忽略小数点，每确定一位商进行一次减法，若机器字长为n位，则得到n-1位余数，在余数末尾补0，再确定下一位商0或1，直到确定n位商即可停止。

在运算器的组成时出现一个表格，说明在进行除运算时，ACC保存被除数和余数，MQ保存商，X保存除数。

##### 原码恢复余数法

原码使用恢复余数法进行除运算：

1. 字长若为n+1位，则ACC、MQ、X全部初始化为n位，将被除数的绝对值放入ACC中，X放入除数的绝对值，MQ初始化为全0。
2. 将MQ的最右边的一位当做当前除运算位，让其进行除运算，运算规则是，默认商1，ACC-=X，即x的补码要加上除数的绝对值的负值的补码（减法都由补码的加法实现），判断是否有误。若结果高位为0则无误，高位为1则有误，错误则商改为0，并恢复余数，ACC加上X中除数的补码。
3. 将ACC和MQ的数据连接在一起，全部逻辑左移一位，MQ数据低位补0，MQ最高位的0移到ACC的最低位。将ACC的最高一位抛弃。若是第i轮逻辑左移，则MQ的后i位是当前计算的商的结果。
4. 从步骤二开始重复，字长若为n+1位，则左移n次，上商n+1次，直到MQ中全部是计算结果，则停止计算。此时MQ中保存商，ACC中保存左移n位的余数值，真正的余数应该是结果再乘上2的-n次方。
5. 定点小数的小数位隐藏在符号位后面第一位，定点正数的小数位隐藏在最后一位后。
6. 将两个符号位的异或结果赋值给商最高位。

**例题** 设机器字长为5位（含一位符号位），x=0.1011，y=0.1101，采用原码恢复余数法求x/y。

其中x就是+0.1011，而y就是+0.1101。先抛去符号位，就得到01011和01101两个数据。然后求出y绝对值的补码：01101和-y绝对值的补码：10011。

将MQ、ACC、X都初始化为五位存储单元。将被除数01011放入ACC中，将除数01101放入X中，商初始化为00000。

手算时每位商取0/1是通过判断当前余数和除数的大小确定的。而机器实现时就要通过ALU判断是ACC中的数更大还是X中的数更大，如果ACC的更大就商1，若X的更大就商0。

第一位默认商1，ACC-=X，ACC的01011和X的10011（X实际值的负值的补码）输入ALU进行加操作01011+10011=11110，返回给ACC，此时发现代表符号的最高位为1，代表出现了负数，就表明之前的商出错了，所以重新确定商为0，ACC要恢复余数，从而再加上y的补码：11110+01101=01011。

第一位的商计算完后需要进行计算，错位相除，所以同乘法一样，ACC和MQ的值都要逻辑左移一位，低位补0，所以MQ由00000还是变为00000，MQ的最高位的0移到ACC最低为，ACC最高位丢弃，由01011变成10110。

然后第二位默认商1，同样ACC-=X，10110+10011=01001，将这个值赋给ACC，发现符号位为0，代表正，商就没有问题，MQ为00001。

再次逻辑左移一位，MQ由00001变为00010，ACC由01001变为10010。

第三位默认商1，同样ACC-=X，10010+10011=00101，商没有问题，MQ为00011。

再次逻辑左移一位，MQ由00011变为00110，ACC由00101变为01010。

第四位默认商1，同样ACC-=X，01010+10011=11101，高位为1，商应该为0，MQ变为00110，ACC恢复余数：11101+01101=01010。

再次逻辑左移一位，MQ由00110变为01100，ACC由01010变为10100。

第五位默认商1，同样ACC-=X，10100+10011=00111，高位为0，商没有问题，MQ为01101。

此时计算结束，商为01101，余数为00111。

##### 原码加减交替法

因为恢复余数很麻烦，所以会考虑是否不用恢复余数，直接进行运算得到后面的结果。

假如令原始值为x，原始值加上-y绝对值的补码结果为a，y绝对值的补码为b，按恢复余数法，a这个余数是一个负值，所以要加上b即a+b变成原始值a+b=x，这时候商0，然后计算下一个商，余数a+b左移一位，即(a+b)×2=2a+2b，这时候商1看看结果是否正确，即2a+2b要减去y绝对值的补码（等价于加上-y绝对值的补码）2a+2b-b=2a+b。

所以如果得到了一个负的余数a，可以直接转换到2a+b这个结果，即直接左移一位余数再加上除数的补码就可以得到结果。

这就是加减交通法或不恢复余数法。

从而恢复余数法就是当余数为负时商0,并+|除数|，再左移，再-|除数|，而加减交替法是当余数为负时商0，并左移，再+[除数|，若余数为正时商1，并左移，再-|除数|。

值得注意的是，若在最后一步余数为负，需要商0，并加上除数的补码得到正确余数。

<span style="color:orange">注意：</span>在定点小数运算时，商只能是小数而不能是整数，所以被除数一定要小于除数，机器判断标准是看第一步计算的商，若第一步计算的商是1则代表结果大于1，机器就会报错。

##### 补码加减交替法

+ 符号位参与运算。
+ 被除数/余数、除数采用双符号位。
+ 被除数和除数同号，则被除数减去除数，异号则被除数加上除数。
+ 余数和除数同号，商1，余数左移一位减去除数;
+ 余数和除数异号，商0，余数左移一位加上除数。
+ 重复n次。
+ 最后一次计算时末位商横置为1，处理简单，而且精度误差也不会超过$2^{-n}$。

除法类型|符号位参与运算|加减次数|移位方向|移位次数次数|上商和加减原则|说明
:------:|:------------:|:------:|:------:|:----------:|:-----------:|:---:
原码加减交替法|否|N+1或N+2|左|N|余数的正负|若最终余数为负，需恢复余数
补码加减交替法|是|N+1|左|N|余数和除数是否同号|商末位恒置1

#### 定点数强制类型转换

+ 无符号数与有符号数：不改变数据内容，只改变解释方式。
+ 长整数转短整数：高位截断，保留低位。
+ 短整数转长整数：符号扩展。

#### 定点数数据存储与排列

+ 数据最左边的高位就是最高有效字节MSB。
+ 数据最右边的低位就是最低有效字节LSB。
+ 大端模式：将MSB存到最低地址，LSB存在最高地址。便于人类阅读。
+ 小端模式：将MSB存到最高地址，LSB存在最低地址。便于机器读取。
+ 边界对齐：
  + 现代计算机通常是按字节编址即每个字节对应一个地址通常。也支持按字、按半字、按字节寻址。
  + 假设存储字长为32位，则1个字=32bit，半字=16bit。每次访存只能读/写1个字。
  + 字地址转换为字节地址，只用逻辑左移两位就可以了，即乘以4，因为字长为32，而字节长8。
  + 使用边界对齐方式会让每个数据都能一次性读完而不用跨行读取，多余的空间用0填充。

## 浮点数

指小数点的位置不固定，如使用科学计数法，如9.694E2。

### 浮点数表示

#### 阶码与尾数

+ 定点数能表示的数字范围有限，但我们不能无限制地增加数据的长度。
+ 类似科学计数法，分为阶码和尾数两个部分，阶码反映数值大小、表示范围、小数点实际位置，尾数反映精度。
+ 对于二进制的浮点数，阶码是常用补码或移码表示的定点整数，而尾数是常用原码或补码表示的定点小数。
+ 若阶码的真值为$E$，尾数的真值为$M$，则浮点数的真值为$N=r^E\times M$，其中r为阶码的底，即基数，一般为2。

**例题** 若阶码和尾数都使用补码表示，求对应真值：a=0,01;1.1001。

a的阶码为0,01，是正数，所以补码与原码一样，从数值来看就是+1。而尾数1.1001代表负数，补码为反码加1，所以真值为1,0110+1=1,0111，即=-(0.25+0.125+0.0625)。所以a的真值就是2×(-0.0111)=-0.111=-0.875（相当于乘2左移一位）。

#### 尾数规格化

+ 左规：出现下溢需要左规，即若尾数的高位是无效值（即为0）则会丧失精度，所以我们需要尽可能将尾数多保存一些1，从而让最高位为1。所以需要让数值左移，让小数点右移，尾数算术左移n位，阶码减n，直到尾数最高位是有效值。
+ 右规：出现上溢需要右规，规范要求小数点要在第一个非0的数据右边，如果小数点前有超过1个有效位，则需要将数值右移，小数点左移，尾数算术右移n位，阶码加n，直到小数点在尾数最高位的右边。

**例题** a=010;00.1100，b=010;00.1000，求a+b的值。

已知分号前面的是阶码，后面是尾数，所以a和b都是2的010=2次幂。

由尾数的00代表a和b都是双符号位表示且都是正数。

所以a=2×2×00.1100，b=2×2×00.1000，则a+b=2×2×00.1100+2×2×00.1000=2×2×(00.1100+00.1000)=2×2×01.0100。

因为使用双符号位表示时，00代表正号，11表示负号，01时，称为上溢，为10时，称为下溢，此时结果为01，表示出现了上溢，这时候就需要右规。

阶码加一，变成2的三次方，尾数右移一位=2×2×2×00.1010。最后结果就是011;01010。

规格化浮点数的特点：

1. 用原码表示的尾数进行规格化，最高位数值一定为1：
   + 正数为0.1××...×的形式，其最大值表示为0.11...1；最小值表示为0.10...0。
   + 尾数的表示范围为$\dfrac{1}{2}\leqslant M\leqslant(1-2^{-n})$。
   + 负数为1.1××...×的形式，其最大值表示为1.10...0;最小值表示为1.11...1。
   + 尾数的表示范围为$-(1-2^{-n})\leqslant M\leqslant\dfrac{1}{2}$。
2. 用补码表示的尾数进行规格化，符号位与最高位数值一定相反：
   + 正数为0.1××...×的形式，其最大值表示为0.11...1；最小值表示为0.10...0。
   + 尾数的表示范围为$\dfrac{1}{2}\leqslant M\leqslant(1-2^{-n})$。
   + 负数为1.0××...×的形式，其最大值表示为1.01...1；最小值表示为1.00..0。（负数的补码1.0xx...x取反后就是1.1xx...x）
   + 尾数的表示范围为$-1\leqslant M\leqslant-(\dfrac{1}{2}+2^{-n})$。（补码中强制规定1.00...0就代表-1）

**例题** 若某浮点数的阶码、尾数用补码表示，共4+8位：0,110;1.1110100，如何规格化？

只需要对尾数部分处理，由于负数的补码是1.0开头，而这时是1.1开头，所以必须变成1.0。

补码算术左移低位补0，补码算术右移，高位补1。如果是算术右移，则会一直补1，而无法变成1.0开头，所以要使用算术左移，移动三位得到1.0100000，同时阶码减3变为3，最后规格化结果为0,011;1.0100000。

对于浮点数，上溢和下溢有正负之分：负上溢<负数区<负下溢<0<正下溢<正数区<正上溢。

### IEEE 754标准

IEEE 754标准就是浮点数标准，为了解决计算机中阶码、尾数使用什么码来表示，各取多少位的问题。

#### 移码定义

+ 移码的定义其实=真值+偏置值，一般取$2^{n-1}$，这时候移码才等于补码符号位取反，若移码采取其他方案则没有这个特点。
+ 在IEEE 754标准中，规定移码的偏置值不再是128而是127，即$2^{n-1}-1$。
+ 从而真值-128的移码为-1000 0000+0111 1111=1111 1111，-127的移码为0000 0000，0的移码为0111 1111，127的移码为1111 1110。

#### IEEE 754定义

+ 分为数符（表示数值正负号）、阶码（用移码表示）、尾数（用原码表示，且默认最高位为1，实际尾数位都要加1）。
+ 标准中会将全0的-127和全1的-128做特殊的用途，所以短浮点数的真值正常范围是-126到127。

英文类型|中文类型|数符位|阶码位|尾数位|总位数|十六进制偏置值|十进制偏置值
:------:|:------:|:-----:|:----:|:----:|:----:|:------------:|:----------:
float|短浮点数|1|8|23|32|7FH|127
double|长浮点数|1|11|52|64|3FFH|1023
long double|临时浮点数|1|15|64|80|3FFFH|16383

+ 令数符为$S$，阶码为$E$，尾数为$M$。
+ 规格化的短浮点数的真值为$(-1)^S\times 1.M\times2^{E-127}$。
+ 规格化的长浮点数的真值为$(-1)^S\times 1.M\times2^{E-1023}$。

**例题** 将十进制数-0.75转换为IEEE 754的单精度浮点数格式表示。

将-0.75D首先转换为二进制为-0.11B，然后规格化变为-1.1B×0.1B。其中阶码为-1（0.1B就是代表2的负一次方）。

因为是负数，所以数符为1，尾数部分应该是将1.1B截断隐含的最高位1，所以应该用0.1B表示，即.100...。

由于阶码为-1，所以移码=阶码真值+偏置量=-1+111 1111=0111 1110。

所以最后就是1 0111 1110 1000 0000 0000 0000 0000 000。

**例题** IEEE 754的单精度浮点数C0 A0 00 00H的值是多少。

首先是16进制转二进制，每一个十六进制位转换为四个二进制位。所以得到1100 0000 1010 0000 0000 0000 0000 0000。

根据IEEE 754标准，将32位分割为数符、阶码、尾数三个部分：数符为1，阶码为100 0000 1，尾数为010 0000 0000 0000 0000 0000。

由于尾数最高位隐含为1，所以尾数的真值为1.010 0000 0000 0000 0000 0000。

由于数符为1，则这个数表示的是一个负数。

由于阶码由移码表示，所以看作无符号数就是129D，而单精度浮点数的偏移量为127D，所以移码真值=移码-偏置量=1000 0001-0111 1111=0000 0010=2。

所以浮点数的真值为-1.01B×2×2=-1.25×4=-5。

#### IEEE 754取值范围

格式|规格化的最小绝对值|规格化的最大绝对值
:--:|:----------------:|:---------------:
单精度|$E=1$，$M=0$：$1.0×2^{1-127}=2^{-126}$|$E=254$，$M=.11...1$：$1.11...1×2^{254-127}=2^{127}×(2-2^{23})$
双精度|$E=1$，$M=0$：$1.0×2^{1-1023}=2^{-1022}$|$E=2046$，$M=.11...1$：$1.11...1×2^{2046-1023}=2^{1023}×(2-2^{-52})$

+ 对于规格化短浮点数，只有$1\leqslant E\leqslant 254$时，$(-1)^S\times 1.M\times2^{E-127}$。
+ 当阶码$E$为全0，即应该为-127D，而尾数$M$不全为0时，表示非规格化小数$\pm(0.\textrm{xx...x})_2\times2^{-126}$。（此时最高位就不默认为1了，阶码固定设置为-126）。
+ 当阶码$E$为全0，即应该为-127D，而尾数$M$全为0时，表示真值$\pm0$，正负看数符。
+ 当阶码$E$为全1，即应该为-128D，而尾数$M$全为0时，表示无穷大$\pm\infty$，正负看数符。
+ 当阶码$E$为全1，即应该为-128D，而尾数$M$不全为0时，表示非数值NaN（Not a Number）。如果非法操作如0/0等就会使用到。

### 浮点数运算

#### 科学计数法加减运算

1. 对阶：阶数小的向阶数更大的对齐。
   + 因为计算机内部，尾数是定点小数，小数点位置不会变，改变的只是数据的相对位置。
   + 若是阶数大的向阶数小的对齐，则阶数大的尾数值会变大，需要对尾数进行算术左移，若内存不够大很可能会引起最高有效位丢失。
   + 若是阶数小的向阶数大的对齐，则阶数小的尾数值会变小，需要对尾数进行算术右移，若内存不够大很可能会引起最后几位丢失，即精度下降，影响较小。
2. 尾数加减：阶数不变，对尾数进行相加减。
3. 规格化，将数据变为整数部分为0到9的数据：
   + 当尾数加减结果的第一位为0时需要左规，直到第一位不为0。
   + 当结果的整数部分大于等于10需要右规，直到整数部分只有一位。
4. 舍入：计算机中由于尾数的比特位有限，所以需要舍弃尾数的低位。舍入方法有：
   + 直接去除。
   + 非0进1。
   + 四舍五入。
5. 判溢出：若运算后阶码超过规定范围则溢出。尾数的溢出未必会导致整体溢出，可以通过第三四步来修补，但是阶码溢出一定会整体溢出。

**例题** 计算$9.85211\times10^{12}+9.96007\times10^{10}$的值并保留四舍五入六位有效尾数。

第一步进行对阶，变成$9.85211\times10^{12}+0.0996007\times10^{12}$。

第二步进行相加得到$9.9517107\times10^{12}$。

第三步由于整数部分为9，所以不需要规格化。

第四步因为只能保留六位有效尾数，所以保留9.95171，因为后一位是0，所以不进位为最后答案。

第五步因为阶码无论是10或12都是两位，所以肯定没有溢出。

#### 浮点数加减运算

浮点数的加减基本上与科学计数法的加减一致。基本上浮点数的运算不可能使用IEEE 754的标准，因为位数太长不好计算。

**例题** 已知十进制数$X=-5/256$，$Y=+59/1024$，按机器补码浮点运算规则计算$X-Y$，结果用二进制表示，浮点数格式如下︰阶符取2位，阶码取3位，数符取2位，尾数取9位。

首先要将十进制的真值转换为二进制原码。因为不是IEEE 754标准，所以小数不用转换为1.xxx的格式，转成0.xxx的格式就可以了：$5D=101B$，$1/256=2^{-8}$，所以$X=-101\times2^{-8}=-0.101\times2^{-5}=-0.101\times2^{-101B}$。然后$59D=11 1011B$，$1/1024=2^{-10}$，从而$Y=+11 1011\times2^{-10}=0.111011\times2^{-4}=0.111011\times2^{-100B}$。

X的阶码为-101，转换为补码表示为1011，由于使用双符号位，所以变成11011；X的尾数为-0.101，补码表示为1.011，由于双符号位，所以为11.011，尾数取9位，所以拓展为11.0110 0000 0。所以X就是11011,11.011000000。

同理Y的阶码为-100，转换为补码表示为1100，双符号位所以变为11100；Y的尾数为0.111011，补码表示为0.111011，使用使用双符号位为00.111011，拓展为9位得到00.111011000.所以Y就是11100,00.111011000。

然后是阶数对齐，小阶向大阶靠拢。首先求阶差：11011-11100=11011+00100=11111=11,001=-1D。所以X的阶数比Y的阶数小一。所以对X算术右移，负数高位补1，阶码加一，从而由11011,11.011000000变为了11100,11.101100000。即变为了$-0.0101×2^{-100B}$。

然后是尾数加减，所以Y的尾数需要变成其负值的补码，方法是对尾数包括符号位全部取反，然后末尾加1，所以-Y=11100,11.000101000。进行相加得到10.110001000。这时候代表出现上溢出（用二进制计算尾数变成-1.001111，由于定点小数无法表示绝对值大于等于1的数，所以上溢）。

第三步规格化，因为使用双符号位，所以正好能补救计算结果的上溢，可以通过右规的方式规格化。所以将10.110001000算术右移，将符号位的0以及后面的数据全部右移一位，符号位补成11，得到11.011000100。然后阶码由于右移而加一，最后为11101,11.011000100。

第四步舍入，由于第三步右移抛弃的是0，所以没有丧失精度，就不需要舍入。

第五步判溢出，11101加1后等于11110，符号位都是11，所以没有溢出。

最后真值为11101,11.011000100。即$2^{-3}\times(-0.1001111)_2$。

舍入的方法：

+ “0”舍“1”入法：类似于十进制数运算中的“四舍五入”法，即在尾数右移时，被移去的最高数值位为0，则舍去;被移去的最高数值位为1，则在尾数的末位加1。这样做可能会使尾数又溢出，此时需再做一次右规。
+ 恒置“1”法：尾数右移时，不论丢掉的最高数值位是“1”还是“O”,都使右移后的尾数末位恒置“1”。这种方法同样有使尾数变大和变小的两种可能。

假如加减的结果为11100,10.110001011，因为尾数符号位为10代表溢出了，所以需要规格化。

使用0舍1入法，将尾数整体右移，并将符号位的低位移到尾数高位，阶码加移位数，符号位修改，从而变成了11101,11.011000101，溢出1，最高位为1，使用0舍1入时需要加1，从而变成11101,11.011000110。（假如尾数为全1，则加1后又会高位溢出，还需要一次右规）。恒置1法的答案是一样的。

#### 浮点数强制类型转换

类型|16位机器|32位机器|64位机器
:--:|:------:|:------:|:------:
char|8|8|8
short|16|16|16
int|16|32|32
long|32|32|64
long long|64|64|64
float|16|32|32
double|64|64|64

无损转换：

+ char→int→long→double。
+ float→double。

由于定点数和浮点数不同，浮点数使用阶码+尾数的存储方式存储，所以定点数数值精度看位长就可以了，而浮点数数值精度看尾数长度，按IEEE 754标准有一个隐含的高位1，所以double尾数长度为53位。对于32位机器long是32位，所以转换到double的53位没有损失，而对于64位机器long是64位，double还是53位，这时候转换就会产生损失了。

int与float转换

+ int：表示整数，范围$[-2^{31},2^{31}-1]$，有效数字32位。
+ float：表示整数及小数，范围$\pm[2^{-126},2^{127}×(2-2^{-23})]$，有效数字23+1=24位。
+ int→float：可能损失精度。
+ float→>int：可能溢出及损失精度。

## 算术逻辑单元

即运算器中的ALU。

### 原理

#### ALU结构

+ 输入信号有一个操作数的输入口，输出信号有一个运算结果输出口，旁边还有一个控制单元CU发出的控制信号接口，会输入指令译码。
+ 机器字长就是指ALU可以同时处理多长的数据。为了保存结果，寄存器的字长与机器字长相等。

#### 逻辑运算

+ 与可以用*表示，如A\*B。
+ 或可以用+表示，如A+B。
+ 优先级上类比乘法加法，与优先于或。
+ 具有类似的分配律结合律。
+ 与非：先与后非。
+ 或非：先或后非。
+ 异或：相异为1，相同为0。
+ 同或：相同为0，相异为1。

### 加法器实现

#### 一位全加器

+ 一位全加器FA中，令被加数为$A$，被加数从低到高的位数为$A_i$，令加数为$B$，被加数从低到高的位数为$B_i$，令来自低位$i-1$的进位为$C_{i-1}$，本位的和为$S_i$。$S_i=A_i+B_i+C_{i-1}$。
+ 输入$A_i$、$B_i$、$C_{i-1}$，输出$S_i$、$C_i$。
+ 输入中有奇数个1时为1（异或）：$S_i=A_i\oplus B_i\oplus C_{i-1}$。
+ 输入中至少两个1才会高位进1，一种情况是两个本位都是1，另一种情况是有一个是1且来自低位的进位是1：$C_i=A_iB_i+(A_i\oplus B_i)C_{i-1}$。

#### 串行加法器

+ 基于一个一位全加器，一位一位串行进入加法器运算。对比一位全加器，需要保存一个进位触发器用来保存进位位，进位触发器初始化值为0。
+ 如果操作数长n位加法就要务n次进行，每次产生一位和，并且串行逐位地送回奇存器。

#### 串行进位并行加法器

+ 把n个全加器串接起来，就可进行两个n位数的相加。前一个全加器的进位输出将作为下一个全加器的输入。
+ 串行进位又称为行波进位，每一级进位直接依赖于前一级的进位，即进位信号是逐级形成的。所以不可能比单纯的串行全加器快很多。

#### 并行进位并行加法器

+ 由于$S_i=A_i\oplus B_i\oplus C_{i-1}$，所以计算的重点是计算$C_i$，而$C_i=A_iB_i+(A_i\oplus B_i)C_{i-1}$，通过递归可以不断展开：$C_i=A_iB_i+(A_i\oplus B_i)(A_{i-1}B_{i-1}+(A_{i-1}\oplus B_{i-1})C_{i-2})$一直可以递归到$C_0$，而$A_i$、$B_i$、$C_0$都是一开始可以知道的，所以第$i$位向更高位的进位$C_i$可根据被加数、加数的第1到$i$位,再结合$C_0$即可确定。
+ 将$G_i=A_iB_i$，$P_i=A_i\oplus B_i$，所以式子得到化简：$C_i=A_iB_i+(A_i\oplus B_i)C_{i-1}=G_i+P_iC_{i-1}$。
+ 所以$C_1=G_1+P_1C_0$，$C_2=G_2+P_2C_1=G_2+P_2G_1+P_2P_1C_0$，$C_3=G_3+P_3C_2=G_3+P_3G_2+P_3P_2G_1+P_3P_2P_1C_0$……所以一直到最后面每个$C_i$都可以用对应的$G_i$和$P_i$计算，这时候$C_i$可以不用递归来计算，可以用一开始就知道的$P_i$、$G_i$和$C_0$计算得到，从而这时候每一位的计算都可以一开始就同时进行了而不用依赖前面的计算。
+ 各级进位信号同时形成，又称为先行进位、同时进位。
+ $G_i$称为进位产生函数，因为$G_i$是通过$A_i$和$B_i$相与，只有同时为1才会产生1。
+ $P_i$称为进位传递函数，$P_i$是通过$A_i$和$B_i$异或，实际上$P_i$为1时，只有此时$C_{i-1}$才能为1，否则为0。

#### 单级先行进位加法器

+ 称为组内并行、组间串行进位方式。
+ 由于逻辑表达式越长就代表电路实现越复杂，所以一般会最多用4个FA和一些新的线路、运算逻辑组成一个运算单元进行串联进位计算。
+ 组内的信息可以并行同时得到，但是组件信息需要串行进位。这时虽然实现简单，但是效率对比并行进位并行加法器还是下降了。

#### 多级先行进位加法器

+ 多级先行进位方式，又称为组内并行、组间并行进位方式。
+ 为了解决这个问题按照并行进位并行加法器的思路继续对每一组的数据进行计算。
+ 令$G_1^*=G_4+P_4G_3+P_4P_3G_2+P_4P_3P_2G_1$为组进位产生函数，$P_1^*=P_4P_3P_2P_1$为组进位传递函数。一开始输入就能确定，所以这些都是一开始就能确定的。
+ 所以$C_4=G_1^*+P_1^*C_0$，$C_8=G_2^*+P_2^*C_4=G_2^*+P_2^*G_1^*+P_2^*P_1^*C_0$，$C_{12}=G_3^*+P_3^*C_8=G_3^*+P_3^*G_2^*+P_3^*P_2^*G_1^*+P_3^*P_2^*P_1^*C_0$……
+ 所以4位BCLA只要输出$G_i$和$P_i$就可以在计算机中计算得到$C_{4i}$了。
