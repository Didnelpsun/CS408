# 数据表示与运算

## 数制与编码

### 进位计数制

+ 真值：符合人类习惯的数字。
+ 机器数：数字实际存到机器里的形式，正负号需要被“数字化”。

#### 十进制

+ 符号反映权重。
+ 符号所在位置也反映权重。
+ $K_nK_{n-1}\cdots K_2K_1K_0K_{-1}K_{-2}\cdots K_{-m}=K_n\times10^n+K_{n-1}\times10^{n-1}\cdots K_2\times10^2+K_1\times10^1+K_0\times10^0+K_{-1}\times10^{-1}+K_{-2}\times10^{-2}\cdots K_{-m}\times10^{-m}$。

#### R进制

+ 基数：每个数码位所用到的不同符号的个数，r进制的基数r。
+ R进制转换为十进制：$K_nK_{n-1}\cdots K_2K_1K_0K_{-1}K_{-2}\cdots K_{-m}=K_n\times r^n+K_{n-1}\times r^{n-1}\cdots K_2\times r^2+K_1\times r^1+K_0\times r^0+K_{-1}\times r^{-1}+K_{-2}\times r^{-2}\cdots K_{-m}\times r^{-m}=\sum_{i=-m}^nK_i\times r^i$。
+ 二进制：0、1。
+ 使用二进制的原因：
  1. 可使用两个稳定状态的物理器件表示。
  2. 0，1正好对应逻辑值假、真。方便实现逻辑运算。
  3. 可很方便地使用逻辑门电路实现算术运算。
+ 八进制：0、1、2、3、4、5、6、7。可以用下标方式表明，也可以用结束的O或开头的0表示。如$(1643)_8$、01643、1643O。
+ 十进制：0、1、2、3、4、5、6、7、8、9。可以用下标方式表明，也可以用结束的D表示，如$(1643)_{10}$、1643D。
+ 十六进制：0、1、2、3、4、5、6、7、8、9、A、B、C、D、E、F。可以用下标方式表明，也可以用结束的H或开头的0x表示。如$(1643)_{16}$、0x1643、1643H。

#### 二进制与八进制或十六进制转换

+ 二进制转换八进制：三位一组，每组转换成对应的八进制符号，整数部分不全则最高位用0填充，小数部分不全则最低位用0填充。
+ 二进制转换十六进制：四位一组，每组转换成对应的十六进制符号，整数部分不全则最高位用0填充，小数部分不全则最低位用0填充。
+ 八进制转换二进制：每位八进制对应的三位二进制。
+ 十六进制转换二进制：每位十六进制对应的四位二进制。

十进制|二进制|八进制|十六进制
:---:|:----:|:----:|:-----:
0|0000|0|0
1|0001|1|1
2|0010|2|2
3|0011|3|3
4|0100|4|4
5|0101|5|5
6|0110|6|6
7|0111|7|7
8|1000|10|8
9|1001|11|9
10|1010|12|A
11|1011|13|B
12|1100|14|C
13|1101|15|D
14|1110|16|E
15|1111|17|F

#### 十进制转换为R进制

+ 整数部分需要使用除基取余法，小数部分需要使用乘基取整法。
+ 对于十进制数，需要把它分为整数部分和小数部分两个部分进行处理。
+ 已知R进制转换为十进制的方法：$K=K_nK_{n-1}\cdots K_2K_1K_0K_{-1}K_{-2}\cdots K_{-m}=K_n\times r^n+K_{n-1}\times r^{n-1}\cdots K_2\times r^2+K_1\times r^1+K_0\times r^0+K_{-1}\times r^{-1}+K_{-2}\times r^{-2}\cdots K_{-m}\times r^{-m}$。
+ 分为整数部分和小数部分：$K=N+F$。
+ 首先把整数拿出来得到$N=K_n\times r^n+K_{n-1}\times r^{n-1}\cdots K_2\times r^2+K_1\times r^1+K_0\times r^0$。
+ 对这个数除以基数$r$，得到$X=K_n\times r^{n-1}+K_{n-1}\times r^{n-2}\cdots K_2\times r^1+K_1\times r^0$，这时候就会得到一个余数$K_0$。所以$N=rX+K_0$，这时候就能算出$K_0$这个位数了。
+ 同理再将得到的商$X$同样除以$r$，就能得到$K_1$，所以不断递归就会得到整数部分所有的$K_i$。
+ 得到的$K_i$是从低位排到高位。
+ 对于小数部分$F=K_{-1}\times r^{-1}+K_{-2}\times r^{-2}\cdots K_{-m}\times r^{-m}$。
+ 对这个数乘基数$r$，得到$K_{-1}\times r^0+K_{-2}\times r^{-1}\cdots K_{-m}\times r^{-m+1}$，取这个常数$K_{-1}$就是想要的答案。将乘积减去这个整数部分得到后面处理的数据
+ 同理再将得到的数据不断乘基数，就能得到小数部分所有的$K_i$。
+ 得到的$K_i$是从高位排到低位。
+ 将整数和小数合在一起就是最后的结果。
+ 有时候小数会出现无法彻底转换的情况，需要考虑保留多少位。

**例题** 将十进制的75.3转换为二进制并保留三位。

首先将75拿出来，以基数2相除：

75÷2=37……1，37÷2=18……1，18÷2=9……0，9÷2=4……1，4÷2=2……0，2÷2=1……0，1÷2=0……1，这个顺序是从低位到高位的，所以75转换二进制就是1001011。

然后是对小数0.3的处理：

0.3×2=0.6=0+0.6，0.6×2=1.2=1+0.2，0.2×2=0.4=0+0.4，这个顺序是从高位到低位的，所以0.3转换二进制就是0.01。

所以转换最后得到1001011.01。

同理也可以使用拼凑法将数字拼凑成对应的数值。这种方法对于只有整数的数值比较好用。

$2^{12}$|$2^{11}$|$2^{10}$|$2^{9}$|$2^{8}$|$2^{7}$|$2^{6}$|$2^{5}$|$2^{4}$|$2^{3}$|$2^{2}$|$2^{1}$|$2^{0}$|$2^{-1}$|$2^{-2}$|$2^{-3}$
:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:
4096|2048|1024|512|256|128|64|32|16|8|4|2|1|0.5|0.25|0.125

### BCD码

即Binary-Coded Decimal，用二进制编码的十进制。

使用4bit来表示0到9这十个数，而4bit能表示十六个数，所以会冗余六个组合。

#### 8421码

8421码是一种有权码，第1、2、3、4位分别对应8、4、2、1，使用常规的二进制来表示十进制：

0|1|2|3|4|5|6|7|8|9
:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:
0000|0001|0010|0011|0100|0101|0110|0111|1000|1001

如985用8421码表示就是1001 1000 0101。

使用8421码表示的数字进行算术运算的方式是先按照二进制的方式进行运算，若最后结果不在映射表中，即落在没有定义的1010到1111中，就直接加上6（因为有六位无效，所以加上六位跳过无效的位数）从而进一位，多了一段补全0。每个段对应的数值合在一起就是原来的结果。

如5+8=0101+1000=1101=13，不在映射表中，则对1101加6，即计算19，得到1 0011这个值，补齐得到0001 0011，而按照8421码，最高位的0001不再代表权值16，而代表十位的1，而后面是3，从而组合在一起就代表了13。

#### 余三码

在8421码的基础上全部加上三：

0|1|2|3|4|5|6|7|8|9
:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:
0011|0100|0101|0110|0111|1000|1001|1010|1011|1100

余三码因为加上了三，所以每一位的权值映射关系就破坏了，所以这是一种无权码，不能分别对应8、4、2、1的值。

#### 2421码

与8421码一样都是一种有权码，但是映射的方式不同，第1、2、3、4位分别对应2、4、2、1。

0|1|2|3|4|5|6|7|8|9
:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:
0000|0001|0010|0011|0100|1011|1100|1101|1110|1111

### 字符与字符串

#### 英文字符表示

ASCII码，数字英文符号一共128个字符，使用7位就可以表示128个字符，但是通常会高位补0凑足1B：

+ 其中32到126是可印刷字符，其他都是控制或通信字符。
+ 数字：48（0011 0000）到57（0011 1001），后面4位就是数字的8421码。
+ 大写字母：65（0100 0001）到90（0101 1010），前面三位是010，后面五位代表1到26。
+ 小写字母：97（0110 0001）到122（0111 1010），前面三位是011，后面五位代表1到26。

#### 中文字符表示

+ GB 2312-80：1980年推出汉字加符号共7445个表示的字符。中文有两个字节。
  + 区位码：94个区，每个区94位。
  + 国标码：为了中文字符表示与英文字符表示共存，防止GB编码被认为是ASCII码的0到32位的控制或通信字符，所以在94区94位的基础上还要各自加上32，即20H，防止信息交换时冲突。
  + 汉字内码：国标码只能用于信息传输，而如果是存储在计算机上，由于前128位已经被ASCII码占用了，所以在国标码的基础上再各自加80H（128），从而计算机识别字符时，看到0到128之间的就能辨认出是ASCII码，大于128的就是GB码。因为ASCII码高位是0，而GB码是两个字节且高位都是1。
+ 输入编码：如拼音、五笔等供人类输入，输入编码输入后转换为国标码再转成汉字内码存储。
+ 汉字字形码：把汉字输出成汉字的样子。

#### 字符串

+ 若一个计算机按字节编址，则每个地址对应Q1B。
+ 很多语言中将'\0'即00H作为字符串结束标志。
+ 大端模式：将数据的最高有效字节存放在低地址单元中。
+ 小端模式：将数据的最高有效字节存放在高地址单元中

### 数据校验

现在计算机组成原理不考数据校验，但是只是内容移动到计算机网络里。具体可以看计算机网络。

+ 校验原理就是将更多字节映射到有限个合法状态，从而有多个冗余的非法状态，更容易判断是否非法。
+ 码字：由若干位代码组成的一个字。
+ 两个码字间的距离：将两个码字逐位进行对比，具有不同的位的个数。
+ 码距：一种编码方案可能有若干个合法码字，各合法码字间的最小距离。
+ 当码距=1时，无检错能力；当码距=2时，有检错能力；当码距≥3时，若设计合理，可能具有检错、纠错能力。

#### 奇偶校验码

+ 奇校验码：整个校验码（有效信息位和校验位）中为1的个数为奇数。
+ 偶校验码：整个校验码（有效信息位和校验位）中为1的个数为偶数。
+ 偶位数出错时无法校验。
+ 对原始数据进行异或（模2加）运算，得到的结果即为校验位。
+ 对所有数据进行异或运算，结果为0表示未出错，为1代表出错。
+ 码距为2，只能检错，不能纠错。

#### 海明码

+ 将信息分组进行偶校验，从而得到多个校验位，从而能携带多种状态信息。
+ 设信息位为$n$，校验位为$k$，从而能表达$2^k$中状态，而信息位+校验位一共$n+k$位，只错一位的状态种数加上一种正确状态为$n+k+1$，从而$2^k\geqslant n+k+1$。
+ 令信息位为$D_i$，校验位为$P_j$，总海明码为$H_k$，其中校验位$P_j$必须放在海明码$H_k$位号位$2^{j-1}$的位置上，即1、2、4、8等。
+ 如果没有发生错误，则每一位进行检错都是0，若出现1，则说明出错。
+ 为了检测是一位错还是两位错，一般会加上一个全校验位，对整体进行偶校验。
+ 具有一位和两位的纠错检错能力，三位以上则不能纠错。

n|1|2-4|5-11|12-26|27-57|58-120
:-:|:-:|:-:|:-:|:-:|:--:|:----:
k|2|3|4|5|6|7

#### 循环冗余校验码

+ 即CRC码，其思想是：
  1. 数据发送、接受方约定一个“除数”。
  2. K个信息位+R个校验位作为“被除数”，添加校验位后需保证除法的余数为0。
  3. 收到数据后，进行除法检查余数是否为0。
+ 得到CRC码的方法：
  1. 确定K和R以及生成多项式对应的二进制码。其中R位生成多项式的最高次幂数。
  2. 将信息码左移R位，低位补0。
  3. 使用模二除法。
  4. 余数就是校验位，只比多项式少一位。
  5. 对全部数据进行多项式除，余数为0代表无措。
  6. 若余数不为0，则出错。
  7. 若$n$个信息位，$k$个校验位，若生成多项式得当，且$2^k\geqslant n+k+1$，则CRC码可纠正一位错。实际上基本上不怎么用来纠错。

## 定点数

指小数点的位置不变，使用常规计数法，如96.94。

### 定点数表示

#### 无符号数

+ 整个机器字长的全部二进制位均为数值位，没有符号位，相当于数的绝对值。
+ $n$位无符号数表示范围为$[0,2^n-1]$。
+ 无符号数不涉及小数。

#### 有符号数

+ 定点整数：最高一位是符号位，0是正，1是负，小数点位置一般隐含在最后。
+ 定点小数：最高一位是符号位，0是正，1是负，小数点位置隐含在符号位后面。
+ 数值部分也称为尾数。要保存一个非整数需要保存定点整数与定点小数两个部分。

#### 原码

+ 原码：用尾数表示真值的绝对值，符号位“0/1”对应“正/负”。
+ 若机器字长为n+1位，则尾数占n位。
+ 若使用1B来保存数值，则+19D就是0001 0011，-19D就是1001 0011。
+ 有时1001 0011会写为1,0010011，其中的逗号只是为了标注正负号，本身是不存在的。
+ 若未指明机器字长，则最开头的多个0可以省略。如1001 0011可以表示为1,10011。
+ 同理小数也可以使用1.11表示，这是指-0.11。
+ 若机器字长$n+1$位，则原码整数的表示范围是$[-(2^n-1),2^n-1]$。
+ 若机器字长$n+1$位，则原码小数的表示范围是$[-(1-2^{-n}),1-2^{-n}]$。
+ 原码表示时真值0有+0和-0两种形式。

#### 反码

+ 反码：若符号位为0，则反码与原码相同，若符号位为1，则数值位全部取反。
+ 可以转换为原码再取反。
+ 若机器字长$n+1$位，则反码整数的表示范围是$[-(2^n-1),2^n-1]$。
+ 若机器字长$n+1$位，则反码小数的表示范围是$[-(1-2^{-n}),1-2^{-n}]$。
+ 反码表示时真值0有+0和-0两种形式。
+ 反码只是由原码转换为补码的一个中间态，实际上并没有作用。

#### 补码

+ 补码：若符号位为0，则反码与原码相同，若符号位为1，则数值位全部取反再加一，即反码加一。
+ 补码表示时真值0只有一种形式0000 0000。
+ 多出来的一种形式1000 0000表示$-2^7$和$-1$。
+ 若机器字长$n+1$位，则补码整数的表示范围是$[-2^n,2^n-1]$。
+ 若机器字长$n+1$位，则补码小数的表示范围是$[-1,1-2^{-n}]$。
+ 将负数补码转回原码的方法相同：尾数取反，末位加一。补码的补码就是原码。
+ 如果已知一个数值的补码，那么求这个值的负数的补码就是全部位取反，末位加一。
+ 如果已知一个负数的补码，那个求这个值的原码就是数值位取反再加一，或是负数补码中，最右边的1以及右边不变，最右边的1的左边取反。

#### 移码

+ 补码的基础上将符号位取反。
+ 移码只能用于表示整数，而不能表示定点小数。
+ 若机器字长$n+1$位，则移码整数的表示范围是$[-2^n,2^n-1]$。
+ 若机器字长$n+1$位，则移码小数的表示范围是$[-1,1-2^{-n}]$。
+ 移码由于负数的最高位为0，正数的最高位为1，从而能更方便对比大小。

机器数|无符号数|原码|反码|补码|移码
:----:|:------:|:--:|:--:|:--:|:--:
0000 0000|0|+0|+0|0|-128
0000 0001|1|+1|+1|+1|-127
...
0111 1101|125|+125|+125|+125|-3
0111 1110|126|+126|+126|+126|-2
0111 1111|127|+127|+127|+127|-1
1000 0000|128|-0|-127|-128|0
1000 0001|129|-1|-126|-127|1
1000 0010|130|-2|-125|-126|2
...
1111 1101|253|-125|-2|-3|125
1111 1110|254|-126|-1|-2|126
1111 1111|255|-127|-0|-1|127

#### 补码作用

+ 原码在计算时由于首位表示的是符号，所以需要考虑将加减运算转换的问题，而减法实现起来比较困难，就考虑是否可以将减法通过加法来实现。
+ 由于计算机码操作若最高位进一就被舍弃，则天然是进行模运算，所以可以通过数学模运算来实现机器码的运算。
+ 带余除法：设$x,m\in Z$，$m>0$则存在唯一决定的整数$q$和$r$，使得$x=q\cdot m+r\,,0\leqslant r<m$。
+ 若两个数绝对值之和为模，则互为补数。即模-数的绝对值=数的补数（正数）。从而数加上数的补数就得到了模。
+ 补码就是正数不变，负数取模的结果。如-66=- 0100 0010，而(1000 0000 - 0100 0010)mod(1111 1111)=1011 1110，也就是其补码。
+ 从而就可以用补数的加法替代原码转换的减法。
+ 所以补码可以让减法操作转换为加法操作，减少硬件成本。

### 定点数运算

#### 移位运算

+ 算术移位：通过改变各介数码位和小数点的相对位置，从而改变各数码位的位权。可用移位运算实现乘法、除法。
  + 原码的算数移位——符号位保持不变，仅对数值位进行移位：
    + 若右移高位补0，低位舍弃，右移代表除2，若移出的是0则刚好整除，若移出的是1则会整除余1丢失精度。
    + 若左移低位补0，低位舍弃，左移代表乘2，若移出的是0则刚好乘2，若移出的是1，则会严重误差。
  + 反码的算术移位——正数的反码与原码相同，所以正数的处理跟原码一样。而对于负数而言，反码的1等于原码的0，反码的0等于原码的1：
    + 若右移高位补1，低位舍弃。
    + 若左移高位补1，低位舍弃。
  + 补码的算术移位——正数的补码与原码相同，所以正数的处理跟原码一样。由于负数补码=反码末位加一，导致反码最右边几个连续的1都因进位而变为0，直到进位碰到第一个0为止。所以得到规律：
    + 负数补码中，最右边的1及其右边同原码一样。最右边的1的左边同反码一样。
    + 右移同反码，高位补1，低位舍弃。
    + 左移同原码，低位补0，高位舍弃。
+ 逻辑移位，可以视为对无符号数的算术移位：
  + 逻辑右移：高位补0，低位舍弃。
  + 逻辑左移：低位补0，高位舍弃。
+ 循环移位，将移出的一位放到另一端的端点，类似队列：
  + 循环右移：将最低位的一位移出放到最高位，其余右移一位。
  + 循环左移：将最高位的一位移出放到最低位，其余左移一位。
  + 进位位CF：保存计算是否进位。1代表产生进位，0代表未产生进位。
  + 带进位位的循环左移：需要加上进位位数值的循环左移。
  + 带进位位的循环右移：需要加上进位位数值的循环右移。

#### 加减运算

+ 原码的加减，由加法器和减法器两个硬件来实现，因为最高位为符号位，所以不能直接进行加减：
  + 原码的加法：
    + 正数+正数：绝对值做加法，结果为正数。
    + 负数+负数：绝对值做加法，结果为负数。
    + 正数+负数：绝对值大的减绝对值小的，符号同绝对值大的数。
    + 负数+正数：绝对值大的减绝对殖小的，符号同绝对值大的数。
  + 原码的减法，减数符号取反，转变为加法：
    + 正-负→正+正。
    + 负-正→负+负。
    + 正-正→正+负。
    + 负+正→负-负。
+ 补码的加减，由于减法器的硬件实现比较困难，所以原码的减法操作可以由补码来更简单实现，不用考虑符号位的异常，直接全部参与运算：
  + 如设机器字长为8位含一位符号位，A=15，B=-24，求A+B和A-B的补码。
  + A=+1111，从而原码补码为0000 1111，B=-11000，所以原码为1001 1000，反码为1110 0111，补码为1110 1000。
  + 所以A+B的补码等于A的补码加B的补码，为0000 1111+1110 1000=1111 0111，原码就是1000 1001，即-9，这与预期的一样。
  + 同理负数值的补码就是补码全部取反加1，所以A-B=0000 1111+0001 1000=0010 0111，即+39。
+ 溢出判断，由于使用补码进行加减操作都会变成加法，所以只用考虑加法溢出的处理。
  + 小于最小值就是下溢。只有负数+负数才会下溢得到正数。如-24-124=1110 1000+1000 0100=0110 1100=108。
  + 大于最大值就是上溢。只有正数+正数才会上溢得到负数。如15+124=0000 1111+0111 1100=1000 1011=-117。
  + 方法一，采用一位符号位（模二补码），根据符号位判断：
    + 设A的符号为$A_s$，B的符号为$B_s$，运算结果的符号为$S_s$。
    + 则溢出逻辑表达式为$V=A_sB_s\overline{S_s}+ \overline{A_s}\overline{B_s}S_s$（即$V=A_s\&\&B_s\&\&!(S_s)\mid\mid!(A_s)\&\&!(B_s)\&\&S_s$）。
    + 若$V=0$，表示无溢出，若$V=1$，表示有溢出。
    + 如-24-124=108产生了溢出，$A_s=1$、$B_s=1$、$S_s=0$，$V=A_sB_s\overline{S_s}+ \overline{A_s}\overline{B_s}S_s=1\,1\,1+0\,0\,0=1+0=1$，所以产生了溢出。
  + 方法二，采用一位符号位（模二补码），根据数据位进位1情况判断：
    + 符号位的进位$C_s=0$，最高数值位的进位$C_1=1$时产生了上溢。
    + 符号位的进位$C_s=1$，最高数值位的进位$C_1=0$时产生了下溢。
    + 如-24-124=1110 1000+1000 0100=0110 1100中符号位都为1，所以符号位进1，$C_s=1$，而最高数值位为1+0=1，没有进位，所以$C_1=0$，所以就产生了下溢。
  + 方法三，采用双符号位（模四补码），正数符号为00，负数符号为11。
    + 若两个符号位不同，则表示溢出，第一个符号位表示应该得到的符号位，第二个符号位代表实际得到的符号位。
    + 如-24-124=11,110 1000+11,000 0100=10,110 1100=108。下溢。
    + 如15+124=00,000 1111+00,111 1100=01,000 1011=-117。上溢。
    + 实际存储时只存储一个符号位，运算时会复制一个符号位。
+ 符号扩展

#### 乘法运算

#### 除法运算

## 浮点数

指小数点的位置不固定，使用科学计数法，如9.694E2。

## 算术逻辑单元

