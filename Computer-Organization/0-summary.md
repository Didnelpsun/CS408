# 概述

软件基于数据结构，数据结构又基于计算机，计算机由操作系统运行，计算机的硬件基于计算机组成原理，计算机之间通过计算机网络连接，这就是四个的关系。计算机组成原理是关于计算机硬件的最底层知识。

+ 计算机系统=硬件+软件。
+ 软件分为：
  + 系统软件：用来管理整个计算机系统，如操作系统、数据库管理系统（$DBMS$）、标准程程序库、网络软件、语言处理程序、服务程序。
  + 应用软件：按任务需要编制成的各种程序。

## 计算机的发展

### 硬件的发展

发展阶段|时间|逻辑元件|速度（次/秒）|内存|外存
:-----:|:--:|:------:|:----------:|:--:|:--:
第一代|1946-1957|电子管|几千-几方|汞延迟线、磁鼓|穿孔卡片、纸带
第二代|1958-1964|晶体管|几万-几干万|磁芯存储器|磁带
第三代|1964-1971|中小规模集成电路|几十万-几百万|半导体存储器|磁带、磁盘
第四代|1972-现在|大规模、超大规模集成电路|上千万-万亿|半导体存储器|磁盘、磁带、光盘、半导体存储器

+ 第一代使用纸带磁带编程。
+ 第二代出现了面向过程的程序设计语言$FORTRAN$，有了操作系统雏形。
+ 第三代主要用于科学计算等专业用途，高级语言快速发展，开始有了分时系统。
+ 第四代开始出现$CPU$、$PC$，如$Windows$、$MacOS$等。

### 软件的发展

+ 机器语言：唯一可以被计算机识别和执行的语言。
+ 汇编语言：必须经过汇编程序的翻译。
+ 高级语言：转换为汇编程序或直接翻译为机器语言。

### 计算机的分类

电子计算机分为：

+ 电子模拟计算机。
+ 电子数字计算机：
  + 专用计算机。
  + 通用计算机：巨型机、大型机、中型机、小型机、微型机、单片机。

## 计算机系统层次结构

### 计算机结构

#### 冯诺伊曼结构

1. 计算机由五大部件组成：
   + 输入设备：将信息转换成机器能识别的形式。
   + 存储器：存放数据和程序。
   + 运算器：算术运算和逻辑运算。
   + 控制器：协调其他部件与解析存储器中的程序或指令。
   + 输出设备：将结果转换为人类熟悉的形式。
2. 指令和数据以同等地位存于存储器，可按地址寻访。
3. 指令和数据用二进制表示。
4. 指令由操作码（指令序列号，用来表示处理的指令）和地址码（操作数据存储的地址）组成。
5. 存储程序：指将指令以二进制代码的形式事先输入计算机的主存储器，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。
6. 以运算器为中心：输入/输出设备与存储器之间的数据传送通过运算器完成。

#### 现代计算机结构

1. 计算机由两个部分组成：
   + 主机：
     + $CPU$：
       + 运算器。
       + 控制器。
     + 主存。
   + $I/O$设备：
     + 辅存。
     + 输入设备。
     + 输出设备。
2. 以存储器为中心。

### 硬件构成

#### I/O设备

+ 输入设备：将程序和数据以机器所能识别和接受的信息形式输入计算机。
+ 输出设备：将计算机处理的结果以人们所能接受的形式或其他系统所要求的信息形式输出

#### 存储器

用于存放程序和数据。分为主存和辅存，$CPU$直接访问主存，只有调入主存才能被$CPU$访问。

存储器结构：

+ 存储体：存储数据的主体，按地址存取。（相联存储器按内容访存）
+ $MAR$：（$Memory\,Address\,Register$）存储地址寄存器，用于访存地址，经过存放地址译码后所选的存储单元。$MAR$位数反映存储单元个数的幂值，与$PC$（程序计数器）长度相等（因为都是指向内存地址），如$MAR$有$10$位，则有$2^{10}=1024$个存储单元。
+ $MDR$：（$Memory\,Data\,Register$）存储数据寄存器，用于暂存要从存储器中读或写的信息。$MDR$位数=存储字长，一般为字节的二次幂的整数倍。（存储字长不等于数据字长，数据字长是数据总线一次性传输的信息位数）
+ 时序控制逻辑：产生存储器操作时所需的各种时序信号。

存储器相关概念：

+ 现代$MAR$和$MDR$被划分进入了$CPU$。
+ 存储单元：每个存储单元存放一串二进制代码。
+ 存储字（$word$）：存储单元中二进制代码的组合，即一个存储元存放的数据。
+ 存储字长：存储单元中二进制代码的位数，为$1B$或字节的偶数倍。
+ 存储元：即存储二进制的电子元件，每个存储元可存储$1bit$。

寄存器和高速缓冲寄存器$Cache$都集成在$CPU$上，离$CPU$越近速度越快，所以存取速度上寄存器>$Cache$>内存。

$CPU$包括运算器和控制器，不包括存储器（存储器不同于寄存器）。

#### 运算器

用于算术运算和逻辑运算。

+ $ALU$：算术逻辑单元，是核心单元，通过内部复杂的电路实现算数运算、逻辑运算。
+ $ACC$：累加器，用于存放操作数，或运算结果。
+ $MQ$：乘商寄存器，在乘、除运算时，用于存放操作数或运算结果。
+ $X$：操作数寄存器，通用的操作数寄存器，用于存放操作数。
+ $PSW$：程序状态寄存器，也称标志寄存器，用于存放$ALU$运算得到的一些标志信息或处理机的状态信息，如结果是否溢出、有无产生进位或借位、结果是否为负等。
+ 还有变址寄存器（$IX$），主要用于存放存储单元在段内的偏移量，基址寄存器（$BR$），用来存放操作数或中间结果，以减少对存储器的访问次数的数据寄存器。这些都不一定具备。

&nbsp;|加|减|乘|除
:-:|:-:|:-:|:-:|:-:
ACC|被加数、和|被减数、差|乘积高位|被除数、余数
MQ|&nbsp;|&nbsp;|乘数、乘积低位|商
X|加数|减数|被乘数|除数

#### 控制器

+ $CU$：控制单元，分析指令，给出控制信号。
+ $IR$：指令寄存器，存放当前执行的指令，内容来自主存的$MDR$。指令中操作码$OP(IR)$送到$CU$分析指令并发出各种微操作命令序列，地址码$Ad(IR)$送到$MAR$来取操作数。
+ $PC$：程序计数器，存放下一条要指令地址，取指后自动加$1$（一条指令长度，不一定为$1$）以形成下一条指令地址的功能，与主存$MAR$有直接通路。

#### 逻辑电路

+ 组合逻辑电路是具有一组输出和一组输入的非记忆性逻辑电路，它的基本特点是任何时刻的输出信号状态仅取决于该时刻各个输入信号状态的组合，而与电路在输入信号作用前的状态无关。组合电路不含存储信号的记忆单元，输出与输入之间无反馈通路，信号是单向传输的。
+ 时序逻辑电路中任意时刻的输出信号不仅和当时的输入信号有关，而且与电路原来的状态有关，这是时序逻辑电路在逻辑功能上的特点。因而时序逻辑电路必然包含存储记忆单元。
+ 组合逻辑电路没有统一的时钟控制，而时序逻辑电路则必须在时钟节拍下工作。

### 计算机工作过程

1. 把程序和数据装入主存储器。
2. 将源程序转成可执行问题。
3. 从可执行文件的首地址开始逐条执行指令。

完成一条指令：

1. 取指令$PC\rightarrow MAR\rightarrow M\rightarrow MDR\rightarrow IR$，并调用$PC$加$1$。
2. 将指令放入$IR$，并分析指令$OP(IR)\rightarrow CU$。
3. 调用$CU$协同执行指令$Ad(IR)\rightarrow MAR\rightarrow M\rightarrow MDR\rightarrow ACC$。

其中翻译包括：预处理；编译；汇编；链接四个阶段。

如何区分指令和数据：

+ 通过不同的时间段来区分指令和数据，即在取指令阶段（或取指微程序）取出的为指令，在执行指令阶段（或相应微程序）取出的即为数据。
+ 如果通过地址来源区分，由$PC$提供存储单元地址的取出的是指令，由指令地址码部分取出（提供存储单元地址或在指令中给出立即数）的是操作数。

已知：

```cpp
int a=2,b=3,c=1,y=0;
int main(){
    y=a*b+c;
}
```

根据计算过程，$a$乘$b$再加上$c$，简单的高级语言背后的转换为机器语言就变成：

指令地址：

主存地址|操作码|地址码|注释
:-----:|:----:|:----:|:--:
0|000001|0000000101|取数a至ACC
1|000100|0000000110|乘b得ab，存于ACC中
2|000011|0000000111|加c得ab+c，存于ACC中
3|000010|0000001000|将ab+c，存于主存单元
4|000110|0000000000|停机

数据地址，基本的赋值操作：

主存地址|数据值|注释
:------:|:----:|:--:
5|0000000000000010|a=2
6|0000000000000011|b=3
7|0000000000000001|c=1
8|0000000000000000|y=0

分析指令地址对应的五条指令执行流程，基本流程是取指令->获取指令操作码->获取指令地址->根据指令地址取数->放入寄存器->计算：

1. 执行地址为$0$的指令，取指令$1$到$4$，分析指令$5$，执行指令$6$到$8$：
   1. $(PC)=0$：程序计数器指向主存地址为$0$的指令。
   2. $(PC)\rightarrow MAR$，$(MAR)=0$：程序计数器将当前指向的指令地址通过系统总线传输给存储地址寄存器，从而存储地址寄存器的值现在置为$0$，表示它要处理的指令的主存地址为$0$。
   3. $M(MAR)\rightarrow MDR$，$(MDR)=000001\,0000000101$：根据存储地址寄存器存储的地址$0$，在存储体中找到对应的指令$000001\,0000000101$，并把它放入存储数据寄存器中。
   4. $(MDR)\rightarrow IR$，$(IR)=000001\,0000000101$：将存储数据寄存器存储的指令放入指令寄存器中。
   5. $OP(IR)\rightarrow CU$：将指令寄存器的$000001$操作码传输给控制单元中，控制单元根据操作码知道这是“取数”的指令。
   6. $AD(IR)\rightarrow MAR$：控制单元根据取数指令，明白要从存储器中取出一个数，而取出的数的地址就是指令寄存器的$0000000101$，即取出存储地址为$5$的数据$a=2$，将这个地址交给存储地址寄存器负责取出。
   7. $M(MAR)\rightarrow MDR$，$(MDR)=000000\,0000000010=2$：存储体根据存储地址寄存器的$0000000101$地址找到地址为$5$的数据$2$，并把$2$放到存储数据寄存器中。
   8. $(MDR)\rightarrow ACC$，$(ACC)=000000\,0000000010=2$：将存储数据寄存器的数据放入累加器中，完成$0$这条指令。
2. 执行地址为$1$的指令，取指令$1$到$4$，分析指令$5$，执行指令$6$到$10$：
   1. $(PC)+=1，(PC)=1$：程序计数器完成一条指令自动加一，从而现在指向地址为$1$的指令。
   2. $(PC)\rightarrow MAR，(MAR)=1$：存储地址寄存器的值现在置为$1$，表示它要处理的指令的主存地址为$1$。
   3. $M(MAR)\rightarrow MDR，(MDR)=000100\,0000000110$：在存储体中找到地址为$1$的指令$000100\,0000000110$，并把它放入存储数据寄存器中。
   4. $(MDR)\rightarrow IR，(IR)=000100\,0000000110$：将存储数据寄存器存储的指令放入指令寄存器中。
   5. $OP(IR)\rightarrow CU$：将指令寄存器的$000100$操作码传输给控制单元中，控制单元根据操作码知道这是“乘法”的指令。
   6. $AD(IR)\rightarrow MAR$：控制单元根据乘法指令，在第一条指令中就得到了其中一个乘数a，现在要另一个乘数$b$，$b$的地址就是指令寄存器的$0000000110$，即取出存储地址为$6$的数据$b=3$，将这个地址交给存储地址寄存器负责取出。
   7. $M(MAR)\rightarrow MDR$，$(MDR)=000000\,0000000011=3$：存储体根据存储地址寄存器的$0000000110$地址找到地址为$6$的数据$3$，并把$3$放到存储数据寄存器中。
   8. $(MDR)\rightarrow MQ$，$(MQ)=000000\,0000000011=3$：由于需要乘法操作，所以将存储数据寄存器的$3$放入乘商寄存器中。
   9. $(ACC)\rightarrow X$，$(X)=2$：然后把$a$的值从累加器中放入通用寄存器中。（乘法操作中被乘数放入通用寄存器中，而乘数放入乘商寄存器中）。
   10. $(MQ)*(X)\rightarrow ACC$，$(ACC)=6$：控制单元通知算术逻辑单元，通过算术逻辑单元对ab进行相乘后放入累加器中。如果乘积太大则需要乘商寄存器辅助存储。
3. 执行地址为$2$的指令，取指令$1$到$4$，分析指令$5$，执行指令$6$到$9$：
   1. $(PC)+=1$，$(PC)=2$：程序计数器完成一条指令自动加一，从而现在指向地址为2的指令。
   2. $(PC)\rightarrow MAR$，$(MAR)=2$：存储地址寄存器的值现在置为$2$，表示它要处理的指令的主存地址为2。
   3. $M(MAR)\rightarrow MDR$，$(MDR)=000011\,0000000111$：根据存储地址寄存器存储的地址$2$，在存储体中找到对应的指令$000011\,0000000111$，并把它放入存储数据寄存器中。
   4. $(MDR)\rightarrow IR$，$(IR)=000011\,0000000111$：将存储数据寄存器存储的指令放入指令寄存器中。
   5. $OP(IR)\rightarrow CU$：将指令寄存器的$000011$操作码传输给控制单元中，控制单元根据操作码知道这是“加法”的指令。
   6. $AD(IR)\rightarrow MAR$：控制单元根据取数指令，从存储器中取出指令寄存器的地址为$0000000111$的数，即取出存储地址为$7$的数据$c=1$，将这个地址交给存储地址寄存器负责取出。
   7. $M(MAR)\rightarrow MDR$，$(MDR)=000000\,0000000001=1$：存储体根据存储地址寄存器的$0000000111$地址找到地址为$7$的数据$1$，并把$1$放到存储数据寄存器中。
   8. $(MDR)\rightarrow X，X=000000\,0000000001=1$：将存储数据寄存器的$1$放入通用寄存器中。（即加法操作中累加器存放被加数，通用寄存器中存放加数）。
   9. $(ACC)+(X)\rightarrow ACC$，$(ACC)=7$：控制单元通知算术逻辑单元，将$ab$与$c$相加并存回累加器中。
4. 执行地址为$3$的指令，取指令$1$到$4$，分析指令$5$，执行指令$6$到$8$：
   1. $(PC)+=1$，$(PC)=3$：程序计数器完成一条指令自动加一，从而现在指向地址为3的指令。
   2. $(PC)\rightarrow MAR$，$(MAR)=3$：存储地址寄存器的值现在置为3，表示它要处理的指令的主存地址为$3$。
   3. $M(MAR)\rightarrow MDR$，$(MDR)=000010\,0000001000$：根据存储地址寄存器存储的地址$3$，在存储体中找到对应的指令$000010\,0000001000$，并把它放入存储数据寄存器中。
   4. $(MDR)\rightarrow IR$，$(IR)=000010\,0000001000$：将存储数据寄存器存储的指令放入指令寄存器中。
   5. $OP(IR)\rightarrow CU$：将指令寄存器的000010操作码传输给控制单元中，控制单元根据操作码知道这是“存数”的指令。
   6. $AD(IR)\rightarrow MAR$，$(MAR)=0000001000=8$：控制单元根据存数指令，根据存储的目的地址为$0000001000$。
   7. $(ACC)\rightarrow MDR$，$(MDR)=7$：将运算的结果从累加器中传输为存储数据寄存器中。
   8. $(MDR)\rightarrow$：地址为$8$的存储单元，$y=7$：控制单元根据控制总线，将存储数据寄存器中的数据存储到存储地址寄存器中所指向的地址，所以地址码为$8$的$y$的值就变成了$7$。
5. 执行地址为$4$的指令，取指令$1$到$4$，分析指令$5$，执行指令$6$：
   1. $(PC)+=1$，$(PC)=4$：程序计数器完成一条指令自动加一，从而现在指向地址为$4$的指令。
   2. $(PC)\rightarrow MAR$，$(MAR)=4$：存储地址寄存器的值现在置为$4$，表示它要处理的指令的主存地址为4。
   3. $M(MAR)\rightarrow MDR$，$(MDR)=000110\,0000000000$：根据存储地址寄存器存储的地址$4$，在存储体中找到对应的指令$000110\,0000000000$，并把它放入存储数据寄存器中。
   4. $(MDR)\rightarrow IR$，$(IR)=000110\,000000000$：将存储数据寄存器存储的指令放入指令寄存器中。
   5. $OP(IR)\rightarrow CU$：将指令寄存器的$000110$操作码传输给控制单元中，控制单元根据操作码知道这是“停机”的指令。
   6. 操作系统通过中断指令停止程序。

### 计算机层次

1. 微程序机器（微指令系统）：由硬件直接执行微指令。
2. 传统机器（用机器语言的机器）：执行二进制机器指令，微程序解释机器执行微指令。
3. 虚拟机器（操作系统机器）：由操作系统程序实现，向上提供“广义指令”即系统调用。也称为混合层。
4. 虚拟机器（汇编语言机器）：不能直接运行汇编语言，必须用汇编程序（汇编器）翻译成机器语言程序，所以是虚拟的。汇编语言与机器语言一一对应。
5. 虚拟机器（高级语言机器）：面向用户，必须用编译程序（编译器或解释器）翻译成汇编语言程序。

+ 翻译程序：是指把高级语言源程序转换成机器语言程序（目标代码）的软件。包括编译程序和解释程序。
+ 编译程序：将高级语言编写的源程序全部语句一次全部翻译成目标机器语言程序，而后再执行机器语言程序（只需翻译一次）。如$C$和$CPP$。
+ 解释程序：将源程序的一条语句翻译成对应于机器语言的语句，并立即执行。紧接着再翻译下一句（每次执行都要翻译），所以不会形成目标程序文件。如$JS$和$Python$。
+ 对于$Java$既可以编译也可以解释。

## 计算机性能指标

### 主存储器

+ $MAR$位数反映内存（而不是外存）单元的个数（最多支持多少个，如果超过了则$MAR$也无法寻址到，等同于没用），反映计算机处理能力和并行能力。
+ $MDR$位数=存储字长=每个存储单元的大小，反映计算机一次性处理的数据大小。
+ 总容量=存储单元个数×存储字长。单位为$bit$。
+ 如$MAR$为$32$位，$MDR$为$8$位，总容量=$2^{32}\times8\div8=3^{32}Byte$，所以为$4GB$。

### 中央处理器

+ $CPU$主频：$CPU$内数字脉冲信号振荡的频率。单位为赫兹。
+ $CPU$时钟周期：$CPU$主频（时钟主频）=$1\div CPU$时钟周期。一个时钟多少秒。单位为纳秒或微秒。
+ $CPI$（$Clock\,cycle\,Per\,Instruction$）：执行一条指令所需的时钟周期数。
+ 执行一条指令的耗时= $CPI\times CPU$时钟周期。
+ $CPU$执行时间（整个程序的耗时）=$CPU$时钟周期数÷主频=(指令条数×$CPI$)÷主频。
+ $IPS$（$Instructions\,Per\,Second$）：每秒执行多少条指令，$IPS$=主频÷平均$CPI$。也可以得到$MIPS$即每秒执行多少百万条指令。由于每个机器有不同指令集，所以使用此进行性能比较有缺陷。
+ 指令周期：一条指令需要多少秒，为$1/IPS$。
+ $FLOPS$（$Floating-point\,Operations\,Per\,Second$）：每秒执行多少次浮点运算。因此有$MFLOPS$、$GFLOPS$、$TFLOPS$、$EFLOPS$、$ZFLOPS$分别代表每秒$10^6$、$10^9$、$10^{12}$、$10^{15}$、$10^{18}$、$10^{21}$次浮点运算

### 系统整体

+ 数据通路带宽：数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据）。
+ 吞吐量：指系统在单位时间内处理请求的数量。它取决于信息能多快地输入内存，$CPU$能多快地取指令，数据能多快地从内存取出或存入，以及所得结果能多快地从内存送给一台外部设备。这些步骤中的每一步都关系到主存，因此，系统吞吐量主要取决于主存的存取周期。
+ 响应时间：指从用户向计算机发送一个请求，到系统对该请求做出响应并获得它所需要的结果的等待时间。通常包括$CPU$时间（运行一个程序所花费的时间）与等待时间（用于磁盘访问、存储器访问、$I/O$操作、操作系统开销等时间）。
+ 基准程序是用来测量机算机处理速度的一种实用程序，以便于被测量的计算机性能可以与运行相向程序的其它计算机性能进行比较。但是也存在缺陷，因为基准程序的性能可能与某一段代码密切相关从而对此进行特别优化。

### 专业术语

+ 系列机。具有基本相同的体系结构，使用相同基本指令系统的多个不同型号的计算机组成的一个产品系列。其特征就是指令系统向后兼容。
+ 兼容。指计算机软件或硬件的通用性，即使用或运行在某个型号的计算机系统中的硬件/软件也能应用于另一个型号的计算机系统时，称这两台计算机在硬件或软件上存在兼容性。
+ 软件可移植性。指把使用在某个系列计算机中的软件直接或进行很少的修改就能运行在另一个系列计算机中的可能性。
+ 固件。将程序固定在$ROM$中组成的部件称为固件。固件是一种具有软件特性的硬件，固件的性能指标介于硬件与软件之间，吸收了软/硬件各自的优点，其执行速度快于软件，灵活性优于硬件，是软/硬件结合的产物。例如，目前操作系统已实现了部分固化（把软件永恒地存储于只读存储器中）。
