# 概述

软件基于数据结构，数据结构又基于计算机，计算机由操作系统运行，计算机的硬件基于计算机组成原理，计算机之间通过计算机网络连接，这就是四个的关系。计算机组成原理是关于计算机硬件的最底层知识。

+ 计算机系统=硬件+软件。
+ 软件分为：
  + 系统软件：用来管理整个计算机系统，如操作系统、数据库管理系统（DBMS）、标准程程序库、网络软件、语言处理程序、服务程序。
  + 应用软件：按任务需要编制成的各种程序。

## 计算机的发展

### 硬件的发展

发展阶段|时间|逻辑元件|速度（次/秒）|内存|外存
:-----:|:--:|:------:|:----------:|:--:|:--:
第一代|1946-1957|电子管|几千-几方|汞延迟线、磁鼓|穿孔卡片、纸带
第二代|1958-1964|晶体管|几万-几干万|磁芯存储器|磁带
第三代|1964-1971|中小规模集成电路|几十万-几百万|半导体存储器|磁带、磁盘
第四代|1972-现在|大规模、超大规模集成电路|上千万-万亿|半导体存储器|磁盘、磁带、光盘、半导体存储器

+ 第一代使用纸带磁带编程。
+ 第二代出现了面向过程的程序设计语言FORTRAN，有了操作系统雏形。
+ 第三代主要用于科学计算等专业用途，高级语言快速发展，开始有了分时系统。
+ 第四代开始出现CPU、PC，如Windows、MacOS等。

### 软件的发展

+ 机器语言。
+ 汇报语言。
+ 高级语言。

## 计算机系统层次结构

### 计算机结构

#### 冯诺伊曼结构

1. 计算机由五大部件组成：
   + 输入设备：将信息转换成机器能识别的形式。
   + 存储器：存放数据和程序。
   + 运算器：算术运算和逻辑运算。
   + 控制器：协调其他部件与解析存储器中的程序或指令。
   + 输出设备：将结果转换为人类熟悉的形式。
2. 指令和数据以同等地位存于存储
器，可按地址寻访。
3. 指令和数据用二进制表示。
4. 指令由操作码（指令序列号，用来表示处理的指令）和地址码（操作数据存储的地址）组成。
5. 存储程序：指将指令以二进制代码的形式事先输入计算机的主存储器，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。
6. 以运算器为中心：输入/输出设备与存储器之间的数据传送通过运算器完成。

#### 现代计算机结构

1. 计算机由两个部分组成：
   + 主机：
     + CPU：
       + 运算器。
       + 控制器。
     + 主存。
   + I/O设备：
     + 辅存。
     + 输入设备。
     + 输出设备。
2. 以存储器为中心。

### 硬件构成

#### 主存储器

+ 存储体：存储数据的主体，按地址存储。
+ MAR：（Memory Address Register）存储地址寄存器。MAR位数反映存储单元个数的幂值。
+ MDR：（Memory Data Register）存储数据寄存器。MDR位数=存储字长。
+ 现代MAR和MDR被划分进入了CPU。
+ 存储单元：每个存储单元存放一串二进制代码。
+ 存储字（word）：存储单元中二进制代码的组合。
+ 存储字长：存储单元中二进制代码的位数。
+ 存储元：即存储二进制的电子元件，每个存储元可存储1bit。

#### 运算器

+ ACC：累加器，用于存放操作数，或运算结果。
+ MQ：乘商寄存器，在乘、除运算时，用于存放操作数或运算结果。
+ X：通用的操作数寄存器，用于存放操作数。
+ ALU：算术逻辑单元，是核心单元，通过内部复杂的电路实现算数运算、逻辑运算。

&nbsp;|加|减|乘|除
:-:|:-:|:-:|:-:|:-:
ACC|被加数、和|被减数、差|乘积高位|被除数、余数
MQ|&nbsp;|&nbsp;|乘数、乘积低位|商
X|加数|减数|被乘数|除数

#### 控制器

+ CU：控制单元，分析指令，给出控制信号。
+ IR：指令寄存器，存放当前执行的指令。
+ PC：程序计数器，存放下一条指令地址，有自动加1功能。

完成一条指令：

1. 取指令，并调用PC加1。
2. 将指令放入IR，并分析指令。
3. 调用CU协同执行指令。

如何区分指令和数据：

+ 通过不同的时间段来区分指令和数据，即在取指令阶段（或取指微程序）取出的为指令，在执行指令阶段（或相应微程序）取出的即为数据。
+ 如果通过地址来源区分，由PC提供存储单元地址的取出的是指令，由指令地址码部分提供存储单元地址的取出的是操作数。

已知：

```cpp
int a=2,b=3,c=1,y=0;
int main(){
    y=a*b+c;
}
```

根据计算发展，a乘b再加上c，简单的高级语言背后的转换为机器语言就变成：

主存地址|操作码|地址码|注释
:-----:|:----:|:----:|:--:
0|000001|0000000101|取数a至ACC
1|000100|0000000110|乘b得ab，存于ACC中
2|000011|0000000111|加c得ab+c，存于ACC中
3|000010|0000001000|将ab+c，存于主存单元
4|000110|0000000000|停机

主存地址|数据值|注释
:------:|:----:|:--:
5|0000000000000010|原始数据a=2
6|0000000000000011|原始数据b=3
7|0000000000000001|原始数据c=1
8|0000000000000000|原始数据y=0

1. 执行地址为0的指令，取指令1到4，分析指令5，执行指令6到8：
   1. (PC)=0：程序计数器指向主存地址为0的指令。
   2. (PC)->MAR，(MAR)=0：程序计数器将当前指向的指令地址通过系统总线传输给存储地址寄存器，从而存储地址寄存器的值现在置为0，表示它要处理的指令的主存地址为0。
   3. M(MAR)->MDR，(MDR)=000001 0000000101：根据存储地址寄存器存储的地址0，在存储体中找到对应的指令000001 0000000101，并把它放入存储数据寄存器中。
   4. (MDR)->IR，(IR)=000001 0000000101：将存储数据寄存器存储的指令放入指令寄存器中。
   5. OP(IR)->CU：将指令寄存器的000001操作码传输给控制单元中，控制单元根据操作码知道这是“取数”的指令。
   6. AD(IR)->MAR：控制单元根据取数指令，明白要从存储器中取出一个数，而取出的数的地址就是指令寄存器的0000000101，即取出存储地址为5的数据a=2，将这个地址交给存储地址寄存器负责取出。
   7. M(MAR)->MDR，(MDR)=0000000000000010=2：存储体根据存储地址寄存器的0000000101地址找到地址为5的数据2，并把2放到存储数据寄存器中。
   8. (MDR)->ACC，(ACC)=0000000000000010=2：将存储数据寄存器的数据放入累加器中，完成0这条指令。
2. 执行地址为1的指令，取指令1到4，分析指令5，执行指令6到10：
   1. (PC)+=1，(PC)=1：程序计数器完成一条指令自动加一，从而现在指向地址为1的指令。
   2. (PC)->MAR，(MAR)=1：存储地址寄存器的值现在置为1，表示它要处理的指令的主存地址为1。
   3. M(MAR)->MDR，(MDR)=000100 0000000110：在存储体中找到地址为1的指令000100 0000000110，并把它放入存储数据寄存器中。
   4. (MDR)->IR，(IR)=000100 0000000110：将存储数据寄存器存储的指令放入指令寄存器中。
   5. OP(IR)->CU：将指令寄存器的000100操作码传输给控制单元中，控制单元根据操作码知道这是“乘法”的指令。
   6. AD(IR)->MAR：控制单元根据乘法指令，在第一条指令中就得到了其中一个乘数a，现在要另一个乘数b，b的地址就是指令寄存器的0000000110，即取出存储地址为6的数据b=3，将这个地址交给存储地址寄存器负责取出。
   7. M(MAR)->MDR，(MDR)=0000000000000011=3：存储体根据存储地址寄存器的0000000110地址找到地址为6的数据3，并把3放到存储数据寄存器中。
   8. (MDR)->MQ，(MQ)=0000000000000011=3：由于需要乘法操作，所以将存储数据寄存器的3放入乘商寄存器中。
   9. (ACC)->X，(X)=2：然后把a的值从累加器中放入通用寄存器中。（乘法操作中被乘数放入通用寄存器中，而乘数放入乘商寄存器中）。
   10. (MQ)*(X)->ACC，(ACC)=6：控制单元通知算术逻辑单元，通过算术逻辑单元对ab进行相乘后放入累加器中。如果乘积太大则需要乘商寄存器辅助存储。
3. 执行地址为2的指令，取指令1到4，分析指令5，执行指令6到9：
   1. (PC)+=1，(PC)=2：程序计数器完成一条指令自动加一，从而现在指向地址为2的指令。
   2. (PC)->MAR，(MAR)=2：存储地址寄存器的值现在置为2，表示它要处理的指令的主存地址为2。
   3. M(MAR)->MDR，(MDR)=000011 0000000111：根据存储地址寄存器存储的地址2，在存储体中找到对应的指令000011 0000000111，并把它放入存储数据寄存器中。
   4. (MDR)->IR，(IR)=000011 0000000111：将存储数据寄存器存储的指令放入指令寄存器中。
   5. OP(IR)->CU：将指令寄存器的000011操作码传输给控制单元中，控制单元根据操作码知道这是“加法”的指令。
   6. AD(IR)->MAR：控制单元根据取数指令，从存储器中取出指令寄存器的地址为0000000111数，，即取出存储地址为7的数据c=1，将这个地址交给存储地址寄存器负责取出。
   7. M(MAR)->MDR，(MDR)=0000000000000001=1：存储体根据存储地址寄存器的0000000111地址找到地址为7的数据1，并把1放到存储数据寄存器中。
   8. (MDR)->X，X=0000000000000001=1：将存储数据寄存器的1放入通用寄存器中。（即加法操作中累加器存放被加数，通用寄存器中存放加数）。
   9. (ACC)+(X)->ACC，(ACC)=7：控制单元通知算术逻辑单元，将ab与c相加并存回累加器中。
4. 执行地址为3的指令，取指令1到4，分析指令5，执行指令6到8：
   1. (PC)+=1，(PC)=3：程序计数器完成一条指令自动加一，从而现在指向地址为3的指令。
   2. (PC)->MAR，(MAR)=3：存储地址寄存器的值现在置为3，表示它要处理的指令的主存地址为3。
   3. M(MAR)->MDR，(MDR)=000010 0000001000：根据存储地址寄存器存储的地址3，在存储体中找到对应的指令000010 0000001000，并把它放入存储数据寄存器中。
   4. (MDR)->IR，(IR)=000010 0000001000：将存储数据寄存器存储的指令放入指令寄存器中。
   5. OP(IR)->CU：将指令寄存器的000010操作码传输给控制单元中，控制单元根据操作码知道这是“存数”的指令。
   6. AD(IR)->MAR，(MAR)=0000001000=8：控制单元根据存数指令，根据存储的目的地址为0000001000。
   7. (ACC)->MDR，(MDR)=7，将运算的结果从累加器中传输为存储数据寄存器中。
   8. (MDR)->地址为8的存储单元，y=7：控制单元根据控制总线，将存储数据寄存器中的数据存储到存储地址寄存器中所指向的地址，所以地址码为8的y的值就变成了7。
5. 执行地址为4的指令，取指令1到4，分析指令5，执行指令6：
   1. (PC)+=1，(PC)=4：程序计数器完成一条指令自动加一，从而现在指向地址为4的指令。
   2. (PC)->MAR，(MAR)=4：存储地址寄存器的值现在置为4，表示它要处理的指令的主存地址为4。
   3. M(MAR)->MDR，(MDR)=000110 0000000000：根据存储地址寄存器存储的地址4，在存储体中找到对应的指令000110 0000000000，并把它放入存储数据寄存器中。
   4. (MDR)->IR，(IR)=000110 0000000000：将存储数据寄存器存储的指令放入指令寄存器中。
   5. OP(IR)->CU：将指令寄存器的000110操作码传输给控制单元中，控制单元根据操作码知道这是“停机”的指令。
   6. 操作系统通过中断指令停止程序。

### 计算机层次

1. 微程序机器（微指令系统）：由硬件直接执行微指令。
2. 传统机器（用机器语言的机器）：执行二进制机器指令。
3. 虚拟机器（操作系统机器）：向上提供“广义指令”即系统调用。
4. 虚拟机器（汇编语言机器）：不能直接运行汇编语言，必须用汇编程序（汇编器）翻译成机器语言程序，所以是虚拟的。汇编语言与机器语言一一对应。
5. 虚拟机器（高级语言机器）：还是必须用编译程序（编译器或解释器）翻译成汇编语言程序。

+ 编译程序：将高级语言编写的源程序全部语句一次全部翻译成机器语言程序，而后再执行机器语言程序（只需翻译一次）。如C和CPP。
+ 解释程序：将源程序的一条语句翻译成对应于机器语言的语句，并立即执行。紧接着再翻译下一句（每次执行都要翻译）。如JS和Python。
+ 对于Java既可以编译也可以解释。

## 计算机性能指标

### 存储器

+ MAR位数反映存储单元的个数（最多支持多少个）。
+ MDR位数=存储字长=每个存储单元的大小。
+ 总容量=存储单元个数×存储字长。单位为bit。
+ 如MAR为32位，MDR为8位，总容量=$2^{32}*8/8=3^{32}$Byte，所以为4GB。

### 中央处理器

+ CPU主频：CPU内数字脉冲信号振荡的频率。单位为赫兹。
+ CPU时钟周期：CPU主频（时钟主频）=1/CPU时钟周期。单位为纳秒或微秒。
+ CPI (Clock cycle Per Instruction）：执行一条指令所需的时钟周期数。
+ 执行一条指令的耗时= CPIxCPU时钟周期。
+ CPU执行时间（整个程序的耗时）=CPU时钟周期数/主频=(指令条数*CPI)/主频。
+ IPS（Instructions Per Second）：每秒执行多少条指令，IPS=主频/平均CPI。
+ FLOPS（Floating-point Operations Per Second）：每秒执行多少次浮点运算。

**例题** 某CPU主频为10o00Hz，某程序包含100条指令，平均来看指令任CPI=3，该程序在该CPU上执行需要多久？

100*3/1000=0.3s。

### 系统整体

+ 数据通路带宽：数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据）。
+ 吞吐量：指系统在单位时间内处理请求的数量。它取决于信息能多快地输入内存，CPU能多快地取指令，数据能多快地从内存取出或存入，以及所得结果能多快地从内存送给一台外部设备。这些步骤中的每一步都关系到主存，因此，系统吞吐量主要取决于主存的存取周期。
+ 响应时间：指从用户向计算机发送一个请求，到系统对该请求做出响应并获得它所需要的结果的等待时间。通常包括CPU时间（运行一个程序所花费的时间）与等待时间（用于磁盘访问、存储器访问、I/O操作、操作系统开销等时间）。
+ 基准程序是用来测量十算机处理速度的一种实用程序，以便于被测量的计算机性能可以与运行相向程序的其它计算机性能进行比较。
