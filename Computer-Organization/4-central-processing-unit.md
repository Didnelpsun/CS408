# 中央处理器

即$CPU$，为最难的一章。

## CPU基本概念

### CPU功能

#### CPU总功能

1. 指令控制。完成取指令、分析指令和执行指令的操作，即程序的顺序控制。
2. 操作控制。一条指令的功能往往是由若干操作信号的组合来实现的。$CPU$管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件，从而控制这些部件按指令的要求进行动作。
3. 时间控制。对各种操作加以时间上的控制。时间控制要为每条指令按时间顺序提供应有的控制信号。
4. 数据加工。对数据进行算术和逻辑运算。
5. 中断处理。对计算机运行过程中出现的异常情况和特殊请求进行处理。

#### 运算器功能

+ 对数据进行加工。
+ 主要部件是$ALU$和$ACC$。

#### 控制器功能

协调并控制计算机各部件执行程序的指令序列，基本功能包括取指令、分析指令、执行指令：

1. 取指令：
   + 自动形成指令地址。
   + 自动发出取指令的命令。
   + $(PC)+1\rightarrow PC$。
2. 分析指令：
   + 操作码译码（操作码，分析本条指令要完成什么操作）。
   + 产生操作数的有效地址。
3. 执行指令：
   + 根据分析指令得到的“操作命令”和“操作数地址”。
   + 形成操作信号控制序列，控制运算器、存储器以及$I/O$设备完成相应的操作。
4. 中断处理：
   + 管理总线及输入输出。
   + 处理异常情况（如掉电）。
   + 特殊请求（如打印机请求打印一行字符）。

+ 控制器部件向系统中的部件提供它们运行所需要的控制信号。
+ 控制器部件从数据总线接收指令信息。
+ 控制器部件从运算器部件接收指令转移地址。
+ 控制器部件送出指令地址到地址总线。

### CPU结构

+ $ALU$为首的组合逻辑。
+ $CU$为首的时序逻辑。
+ 寄存器。
+ 中断系统。

内部寄存器：

+ 用户可见可编程：
  + 通用寄存器组$X$。
  + 程序状态字寄存器$PSW$（标志寄存器）。
+ 用户不可见不可编程：
  + 存储器地址寄存器$MAR$。
  + 存储器数据寄存器$MDR$。
  + 指令寄存器$IR$。

#### 运算器结构

1. 算术逻辑单元$ALU$：主要功能是进行算术/逻辑运算。
2. 通用寄存器组$X$：如$AX$、$BX$、$CX$、$DX$、$SP$等，用于存放操作数（包括源操作数、目的操作数及中间结果）和各种地址信息等。$SP$是堆栈指针，用于指示栈顶的地址。
3. 内部总线：
   + 专用数据通路方式：
     + 根据指令执行过程中的数据和地址的流动方向安排多条连接线路。
     + 如果直接用导线连接，相当于多个寄存器同时并且一直向$ALU$传输数据，解决方法：
        1. 使用多路选择器$MUX$根据控制信号选择一路输出解决方法。
        2. 使用三态门可以控制每一路是否输出，$1$允许，$0$不允许。
     + 性能较高，基本不存在数据冲突现象，但结构复杂，硬件量大，不易实现。
   + $CPU$内部单总线方式：
     + 将所有寄存器的输入端和输出端都连接到一条公共的通路上。
     + 结构简单，容易实现，但数据传输存在较多冲突的现象，性能较低。
     + 为了解决冲突用暂存寄存器解决。
4. 暂存寄存器$R$：用于暂存从主存读来的数据，这个数据不能存放在通用寄存器中，否则会破坏其原有内容。
5. 累加寄存器$ACC$：它是一个通用寄存器，用于暂时存放$ALU$运算的结果信息，用于实现加法运算。
6. 程序状态字寄存器$PSW$：保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息，如溢出标志（$OP$） 、符号标志（$SF$）、零标志（$ZF$）、进位标志（$CF$）等，$PSW$中的这些位参与并决定微操作的形成。
7. 移位器（移位寄存器）$SR$：对运算结果进行移位运算。拥有移位逻辑的寄存器。
8. 计数器（计数寄存器）$CT$：控制乘除运算的操作步数。拥有计数逻辑的寄存器。

#### 控制器结构

1. 程序计数器$PC$：用于指出下一条指令在主存中的存放地址。$CPU$就是根据$PC$的内容去主存中取指令的。因程序中指令（通常）是顺序执行的，所以$PC$有自增功能。
2. 指令寄存器$IR$：用于保存当前正在执行的那条指令。
3. 指令译码器$ID$：仅对**操作码**字段进行译码，向控制器提供特定的操作信号。
4. 操作控制器$OC$：用来产生各种操作控制信号。
5. 微操作信号发生器：根据$IR$的内容（指令）、$PSW$的内容（状态信息）及时序信号，产生控制整个计算机系统所需的各种控制信号，其结构有组合逻辑型和存储逻辑型两种。
6. 时序系统（时序产生器）：用于产生各种时序信号,它们都是由统一时钟（$CLOCK$）分频得到。
7. 存储器地址寄存器$MAR$：用于存放所要访问的主存单元的地址。
8. 存储器数据寄存器$MDR$：用于存放向主存写入的信息或从主存中读出的信息。

## 指令执行

### 指令周期

#### 指令周期定义

+ 指令周期：$CPU$从主存中每取出并执行一条指令所需的全部时间：
  + 取指周期：取指、分析。
  + 执行周期。
+ 指令周期常常用若干机器周期来表示，机器周期又叫$CPU$周期。如取指令、取有效地址、执行指令这就是三个机器周期，是一个指令周期。
+ 一个机器周期又包含若干时钟周期（也称为节拍、$T$周期或$CPU$时钟周期，它是$CPU$操作的最基本单位）。
+ 每个指令周期内机器周期数可以不等，每个机器周期内的节拍数也可以不等。
+ 指令周期流程：
  1. 进入取指周期。
  2. 判断是否有间址。
  3. 若有则进入间址周期，结束后进入执行周期。
  4. 若无则直接进入执行周期。
  5. 判断是否有中断。
  6. 若有则进入中断周期，结束后进入下一条指令的指令周期。
  7. 若无则直接进入下一条指令的指令周期。

<span style="color:orange">注意：</span>中断周期中的进栈操作是将$SP$减$1$，这和传统意义上的进栈操作相反，原因是计算机的堆栈中都是向低地址增加，所以进栈操作是减$1$而不是加$1$。

#### 标志触发器

为了区别不同的工作周期，$CPU$内设了四个标志触发器，以一状态位为有效：

+ 取指令$FE$：取指周期。
+ 取地址$IND$：间址周期。
+ 存取操作数或结果$EX$：执行周期。
+ 存程序断点$INT$：中断周期。

#### 相关周期区别

四种周期：

+ 指令周期：$CPU$从主存中每取出并执行一条指令所需的全部时间。指令周期可变。
+ 时钟周期：通常称为节拍或$T$周期，它是$CPU$操作的最基本单位。时钟周期不变。
+ $CPU$周期也称机器周期：一个机器周期包含若干时钟周期。是$CPU$进行一次操作的时间。由于$CPU$内部操作的速度较快，而$CPU$访问一次存储器的时间较长，因此机器周期通常由存取周期来确定，往往是通过一次总线事务访问一次主存或$I/O$的时间。机器周期可变。
+ 存取周期：指存储器进行两次独立的存储器操作（连续两次读或写操作）所需的最小间隔时间。存取周期往往为固定值。
+ 机器周期：通过一次总线事务访问一次主存或 $I/O$的时间定为一个机器周期。所以机器周期往往与访存周期相等。

### 数据流

指令周期一共包含四个机器周期，但是指令不同可能只有部分周期，如零地址指令只有取指和执行周期。

#### 取指周期

根据$PC$内容（无论是普通指令还是转移指令）从内存中取出指令代码并放入$IR$中。

<span style="color:orange">注意：</span>取指操作是控制器固化的自动执行的操作。

1. 当前指令地址送至存储器地址寄存器，记做：$(PC)\rightarrow MAR$。
2. $MAR$将地址码发送到地址总线。
3. 地址总线将地址发送给存储器，等待使用地址。
4. $CU$发出控制读信号给控制总线。
5. 控制总线将控制读的信号发送给存储器。启动存储器做读操作，记做：$1\rightarrow R$。
6. 存储器根据地址总线传来的地址信息和控制总线传来的控制读信息来进行读操作，从中读出数据。并将地址所指的数据发送给数据总线。
7. 数据总线将数据送入$MDR$，记做：$M(MAR)\rightarrow MDR$。
8. 将$MDR$中数据（此时是指令内容）送入$IR$，记做：$(MDR)\rightarrow IR$。
9. $CU$发出控制信号，控制$PC$形成下一条指令地址，默认是加一，记做：$(PC)+1\rightarrow PC$。

#### 间址周期

取操作数有效地址。

1. $IR$将指令的地址码送入$MAR$，记做：$Ad(IR)\rightarrow MAR$或$Ad(MDR)\rightarrow MAR$。
2. $MAD$将地址码发送到地址总线。
3. 地址总线将地址发送给存储器，等待使用地址。
4. $CU$发出控制读信号给控制总线。
5. 控制总线将控制读信息发送到存储器中。启动主存做读操作，记做：$1\rightarrow R$。
6. 存储器根据地址总线传来的地址信息和控制总线传来的控制读信息来进行读操作，从中读出数据。并将地址所指的数据发送给数据总线。
7. 数据总线将数据送入$MDR$，记做：$M(MAR)\rightarrow MDR$。此时$MDR$保存的是操作数的地址而不是操作数本身。
8. 将有效地址送至指令的地址码字段，记做：$MDR\rightarrow Ad(IR)$。这一步可以没有。

#### 执行周期

执行周期的任务是根据$IR$中的指令字的操作码和操作数通过$ALU$操作产生执行结果。不同指令的执行周期操作不同，因此没有统一的数据流向。

这里$MDR$访存取数得到操作数，此时$MDR$中的内容才是操作数。

#### 中断周期

+ 中断：暂停当前任务去完成其他任务。为了能够恢复当前任务，需要保存断点。
+ 一般使用堆栈来保存断点，这里用$SP$表示栈顶地址，假设$SP$指向栈顶元素，进栈操作是先修改指针，后存入数据。

1. $CU$控制将$SP$减$1$，即将一个空元素进栈然后对其操作，并修改后的地址送入$MAR$，记做：$(SP)-1\rightarrow SP$，$(SP)\rightarrow MAR$。本质上是将断点存入某个存储单元，假设其地址为$a$，故可记做：$a\rightarrow MAR$。
2. $MAR$将地址码发送到地址总线。
3. 地址总线将地址发送给存储器，等待使用地址。
4. $CU$发出控制写信号给控制总线。
5. 控制总线将控制写信息发送到存储器中。启动主存做写操作，记做：$1\rightarrow W$。
6. 将断点（$PC$内容）送入$MDR$，记做：$(PC)\rightarrow MDR$。
7. 将$MDR$内容传入数据总线。
8. 数据总结将内容发送存储器。存储器将内容写入其中，记为$(MDR)\rightarrow M$。
9. $CU$控制将中断服务程序的入口地更新（由向量地址形成部件产生）送入$PC$：向量地址$\rightarrow PC$。

### 指令执行方案

一个指令周期通常要包括多个时间段（执行步骤），每个步骤完成指令的一部分功能，几个依次执行的步骤完成这条指令的全部功能。

1. 单指令周期：
   + 对所有指令都选用相同的执行时间来完成。
   + 指令之间串行执行。
   + 指令周期取决于执行时间最长的指令的执行时间。
   + 执行周期内控制信号不变。
   + 缺点：对于那些本来可以在更短时间内完成的指令，要使用这个较长的周期来完成，会降低整个系统的运行速度。
   + 优点：实施简单，只用程序计数器$PC$就能实现。
2. 多指令周期：
   + 对不同类型的指令选用不同的执行步骤来完成。
   + 指令之间串行执行。
   + 可选用不同个数的时钟周期来完成不同指令的执行过程。
   + 缺点：需要更复杂的硬件设计。
   + 优点：系统运行速度更高，效率更高。
3. 流水线方案：
   + 在每一个时钟周期启动一条指令，尽量让多条指令同时运行，但各自处在不同的执行步骤中。

## 数据通路

+ 数据通路就是数据在功能部件之间传送的路径。
+ 由控制部件产生的控制信号建立数据通路。
+ 数据通路的基本结构：
  + $CPU$内部单总线方式。
  + $CPU$内部多总线方式。
  + 专用数据通路方式。

### CPU内部单总线方式

+ 内部总线是指同一部件，如$CPU$内部连接各寄存器及运算部件之间的总线。
+ 系统总线是指同一台计算机系统的各部件，如$CPU$、内存、通道和各类$I/O$接口间互相连接的总线。
+ 使用一根总线连接部件的输入和输出。
+ 一个时钟内只允许一次操作。
+ 实现简单。
+ 容易冲突，且效率较低。

对于$ALU$这种是一个组合逻辑电路的部件，其运算过程中必须保持两个输入端的内容不变。如果使用内部单总线方式，因此为了得到两个不同的操作数，$ALU$的一个输入端与总线相连，另一个输入端需通过一个寄存器与总线相连，第一个传入值的输入端需要用寄存器保存数据等待第二个数的输入，避免数据发生变化。此外，$ALU$的唯一的输出端也不能直接与内部总线相连，否则其输出又会通过总线反馈到输入端，影响运算结果，因此输出端需通过一个暂存器（用来暂存结果的寄存器）或三态门（控制与总线的打开与关闭）与总线相连。

1. 寄存器之间数据传送，比如把$PC$内容送至$MAR$，实现传送操作的流程及控制信号为：
   1. $(PC)\rightarrow Bus$：$PCout$有效，$PC$内容送总线。
   2. $Bus\rightarrow MAR$：$MARin$有效，总线内容送$MAR$。
2. 主存与$CPU$之间的数据传送，比如$CPU$从主存读取指令，实现传送操作的流程及控制信号为：
   1. $(PC)\rightarrow Bus\rightarrow MAR$：$PCout$和$IMARin$有效，现行指令地址$\rightarrow MAR$。
   2. $1\rightarrow R$：$CU$通过控制总线发出读命令。
   3. $MEM(MAR)\rightarrow MDR$：$MDRin$有效，根据$MAR$地址取值送到$MDR$。
   4. $MDR\rightarrow Bus\rightarrow IR$：$MDRout$和$IRin$有效，现行指令$\rightarrow IR$。
3. 执行算术或逻辑运算，比如一条加法指令，微操作序列及控制信号为：
   1. $Ad(IR)\rightarrow Bus\rightarrow MAR$：$MDRout$和$IMARin$有效。
   2. $1\rightarrow R$：$CU$发读命令。
   3. $MEM(MAR)\rightarrow$数据线$\rightarrow MDR$：$MDRin$有效。
   4. $MDR\rightarrow Bus\rightarrow Y$：$MDRout$和$Yin$有效，操作数$\rightarrow Y$。
   5. $(ACC)+(Y)\rightarrow Z$：$ACCout$和$ALUin$有效，$CU$向$ALU$发送加命令。
   6. $Z\rightarrow ACC$：$Zout$和$ACCin$有效，结果$\rightarrow ACC$。

### CPU内部多总线方式

+ 使用多根总线连接部件的输入和输出。
+ 效率相对于单总线而言得到了提升。

### 专用数据通路方式

+ 对于各种部件使用专用的通路进行连接。专用通路就是将总线分散到各个地方。
+ 连接多，实现困难。

## 控制器

$CU$的设计包括硬布线和微程序两种，微程序比较重要，硬布线了解即可。

### 控制器输入输出

输入：

1. 指令寄存器：$OP(IR)\rightarrow CU$，控制信号的产生与操作码有关。
2. 时钟：一个时钟脉冲发一个操作命令或一组需要同时执行的操作命令。
3. 标志：如条件转移指令，根据相应的标志位决定下一步操作。
4. 外来信号：如中断请求信号$INTR$、总线请求信号$HRQ$。

$CU$的输入信号来源如下：

1. 经指令译码器译码产生的指令信息。
2. 时序系统产生的机器周期信号和节拍信号。
3. 来自执行单元的反馈信息即标志。

前两者是主要因素。

输出：

1. $CPU$内部的控制信号：寄存器之间的数据传输、$PC$的修改、控制$ALU$进行相应的运算。
2. 到控制总线的控制信号：
   + 到存储器:访存控制信号MREQ、读命令RD、写命令WR。
   + 到I/O设备:访问I/O设备的控制信号IO。
   + 中断响应信号INTA。
   + 总线响应信号HLDA。

### 硬布线

微操作控制信号由组合逻辑电路根据当前的指令码、状态和时序，即时产生。

#### 设计步骤

1. 分析每个阶段的微操作序列。
2. 选择$CPU$的控制方式：产生不同微操作命令序列所用的时序控制方式：
   1. 同步控制方式：
      + 整个系统所有的控制信号均来自一个统一的时钟信号。
      + 通常以最长的微操作序列和最烦琐的微操作作为标准，采取完全统一的、具有相同时间间隔和相同数目的节拍作为机器周期来运行不同的指令。
      + 同步控制方式的优点是控制电路简单，缺点是运行速度慢。
   2. 异步控制方式：
      + 异步控制方式不存在基准时标信号。
      + 各部件按自身固有的速度工作，通过应答方式进行联络。
      + 异步控制方式的优点是运行速度快，缺点是控制电路比较复杂。
   3. 联合控制方式：
      + 对各种不同的指令的微操作实行大部分采用同步控制、小部分采用异步控制的办法。
3. 安排微操作时序：
   + 原则：
      1. 微操作的先后顺序不得随意更改被控对象不同的微操作。
      2. 尽量安排在一个节拍内完成占用时间较短的微操作。
      3. 尽量安排在一个节拍内完成并允许有先后顺序。
4. 电路设计。
   1. 列出操作时间表。
   2. 写出微操作命令的最简表达式。
   3. 画出逻辑图。

#### 指令类别

1. 非访存指令：
   1. $CLA$（$clear$）：$ACC$清零。
   2. $COM$（$complement$）：$ACC$取反。
   3. $SHR$（$shift$）：算术右移。
   4. $CSL$（$cyclic\,shift$）：循环左移。
   5. $STP$（$stop$）：停机。
2. 访存指令：
   1. $ADD$：加法指令，隐含$ACC$。
   2. $STA$：存数指令，隐含$ACC$。
   3. $LDA$：取数指令，隐含$ACC$。
3. 转移指令：
   1. $JMP$（$jump$）：无条件转移。
   2. $BAN$（$branch\,ACC\,Negative$）：条件转移。

#### 基本微操作时序

首先对于取指周期，基本上的流程如下：

1. $PC\rightarrow MAR$：将$PC$地址交给$MAR$。
2. $1\rightarrow R$：主存发出读命令。只需要存储器空闲就能发出。
3. $M(MAR)\rightarrow MDR$：将地址指向指令交给$MDR$。要$MAR$准备好，在$1$的后面。
4. $MDR\rightarrow IR$：将指令交给$IR$。把$MDR$有指令，在$3$后面。
5. $OP(IR)\rightarrow ID$：编译指令。$IR$中要有指令，在$4$后面。
6. $(PC)+1\rightarrow PC$：$PC$自加$1$。因为操作完就可以更新，所以在$1$后面就可以了。

所以没有依赖的可以尽量往前放，顺序可以变为$123645$。

因为$12$没有相互依赖，所以可以都安排在$T0$时间；$36$在$1$的后面，且$36$之间用到的设备不一样从而不会冲突，所以都安排在$T1$；而$4$和$5$时间都较短，所以可以都安排在$T2$。

然后是间址周期：

1. $Ad(IR)\rightarrow MAR$：获取$IR$指令中的地址交给$MAR$。
2. $1\rightarrow R$：主存发出读命令。
3. $M(MAR)\rightarrow MDR$：取出对应的值放到$MDR$中。
4. $MDR\rightarrow Ad(IR)$：将$MDR$的地址值放入$IR$的指令中。

与取指周期一致，$2$可以跟$1$一起，而$34$都依赖于$1$，所以$12$是$T0$，$3$是$T1$，$4$是$T2$。

执行周期省略，最后是中断周期，假设中断时要保存的地址为$a$：

1. $a\rightarrow MAR$：将$a$保存到$MAR$中。
2. $1\rightarrow W$：主存发出写命令。存储器空闲就可以。
3. $0\rightarrow EINT$：硬件关中断。安排在第一个周期就可以。
4. $(PC)\rightarrow MDR$：将当前程序计数器保存的位置暂存到$MDR$，等待后期恢复。内部数据通路空闲就可以。
5. $MDR\rightarrow M(MAR)$：将$MDR$的数据保存到$a$这个地址。在$4$之后。
6. 向量地址$\rightarrow PC$：将$PC$送到中断服务地址。只用$PC$改好就可以，在$4$之后。

$1$、$2$、$3$都在$T0$，而$456$依次为$T1$、$T2$、$T3$。

这些操作由中断隐指令完成。中断隐指令不是一条指令，而是指一条指令的中断周期由硬件完成的一系列操作

### 微程序

事先把微操作控制信号存储控制存储器中，将每一条机器指令编写成一个微程序，这些微程序可以存到一个控制存储器中，用寻址用户程序机器指令的办法来寻址每个微程序中的微指令。

+ 在微程序控制器中，控制部件向执行部件发出的控制信号称为微命令。
+ 微命令执行的操作称为微操作。
+ 微指令则是若干微命令的集合。
+ 若干微指令的有序集合称为微程序。

#### 微程序构成

+ 完成一条机器指令分为多个微操作命令，微操作命令即微命令，是微操作的控制信号。微操作是微命令的执行过程。
+ 微命令分为：
  + 相容性微命令：可以同时产生、共同完成某些微操作的微命令。
  + 互斥性微命令：在机器中不允许同时出现的微命令。
+ 对于相容性的微命令可以合并为一条微指令，而互斥性微命令只能单独为一条微指令。
+ 微指令是若干微命令的集合。微周期通常指从控制存储器中读取一条微指令并执行相应的微操作所需的时间。
+ 假设微指令的一个二进制位对应一个微操作命令，所有的微命令都合并为微指令，微指令再合并为一个微程序保存到$ROM$中，从而每一条机器指令对应一条微程序。
+ 微指令基本格式：
  + 操作控制：微操作码：产生控制信号。
  + 顺序控制：微地址码：产生下一条指令地址。
+ 每条指令取指周期的操作是相同的，所以将取指令操作的微命令统一编成一个微程序，而每条机器指令所对应的具体操作再单独编写一个对应的微程序。
+ 执行公用的取指微程序从主存中取出机器指令后，由机器指令的操作码字段指出各个微程序的入口地址（初始微地址）。

#### 微程序控制器结构

存储器：

+ 主存储器用于存放程序和数据，在$CPU$外部，由$RAM$实现。
+ 控制存储器$CM$用于存放微程序，在$CPU$内部，由$ROM$实现。

寄存器：

+ 地址译码器：将地址码转换微存储单元控制信号。
+ 微地址寄存器$CMAR$：接收微地址形成部件送来的微地址，为在$CM$中读取微指令作准备。
+ 微指令寄存器$CMDR$：用于存放从$CM$中取出的微指令，它的位数同微指令字长相等。
+ 微地址形成部件：产生初始微地址和后继微地址，以保证微指令的连续执行。
+ 顺序逻辑单元：为了保证指令联系执行，控制形成下一条微指令，拥有一个标志位标识顺序执行还是跳转和一个时钟信号$CLK$。

控制流程：

1. 机器指令操作码$OP$送到微地址形成部件形成微地址。
2. 将初始微地址送到顺序逻辑单元，判断顺序执行还是跳转。
3. 送到$CMAR$保存微地址。
4. 将微地址从$CMAR$送到地址译码器中译码。
5. 形成控制单元后送到$CM$中取出微指令。
6. 将微指令送到$CMDR$中。
7. 根据微指令中的下一条指令地址送到顺序逻辑单元，判断顺序执行还是跳转。
8. 返回结果后$CMDR$送到$CPU$内部和系统总线，产生控制信号。

微程序个数：

+ 默认一条机器指令对应一个微程序。
+ 取指周期微程序默认是公共的（即单独拿出来公用），故如果某指令系统中有$n$条机器指令，则$CM$中微程序的个数至少是$n+1$个（加一个取指的公共微程序）。
+ 间址周期微程序和中断周期微程序不一定是公共的。若公共的，如果这台计算机指令系统中有$n$条机器指令，则$CM$中微程序的个数是$n+3$个。若题目中没有提到间址，就不考虑间址，所以是$n+2$个。

#### 微指令编码

微指令的编码方式又称为微指令的控制方式，它是指如何对微指令的控制字段进行编码，以形成控制信号。编码的目标是在保证速度的情况下，尽量缩短微指令字长。

1. 直接编码（直接控制）方式：
   + 在微指令的操作控制字段中，每一位二进制位代表一个微操作命令。
   + 某位为“$1$”表示该控制信号有效，为$1$的指令同时执行；若“$0$”则代表此时该位指向的命令不运行。
   + 优点：简单、直观，执行速度快，操作并行性好。
   + 缺点：微指令字长过长，$n$个微命令就要求微指令的操作字段有$n$位，造成控存容量极大。
2. 字段直接编码方式：
   + 将微指令的控制字段分成若干“段”，每段经译码后发出控制信号。
   + 微命令字段分段的原则：
      1. 因为每组译码后可以通过每位$10$的不同来让每组中的操作互斥，而不同组则很难完成互斥，所以互斥性微命令分在同一段内；因为命令在不同的组可以同时执行，所以相容性微命令分在不同段内。
      2. 每个小段中包含的信息位不能太多，否则将增加译码线路的复杂性和译码时间。
      3. 一般每个小段还要留出一个状态，表示本字段不发出任何微命令。因此，当某字段的长度为$3$位时，最多只能表示$7$个互斥的微命令，通常用$000$表示不操作。
   + 优点：可以缩短微指令字长。
   + 缺点：要通过译码电路后再发出微命令，因此比直接编码方式慢。
3. 字段间接编码方式：
   + 一个字段的某些微命令需由另一个字段中的某些微命令来解释，由于不是靠字段直接译码发出的微命令，故称为字段间接编码，又称隐式编码。
   + 优点：可进一步缩短微指令字长。
   + 缺点：运行速度更慢；削弱了微指令的并行控制能力，故通常作为字段直接编码方式的辅助手段。

#### 微指令地址

1. 微指令的下地址字段指出：微指令格式中设置一个下地址字段，由微指令的下地址字段直接指出后继微指令的地址，这种方式又称为断定方式。
2. 根据机器指令的操作码形成：当机器指令取至指令寄存器后，微指令的地址由操作码经微地址形成部件形成。
3. 由硬件产生微程序入口地址：
   + 第一条微指令地址：专门硬件产生。
   + 中断周期：硬件产生中断周期微程序首地址。
4. 增量计数器法：$(CMAR)+1\rightarrow CMAR$，适用于指令连续存放的情况。
5. 分支转移：指令分为三个字段：
   1. 操作控制字段：指明操作控制类型。
   2. 转移方式：指明判别条件。
   3. 转移地址：指明转移成功后的去向。
6. 通过测试网络：一个测试网络产生。

#### 微指令格式

1. 水平型微指令：
   + 一次能定义并执行多个并行操作。
   + 基本格式是：操作控制+判别测试+后继地址。
   + 优点：微程序短，执行速度快。
   + 缺点：微指令长，编写微程序较麻烦。
2. 垂直型微指令：
   + 类似机器指令操作码的方式，由微操作码字段规定微指令的功能。一条指令对应一个操作。
   + 基本格式：微操作码+目的地址+源地址。
   + 优点：微指令短、简单、规整，便于编写微程序。
   + 缺点：微程序长，执行速度慢，工作效率低。
3. 混合型微指令：
   + 在垂直型的基础上增加一些不太复杂的并行操作。
   + 微指令较短，仍便于编写。
   + 微程序也不长，执行速度加快。

水平型微指令的求法。

+ 操作控制：
  + 若是直接编码方式，则微命令数就是操作控制字段位数。
  + 若是字段直接编码方式，则会分$n$个组，每组$n_i$种状态，则总位数就是$\sum\limits_{i=1}^n\log_2(n_i+1)$（全$0$空出）。如$2,3,4$，则一共需要$2+2+3=7$位。
+ 判别测试：
  + 直接编码方式，有几个外部条件，就取几位。
  + 如果是字段直接编码，有$N$个外部条件就有$n$位，$2^n\geqslant N+1$，加$1$是因为还有无条件转移的情况。
+ 后继地址：
  + 求出前面两项后，直接根据微指令字长减去。
  + 根据$CM$的容量的前一项确认，$2^N\times M$容量就是$N$位。

#### 微程序控制单元设计

设计步骤：

1. 分析每个阶段的微操作序列。
2. 写出对应机器指令的微操作命令及节拍安排：
   1. 写出每个周期所需要的微操作（参照硬布线）。
   2. 补充微程序控制器特有的微操作：
      + 取指周期：$Ad(CMDR)\rightarrow CMAR$；$OP(IR)\rightarrow CMAR$。
      + 执行周期：$Ad(CMDR)\rightarrow CMAR$。
3. 确定微指令格式：
   + 根据微操作个数决定采用何种编码方式，以确定微指令的操作控制字段的位数。
   + 由微指令数确定微指令的顺序控制字段的位数。
   + 最后按操作控制字段位数和顺序控制字段位数就可确定微指令字长。
4. 编写微指令码点：根据操作控制字段每一位代表的微操作命令，编写每一条微指令的码点。

节拍安排|取指周期-硬布线控制器的节拍安排|取指周期-微程序控制器的节拍安排
:------:|:-----------------------------:|:----------------------------:
T0|PC→MAR|PC→MAR
T0|1→R|1→R
T1|M(MAR)→MDR|M(MAR)→MDR
T1|(PC)+1→PC|(PC)+1→PC
T2|MDR→IR|MDR→IR
T2|OP(IR)→ID|OP(IR)→微地址形成部件

根据读出转入微指令的过程，变为：

节拍安排|取指周期-硬布线控制器的节拍安排|取指周期-微程序控制器的节拍安排
:------:|:-----------------------------:|:----------------------------:
T0|PC→MAR|PC→MAR
T0|1→R|1→R
T1|M(MAR)→MDR|Ad(CMDR)→CMAR
T1|(PC)+1→PC|
T2|MDR→IR|M(MAR)→MDR
T2|OP(IR)→ID|(PC)+1→PC
T3||Ad(CMDR)→CMAR
T4||MDR→IR
T4||OP(IR)→微地址形成部件

#### 硬布线与微程序

对比项目\类别|微程序控制器|硬布线控制器
:----------:|:-----------:|:----------:
工作原理|微操作控制信号以微程序的形式存放在控制存储器中，执行指令时读出即可|微操作控制信号由组合逻辑电路根据当前的指令码、状态和时序，即时产生
执行速度|慢（从CM中读取微指令）|快
规整性|较规整|烦琐、不规整
应用场合|CISC CPU|RISC CPU
易扩充性|易扩充修改|困难

#### 微程序设计分类

+ 静态微程序设计：无需改变，采用$ROM$。
+ 动态微程序设计动态通过改变微指令和微程序改变机器指令，有利于仿真，采用$EPROM$。
+ 毫微程序设计：微程序设计用微程序解种机器指令，毫微程序设计用毫微程序解释微程序。

## 指令流水线

### 流水线基本概念

#### 指令流水线定义

一条指令大致分为取指、分析、执行三个阶段（或者取指$IF$、译码/读寄存器$ID$、执行/计算地址$EX$、访存$MEM$、结果写回寄存器$WB$），设时间都为$t$，一共有$n$条指令：

1. 顺序执行：
   + 顺序执行所有指令。
   + 总耗时$3nt$。
   + 传统冯·诺依曼机采用顺序执行方式，又称串行执行方式。
   + 优点：控制简单，硬件代价小。
   + 缺点：执行指令的速度较慢，在任何时刻，处理机中只有一个指令在指令，各功能部件利用率都很低。
2. 一次重叠执行方式：
   + 在执行第$k$条指令的同时取第$k+1$条指令。
   + 总耗时$(1+2n)t$。
   + 优点：程序的执行时间缩短了$1/3$，各功能部件的利用率明患提高。
   + 缺点：需要付出硬件上较大开销的代价控制过程也比顺件执行复杂了。
3. 二次重叠执行方式：
   + 分析第$k$条指令的同时取$k+1$条指令，执行$k$条指令时分析$k+1$条指令与取$k+2$条指令。
   + 总耗时$(2+n)t$。
   + 与顺序执行方式相比，指令的执行时间缩短近$2/3$。
   + 这是一种理想的指令执行方式，在正常情况下,处理机中同时有$3$条指令在执行。
4. 指令流水方式：多次重叠执行方式就是流水线方式。

#### 流水线表示

1. 指令执行过程图：
   + 横坐标为时间，纵坐标为指令序列。
   + 每一行就是一条指令序列。
   + 主要用于分析指令执行过程以及影响流水线的因素。
2. 时空图：
   + 横坐标为时间，纵坐标为空间，即不同的阶段所对应的不同硬件资源，如：取指、译码、执行、存结果。
   + 每一斜着的一列就是一条指令序列。
   + 主要用于分析流水线的性能。

#### 指令集要求

1. 指令长度一致。
2. 指令格式规整，保证源寄存器位置相同。
3. 让$Load/Store$指令唯一访问存储器。
4. 数据和指令在存储器种对齐存放。

### 流水线影响因素

+ 理想情况：各阶段花费时间相同，每个阶段结束后能立即进入下一阶段。
+ 机器周期一般分为五段：取指$IF$、译码$ID$、执行$EX$、访存$M$、写回$WB$。
+ 假如各部件实际耗时：$100ns$、$80ns$、$70ns$、$50ns$、$50ns$，为方便流水线的设计，将每个阶段的耗时取成一样，以最长耗时为准。即此处应将机器周期设置为$100ns$。
+ 流水线每一个功能段部件后面都要有一个缓冲寄存器，或称为锁存器，其作用是保存本流水段的执行结果，提供给下一流水段使用。

#### 结构相关（资源冲突）

+ 由于多条指令在同一时刻争用同一资源而形成的冲突称为结构相关。
+ 解决办法：
  1. 后一相关指令暂停一周期。
  2. 单独设置数据存储器和指令寄存器。

#### 数据相关（数据冲突）

+ 数据相关指在一个程序中，存在必须等前一条指令执行完才能执行后一条指令的情况，则这两条指令即为数据相关。
+ 数据的基本操作：读、写。
+ 冲突的基本类型：
  + 写后读$RAW$：没有写完就读取，按序发射，按序完成只会出现写后读的错误。
  + 读后写$WAR$：乱序发射，优化手段导致指令顺序不符合编写程序时预想的逻辑顺序。
  + 写后写$WAW$：存在多个功能部件时，后一条指令先于前一条指令完成。
+ 解决办法:
   1. 把遇到数据相关的指令及其后续指令都暂停一至几个时钟周期，直到数据相关问题消失后再继续执行。可分为硬件阻塞（$stall$）和软件插入“$NOP$”（空指令）两种方法。
   2. 数据旁路技术：计算得到结果后不写回，直接当作输入使用。
   3. 编译优化：通过编译器调整指令顺序来解决数据相关。

#### 控制相关（控制冲突）

+ 当流水线遇到转移指令和其他改变$PC$值的指令而造成断流时，会引起控制相关。
+ 主要指转移指令。
+ 解决办法：
   1. 尽早判别转移是否发生，尽早生成转移目标地址。
   2. 预取转移成功和不成功两个控制流方向上的目标指令。
   3. 加快和提前形成条件码。
   4. 提高转移方向的猜准率。

### 流水线分类

+ 根据流水线使用的级别的不同：
  + 部件功能级流水就是将复杂的算术逻辑运算组成流水线工作方式。例如，可将浮点加法操作分成求阶差、对阶、尾数相加以及结果规格化等4个子过程。
  + 处理机级流水是把一条指令解释过程分成多个子过程，如前面提到的取指、译码、执行、访存及写回$5$个子过程。
  + 处理机间流水是一种宏流水，其中每一个处理机完成某一专门任务，各个处理机所得到的结果需存放在与下一个处理机所共享的存储器中。
+ 按流水线可以完成的功能：
  + 单功能流水线指只能实现一种固定的专门功能的流水线。
  + 多功能流水线指通过各段间的不同连接方式可以同时或不同时地实现多种功能的流水线。
+ 按同一时间内各段之间的连接方式：
  + 静态流水线指在同一时间内，流水线的各段只能按同一种功能的连接方式工作。
  + 动态流水线指在同一时间内，当某些段正在实现某种运算时，另一些段却正在进行另一种运算。这样对提高流水线的效率很有好处，但会使流水线控制变得很复杂。
+ 按流水线的各个功能段之间是否有反馈信息：
  + 线性流水线中，从输入到输出，每个功能段只允许经过一次，不存在反馈回路。
  + 非线性流水线存在反馈回路，从输入到输出过程中，某些功能段将数次通过流水线，这种流水线适合进行线性递归的运算。

### 流水线性能

1. 吞吐率：
   + 指在单位时间内流水线所完成的任务数量，或是输出结果的数量。
   + 设任务数为$n$，处理完成$n$个任务所用的时间为$T_k$，则计算流水线吞吐率$TP$的最基本的公式为$TP=\dfrac{n}{T_k}$。
   + 令每个指令分为$k$个阶段，每个阶段所需时间为$\Delta t$一般等于一个时钟周期，则理想状态下$T_k=(k+n-1)\Delta t$，所以$TP=\dfrac{n}{(k+n-1)\Delta t}$。
   + 第一个指令执行阶段称为装入时间，最后一个指令执行的阶段称为排空时间。
2. 加速比：
   + 完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比。
   + 设$T_0$表示不使用流水线时的执行时间，即顺序执行所用的时间；$T_k$表示使用流水线时的执行时间，则计算流水线加速比$S$的基本公式为$S=\dfrac{T_0}{T_k}$。
   + 单独完成一个任务需要$k\Delta t$，则顺序完成时间$T_0=nk\Delta t$。又$T_k=(k+n-1)\Delta t$，所以$S=\dfrac{nk\Delta t}{(k+n-1)\Delta t}=\dfrac{kn}{k+n-1}$。
3. 效率：
   + 流水线的设备利用率称为流水线的效率。
   + 在时空图上，流水线的效率定义为完成$n$个任务占用的时空区有效面积与$n$个任务所用的时间与k个流水段所围成的时空区总面积之比。（时空图中用到的类平行四边形面积除以围成矩形的面积）。
   + 流水线效率$E$的基本公式为$E=\dfrac{T_0}{kT_k}=\dfrac{n}{k+n-1}$。

### 流水线多发

1. 超标量技术：
   + 每个时钟周期内可并发多条独立指令。
   + 要配置多个功能部件。
   + 不能调整指令的执行顺序。
   + 可以结合动态调度技术优化。
2. 超流水技术：
   + 在一个时钟周期内再分段。
   + 在一个时钟周期内单个功能部件使用多次。
   + 不能调整指令的执行顺序，靠编译来优化。
3. 超长指令字：
   + 由编译程序挖掘出指令间潜在的并行性，将多条能并行操作的指令组合成一条具有多个操作码字段的超长指令字。
   + 需要更大的$Cache$。

## 多处理器

### 指令数据流结构

#### SISD

+ 单指令流和单数据流系统，即传统冯·诺依曼体系结构。
+ 只有一个处理器和存储器，一次性只执行一条指令。
+ 使用流水线技术，所以设置多个功能部件，采用多模块交叉存储器。

#### SIMD

+ 单指令流和多数据流系统。同时对多个数据进行处理，一般称为数据级并行技术。
+ 有一个指令控制部件和多个处理单元。
+ 每个处理单元有自己的地址寄存器。
+ 一个顺序程序被编译后可能串行也可能并行。
+ 适合循环结构，不适合选择结构。
+ 包括阵列处理器和向量处理器系统。向量处理器系统是一种实现了直接操作一维数组（向量）指令集的$CPU$，而串行处理器只能处理单一数据集。其基本理念是将从存储器中收集的一组数据按顺序放到一组向量寄存器中，然后以流水化的方式对它们依次操作，最后将结果写回寄存器。向量处理器在特定工作环境中极大地提升了性能，尤其是在数值模拟或者相似的领域中。

#### MISD

多指令流和单数据流系统，这种计算机实际上不存在。

#### MIMD

+ 多指令流和多数据流系统，是一种并行程度更高的线程级并行或线程级以上并行计算模式。
+ 包括多处理器和多计算机系统。
+ 多计算机系统中的每个计算机节点都具有各自的私有存储器，并且具有独立的主存地址空间，不能通过存取指令来访问不同节点的私有存储器，而要通过消息传递进行数据传送，也称消息传递$MIMD$。
+ 多处理器系统是共享存储多处理器（$SMP$）系统的简称，它具有共享的单一地址空间，通过存取指令来访问系统中的所有存储器，也称共享存储$MIMD$。

### 硬件多线程

为减少线程切换的开销，产生硬件多线程。在支持便件多线程的$CPU$中，必须为每个线
程提供单独的通用寄存器组、单独的程序计数器等，线程的切换只需激活选中的寄存器，从而
省略了与存储器数据交换的环节。

#### 细粒度多线程

多个线程之间轮流交叉执行指令，多个线程之间的指令是不相关的，可以乱序并行执行。

在这种方式下，处理器能在每个时钟周期切换线程。

时钟|当前执行指令所属线程
:--:|:------------------:
1|A
2|B
3|A
4|C
5|B

#### 粗粒度多线程

仅在一个线程出现了较大开销的阻塞时，才切换线程，如$Cache$缺失。

在这种方式下，当
发生流水线阻塞时，必须清除被阻塞的流水线，新线程的指令开始执行前需要重载流水线，因
此，线程切换的开销比细粒度多线程更大。

时钟|当前执行指令所属线程
:--:|:------------------:
1|A
2|A
3|B
4|B
5|C

#### 同时多线程

同时多线程（$SMT$）是上述两种多线程技术的变体。它在实现指令级并行的同时，实现线程级并行，也就是说，它在同一个时钟周期中，发射多个不同线程中的多条指令执行。

时钟|当前执行指令所属线程
:--:|:------------------:
1|AB
2|AC
3|BC

### 多核处理器

+ 多核处理器是指将多个处理单元集成到单个$CPU$中，每个处理单元称为一个核，可以同时执行多个运算。
+ 每个核可以有自己的$Cache$，也可以共享同一个$Cache$。
+ 所有核一般都是对称的，并且共享主存储器，因此多核属于共享存储的对称多处理器。

### 共享内存多处理器

具有共享的单一物理地址空间的多处理器被称为共享内存多处理器（$SMP$）。处理器通过存
储器中的共享变量互相通信，所有处理器都能通过存取指今访向任何存储器的位置。注意，即
使这些系统共享同一个物理地址空间，它们仍然可在自己的虚拟地址空间中单独地运行程序。

+ 统一存储访问（$UMA$）多处理器：
  + 每个处理器对所有存储单元的访问时间是大致相同的，即访问时间与哪个处理器提出访存请求及访问哪个字无关。
  + 根据处理器与共享存储器之间的连接方式，分为基于总线、基于交叉开关网络和基于多级交换网络连接等几种处理器。
  + 需要解决$Cache$一致性问题。
+ 非统一存储访问（$NUMA$）多处理器：
  + 某些访存请求要比其他的快，具体取决于哪个处理器提出了访问请求以及访问哪个字，这是由于主存被分割并分配给了同一机器上的不同处理器或内存控制器。
  + 处理器中不带高速缓存时，被称为$NC-NUMA$；处理器中带有一致性高速缓存时，被称为$CC-NUMA$。
  + 拓展性更强。
